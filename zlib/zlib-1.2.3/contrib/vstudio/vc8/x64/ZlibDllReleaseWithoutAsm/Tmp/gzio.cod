; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@ ; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	__imp_sprintf:PROC
EXTRN	__imp__fdopen:PROC
EXTRN	__imp_fopen:PROC
EXTRN	__imp_fprintf:PROC
EXTRN	__imp_ftell:PROC
EXTRN	__imp_ferror:PROC
EXTRN	__imp_fread:PROC
EXTRN	__imp__vsnprintf:PROC
EXTRN	__imp_fflush:PROC
EXTRN	__imp_fseek:PROC
EXTRN	__imp_fwrite:PROC
EXTRN	__imp_fclose:PROC
EXTRN	__imp_fputc:PROC
EXTRN	strcpy:PROC
EXTRN	strcat:PROC
EXTRN	strlen:PROC
EXTRN	__imp_strerror:PROC
EXTRN	__imp__errno:PROC
EXTRN	__imp_free:PROC
EXTRN	__imp_malloc:PROC
EXTRN	__imp_clearerr:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
CONST	SEGMENT
??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@ DB '%'
	DB	'c%c%c%c%c%c%c%c%c%c', 00H			; `string'
	ORG $+2
gz_magic DD	01fH
	DD	08bH
PUBLIC	gzclearerr
;	COMDAT pdata
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\gzio.c
pdata	SEGMENT
$pdata$gzclearerr DD imagerel $LN5
	DD	imagerel $LN5+84
	DD	imagerel $unwind$gzclearerr
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclearerr DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzclearerr
_TEXT	SEGMENT
s$ = 32
file$ = 64
gzclearerr PROC						; COMDAT

; 1019 : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1020 :     gz_stream *s = (gz_stream*)file;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 1021 : 
; 1022 :     if (s == NULL) return;

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 02		 jne	 SHORT $LN2@gzclearerr
  0001b	eb 32		 jmp	 SHORT $LN3@gzclearerr
$LN2@gzclearerr:

; 1023 :     if (s->z_err != Z_STREAM_END) s->z_err = Z_OK;

  0001d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00022	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00026	74 0c		 je	 SHORT $LN1@gzclearerr
  00028	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0002d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0
$LN1@gzclearerr:

; 1024 :     s->z_eof = 0;

  00034	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00039	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 1025 :     clearerr(s->file);

  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00045	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00049	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_clearerr
$LN3@gzclearerr:

; 1026 : }

  0004f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00053	c3		 ret	 0
gzclearerr ENDP
_TEXT	ENDS
PUBLIC	gzerror
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzerror DD imagerel $LN11
	DD	imagerel $LN11+406
	DD	imagerel $unwind$gzerror
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzerror DD 020f01H
	DD	0300b720fH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzerror
_TEXT	SEGMENT
s$ = 32
m$ = 40
tv73 = 48
file$ = 80
errnum$ = 88
gzerror	PROC						; COMDAT

; 990  : {

$LN11:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	53		 push	 rbx
  0000b	48 83 ec 40	 sub	 rsp, 64			; 00000040H

; 991  :     char *m;
; 992  :     gz_stream *s = (gz_stream*)file;

  0000f	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00014	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 993  : 
; 994  :     if (s == NULL) {

  00019	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  0001f	75 17		 jne	 SHORT $LN6@gzerror

; 995  :         *errnum = Z_STREAM_ERROR;

  00021	48 8b 44 24 58	 mov	 rax, QWORD PTR errnum$[rsp]
  00026	c7 00 fe ff ff
	ff		 mov	 DWORD PTR [rax], -2

; 996  :         return (const char*)ERR_MSG(Z_STREAM_ERROR);

  0002c	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  00033	e9 58 01 00 00	 jmp	 $LN7@gzerror
$LN6@gzerror:

; 997  :     }
; 998  :     *errnum = s->z_err;

  00038	48 8b 4c 24 58	 mov	 rcx, QWORD PTR errnum$[rsp]
  0003d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00042	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00045	89 01		 mov	 DWORD PTR [rcx], eax

; 999  :     if (*errnum == Z_OK) return (const char*)"";

  00047	48 8b 44 24 58	 mov	 rax, QWORD PTR errnum$[rsp]
  0004c	83 38 00	 cmp	 DWORD PTR [rax], 0
  0004f	75 0c		 jne	 SHORT $LN5@gzerror
  00051	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_00CNPNBAHC@?$AA@
  00058	e9 33 01 00 00	 jmp	 $LN7@gzerror
$LN5@gzerror:

; 1000 : 
; 1001 :     m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

  0005d	48 8b 44 24 58	 mov	 rax, QWORD PTR errnum$[rsp]
  00062	83 38 ff	 cmp	 DWORD PTR [rax], -1
  00065	75 15		 jne	 SHORT $LN9@gzerror
  00067	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  0006d	8b 08		 mov	 ecx, DWORD PTR [rax]
  0006f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_strerror
  00075	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
  0007a	eb 0e		 jmp	 SHORT $LN10@gzerror
$LN9@gzerror:
  0007c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00081	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00085	48 89 44 24 30	 mov	 QWORD PTR tv73[rsp], rax
$LN10@gzerror:
  0008a	48 8b 44 24 30	 mov	 rax, QWORD PTR tv73[rsp]
  0008f	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax

; 1002 : 
; 1003 :     if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

  00094	48 83 7c 24 28
	00		 cmp	 QWORD PTR m$[rsp], 0
  0009a	74 0c		 je	 SHORT $LN3@gzerror
  0009c	48 8b 44 24 28	 mov	 rax, QWORD PTR m$[rsp]
  000a1	0f be 00	 movsx	 eax, BYTE PTR [rax]
  000a4	85 c0		 test	 eax, eax
  000a6	75 20		 jne	 SHORT $LN4@gzerror
$LN3@gzerror:
  000a8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000ad	b8 02 00 00 00	 mov	 eax, 2
  000b2	2b 41 58	 sub	 eax, DWORD PTR [rcx+88]
  000b5	48 63 c8	 movsxd	 rcx, eax
  000b8	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:z_errmsg
  000bf	48 8b 04 c8	 mov	 rax, QWORD PTR [rax+rcx*8]
  000c3	48 89 44 24 28	 mov	 QWORD PTR m$[rsp], rax
$LN4@gzerror:

; 1004 : 
; 1005 :     TRYFREE(s->msg);

  000c8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000cd	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  000d5	74 12		 je	 SHORT $LN2@gzerror
  000d7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000dc	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  000e3	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@gzerror:

; 1006 :     s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);

  000e9	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000ee	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  000f5	e8 00 00 00 00	 call	 strlen
  000fa	48 8b d8	 mov	 rbx, rax
  000fd	48 8b 4c 24 28	 mov	 rcx, QWORD PTR m$[rsp]
  00102	e8 00 00 00 00	 call	 strlen
  00107	48 8d 4c 03 03	 lea	 rcx, QWORD PTR [rbx+rax+3]
  0010c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00112	4c 8b d8	 mov	 r11, rax
  00115	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0011a	4c 89 98 80 00
	00 00		 mov	 QWORD PTR [rax+128], r11

; 1007 :     if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR);

  00121	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00126	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  0012e	75 09		 jne	 SHORT $LN1@gzerror
  00130	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48
  00137	eb 57		 jmp	 SHORT $LN7@gzerror
$LN1@gzerror:

; 1008 :     strcpy(s->msg, s->path);

  00139	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  0013e	48 8b 92 88 00
	00 00		 mov	 rdx, QWORD PTR [rdx+136]
  00145	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0014a	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00151	e8 00 00 00 00	 call	 strcpy

; 1009 :     strcat(s->msg, ": ");

  00156	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_02LMMGGCAJ@?3?5?$AA@
  0015d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00162	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  00169	e8 00 00 00 00	 call	 strcat

; 1010 :     strcat(s->msg, m);

  0016e	48 8b 54 24 28	 mov	 rdx, QWORD PTR m$[rsp]
  00173	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00178	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0017f	e8 00 00 00 00	 call	 strcat

; 1011 :     return (const char*)s->msg;

  00184	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00189	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
$LN7@gzerror:

; 1012 : }

  00190	48 83 c4 40	 add	 rsp, 64			; 00000040H
  00194	5b		 pop	 rbx
  00195	c3		 ret	 0
gzerror	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$putLong DD imagerel putLong
	DD	imagerel putLong+80
	DD	imagerel $unwind$putLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$putLong DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT putLong
_TEXT	SEGMENT
n$ = 32
file$ = 64
x$ = 72
putLong	PROC						; COMDAT

; 923  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 924  :     int n;
; 925  :     for (n = 0; n < 4; n++) {

  0000d	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00015	eb 0b		 jmp	 SHORT $LN3@putLong
$LN2@putLong:
  00017	8b 44 24 20	 mov	 eax, DWORD PTR n$[rsp]
  0001b	83 c0 01	 add	 eax, 1
  0001e	89 44 24 20	 mov	 DWORD PTR n$[rsp], eax
$LN3@putLong:
  00022	83 7c 24 20 04	 cmp	 DWORD PTR n$[rsp], 4
  00027	7d 22		 jge	 SHORT $LN1@putLong

; 926  :         fputc((int)(x & 0xff), file);

  00029	8b 4c 24 48	 mov	 ecx, DWORD PTR x$[rsp]
  0002d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00033	48 8b 54 24 40	 mov	 rdx, QWORD PTR file$[rsp]
  00038	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fputc

; 927  :         x >>= 8;

  0003e	8b 44 24 48	 mov	 eax, DWORD PTR x$[rsp]
  00042	c1 e8 08	 shr	 eax, 8
  00045	89 44 24 48	 mov	 DWORD PTR x$[rsp], eax

; 928  :     }

  00049	eb cc		 jmp	 SHORT $LN2@putLong
$LN1@putLong:

; 929  : }

  0004b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004f	c3		 ret	 0
putLong	ENDP
_TEXT	ENDS
PUBLIC	gzeof
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzeof DD	imagerel $LN8
	DD	imagerel $LN8+99
	DD	imagerel $unwind$gzeof
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzeof DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzeof
_TEXT	SEGMENT
s$ = 0
tv72 = 8
file$ = 32
gzeof	PROC						; COMDAT

; 893  : {

$LN8:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 894  :     gz_stream *s = (gz_stream*)file;

  00009	48 8b 44 24 20	 mov	 rax, QWORD PTR file$[rsp]
  0000e	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 895  : 
; 896  :     /* With concatenated compressed files that can have embedded
; 897  :      * crc trailers, z_eof is no longer the only/best indicator of EOF
; 898  :      * on a gz_stream. Handle end-of-stream error explicitly here.
; 899  :      */
; 900  :     if (s == NULL || s->mode != 'r') return 0;

  00012	48 83 3c 24 00	 cmp	 QWORD PTR s$[rsp], 0
  00017	74 10		 je	 SHORT $LN2@gzeof
  00019	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0001d	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00024	83 f8 72	 cmp	 eax, 114		; 00000072H
  00027	74 04		 je	 SHORT $LN3@gzeof
$LN2@gzeof:
  00029	33 c0		 xor	 eax, eax
  0002b	eb 31		 jmp	 SHORT $LN4@gzeof
$LN3@gzeof:

; 901  :     if (s->z_eof) return 1;

  0002d	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00031	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00035	74 07		 je	 SHORT $LN1@gzeof
  00037	b8 01 00 00 00	 mov	 eax, 1
  0003c	eb 20		 jmp	 SHORT $LN4@gzeof
$LN1@gzeof:

; 902  :     return s->z_err == Z_STREAM_END;

  0003e	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00042	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00046	75 0a		 jne	 SHORT $LN6@gzeof
  00048	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv72[rsp], 1
  00050	eb 08		 jmp	 SHORT $LN7@gzeof
$LN6@gzeof:
  00052	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv72[rsp], 0
$LN7@gzeof:
  0005a	8b 44 24 08	 mov	 eax, DWORD PTR tv72[rsp]
$LN4@gzeof:

; 903  : }

  0005e	48 83 c4 18	 add	 rsp, 24
  00062	c3		 ret	 0
gzeof	ENDP
_TEXT	ENDS
PUBLIC	gzungetc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzungetc DD imagerel $LN8
	DD	imagerel $LN8+195
	DD	imagerel $unwind$gzungetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzungetc DD 010d01H
	DD	0220dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzungetc
_TEXT	SEGMENT
s$ = 0
tv79 = 8
c$ = 32
file$ = 40
gzungetc PROC						; COMDAT

; 518  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 18	 sub	 rsp, 24

; 519  :     gz_stream *s = (gz_stream*)file;

  0000d	48 8b 44 24 28	 mov	 rax, QWORD PTR file$[rsp]
  00012	48 89 04 24	 mov	 QWORD PTR s$[rsp], rax

; 520  : 
; 521  :     if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;

  00016	48 83 3c 24 00	 cmp	 QWORD PTR s$[rsp], 0
  0001b	74 24		 je	 SHORT $LN2@gzungetc
  0001d	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00021	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00028	83 f8 72	 cmp	 eax, 114		; 00000072H
  0002b	75 14		 jne	 SHORT $LN2@gzungetc
  0002d	83 7c 24 20 ff	 cmp	 DWORD PTR c$[rsp], -1
  00032	74 0d		 je	 SHORT $LN2@gzungetc
  00034	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00038	83 b8 a4 00 00
	00 ff		 cmp	 DWORD PTR [rax+164], -1
  0003f	74 07		 je	 SHORT $LN3@gzungetc
$LN2@gzungetc:
  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	eb 76		 jmp	 SHORT $LN4@gzungetc
$LN3@gzungetc:

; 522  :     s->back = c;

  00048	48 8b 0c 24	 mov	 rcx, QWORD PTR s$[rsp]
  0004c	8b 44 24 20	 mov	 eax, DWORD PTR c$[rsp]
  00050	89 81 a4 00 00
	00		 mov	 DWORD PTR [rcx+164], eax

; 523  :     s->out--;

  00056	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0005a	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  00060	83 e9 01	 sub	 ecx, 1
  00063	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00067	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 524  :     s->last = (s->z_err == Z_STREAM_END);

  0006d	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  00071	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00075	75 0a		 jne	 SHORT $LN6@gzungetc
  00077	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv79[rsp], 1
  0007f	eb 08		 jmp	 SHORT $LN7@gzungetc
$LN6@gzungetc:
  00081	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN7@gzungetc:
  00089	48 8b 0c 24	 mov	 rcx, QWORD PTR s$[rsp]
  0008d	8b 44 24 08	 mov	 eax, DWORD PTR tv79[rsp]
  00091	89 81 a8 00 00
	00		 mov	 DWORD PTR [rcx+168], eax

; 525  :     if (s->last) s->z_err = Z_OK;

  00097	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  0009b	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [rax+168], 0
  000a2	74 0b		 je	 SHORT $LN1@gzungetc
  000a4	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000a8	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0
$LN1@gzungetc:

; 526  :     s->z_eof = 0;

  000af	48 8b 04 24	 mov	 rax, QWORD PTR s$[rsp]
  000b3	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 527  :     return c;

  000ba	8b 44 24 20	 mov	 eax, DWORD PTR c$[rsp]
$LN4@gzungetc:

; 528  : }

  000be	48 83 c4 18	 add	 rsp, 24
  000c2	c3		 ret	 0
gzungetc ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$get_byte DD imagerel get_byte
	DD	imagerel get_byte+246
	DD	imagerel $unwind$get_byte
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$get_byte DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT get_byte
_TEXT	SEGMENT
tv93 = 32
s$ = 64
get_byte PROC						; COMDAT

; 263  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 264  :     if (s->z_eof) return EOF;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0000e	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00012	74 0a		 je	 SHORT $LN4@get_byte
  00014	b8 ff ff ff ff	 mov	 eax, -1
  00019	e9 d3 00 00 00	 jmp	 $LN5@get_byte
$LN4@get_byte:

; 265  :     if (s->stream.avail_in == 0) {

  0001e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00023	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00027	0f 85 89 00 00
	00		 jne	 $LN3@get_byte

; 266  :         errno = 0;

  0002d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00033	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 267  :         s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);

  00039	4c 8b 4c 24 40	 mov	 r9, QWORD PTR s$[rsp]
  0003e	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  00042	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  00048	ba 01 00 00 00	 mov	 edx, 1
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00052	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00056	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0005c	4c 8b d8	 mov	 r11, rax
  0005f	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00064	44 89 58 08	 mov	 DWORD PTR [rax+8], r11d

; 268  :         if (s->stream.avail_in == 0) {

  00068	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0006d	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00071	75 32		 jne	 SHORT $LN2@get_byte

; 269  :             s->z_eof = 1;

  00073	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00078	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [rax+92], 1

; 270  :             if (ferror(s->file)) s->z_err = Z_ERRNO;

  0007f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00084	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00088	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  0008e	85 c0		 test	 eax, eax
  00090	74 0c		 je	 SHORT $LN1@get_byte
  00092	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00097	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1
$LN1@get_byte:

; 271  :             return EOF;

  0009e	b8 ff ff ff ff	 mov	 eax, -1
  000a3	eb 4c		 jmp	 SHORT $LN5@get_byte
$LN2@get_byte:

; 272  :         }
; 273  :         s->stream.next_in = s->inbuf;

  000a5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000aa	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000af	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000b3	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN3@get_byte:

; 274  :     }
; 275  :     s->stream.avail_in--;

  000b6	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000bb	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000be	83 e9 01	 sub	 ecx, 1
  000c1	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000c6	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 276  :     return *(s->stream.next_in)++;

  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000ce	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000d1	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d4	88 44 24 20	 mov	 BYTE PTR tv93[rsp], al
  000d8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000dd	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  000e0	48 83 c1 01	 add	 rcx, 1
  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000e9	48 89 08	 mov	 QWORD PTR [rax], rcx
  000ec	0f b6 44 24 20	 movzx	 eax, BYTE PTR tv93[rsp]
$LN5@get_byte:

; 277  : }

  000f1	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000f5	c3		 ret	 0
get_byte ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$getLong DD imagerel getLong
	DD	imagerel getLong+132
	DD	imagerel $unwind$getLong
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$getLong DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT getLong
_TEXT	SEGMENT
x$ = 32
c$ = 36
s$ = 64
getLong	PROC						; COMDAT

; 937  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 938  :     uLong x = (uLong)get_byte(s);

  00009	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0000e	e8 00 00 00 00	 call	 get_byte
  00013	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 939  :     int c;
; 940  : 
; 941  :     x += ((uLong)get_byte(s))<<8;

  00017	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001c	e8 00 00 00 00	 call	 get_byte
  00021	8b c8		 mov	 ecx, eax
  00023	c1 e1 08	 shl	 ecx, 8
  00026	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  0002a	03 c1		 add	 eax, ecx
  0002c	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 942  :     x += ((uLong)get_byte(s))<<16;

  00030	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00035	e8 00 00 00 00	 call	 get_byte
  0003a	8b c8		 mov	 ecx, eax
  0003c	c1 e1 10	 shl	 ecx, 16
  0003f	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00043	03 c1		 add	 eax, ecx
  00045	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 943  :     c = get_byte(s);

  00049	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0004e	e8 00 00 00 00	 call	 get_byte
  00053	89 44 24 24	 mov	 DWORD PTR c$[rsp], eax

; 944  :     if (c == EOF) s->z_err = Z_DATA_ERROR;

  00057	83 7c 24 24 ff	 cmp	 DWORD PTR c$[rsp], -1
  0005c	75 0c		 jne	 SHORT $LN1@getLong
  0005e	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00063	c7 40 58 fd ff
	ff ff		 mov	 DWORD PTR [rax+88], -3
$LN1@getLong:

; 945  :     x += ((uLong)c)<<24;

  0006a	8b 4c 24 24	 mov	 ecx, DWORD PTR c$[rsp]
  0006e	c1 e1 18	 shl	 ecx, 24
  00071	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]
  00075	03 c1		 add	 eax, ecx
  00077	89 44 24 20	 mov	 DWORD PTR x$[rsp], eax

; 946  :     return x;

  0007b	8b 44 24 20	 mov	 eax, DWORD PTR x$[rsp]

; 947  : }

  0007f	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00083	c3		 ret	 0
getLong	ENDP
_TEXT	ENDS
PUBLIC	gzrewind
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzrewind DD imagerel $LN6
	DD	imagerel $LN6+234
	DD	imagerel $unwind$gzrewind
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzrewind DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzrewind
_TEXT	SEGMENT
s$ = 32
file$ = 64
gzrewind PROC						; COMDAT

; 859  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 860  :     gz_stream *s = (gz_stream*)file;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 861  : 
; 862  :     if (s == NULL || s->mode != 'r') return -1;

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	74 11		 je	 SHORT $LN2@gzrewind
  0001b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00020	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00027	83 f8 72	 cmp	 eax, 114		; 00000072H
  0002a	74 0a		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:
  0002c	b8 ff ff ff ff	 mov	 eax, -1
  00031	e9 af 00 00 00	 jmp	 $LN4@gzrewind
$LN3@gzrewind:

; 863  : 
; 864  :     s->z_err = Z_OK;

  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0003b	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 865  :     s->z_eof = 0;

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00047	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 866  :     s->back = EOF;

  0004e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00053	c7 80 a4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+164], -1

; 867  :     s->stream.avail_in = 0;

  0005d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00062	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 868  :     s->stream.next_in = s->inbuf;

  00069	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0006e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00073	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00077	48 89 01	 mov	 QWORD PTR [rcx], rax

; 869  :     s->crc = crc32(0L, Z_NULL, 0);

  0007a	45 33 c0	 xor	 r8d, r8d
  0007d	33 d2		 xor	 edx, edx
  0007f	33 c9		 xor	 ecx, ecx
  00081	e8 00 00 00 00	 call	 crc32
  00086	44 8b d8	 mov	 r11d, eax
  00089	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0008e	44 89 58 78	 mov	 DWORD PTR [rax+120], r11d

; 870  :     if (!s->transparent) (void)inflateReset(&s->stream);

  00092	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00097	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  0009e	75 0a		 jne	 SHORT $LN1@gzrewind
  000a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000a5	e8 00 00 00 00	 call	 inflateReset
$LN1@gzrewind:

; 871  :     s->in = 0;

  000aa	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000af	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 872  :     s->out = 0;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000be	c7 80 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+160], 0

; 873  :     return fseek(s->file, s->start, SEEK_SET);

  000c8	45 33 c0	 xor	 r8d, r8d
  000cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000d0	8b 90 98 00 00
	00		 mov	 edx, DWORD PTR [rax+152]
  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000db	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000df	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
$LN4@gzrewind:

; 874  : }

  000e5	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000e9	c3		 ret	 0
gzrewind ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$destroy DD imagerel destroy
	DD	imagerel destroy+332
	DD	imagerel $unwind$destroy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$destroy DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT destroy
_TEXT	SEGMENT
err$ = 32
s$ = 64
destroy	PROC						; COMDAT

; 357  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 358  :     int err = Z_OK;

  00009	c7 44 24 20 00
	00 00 00	 mov	 DWORD PTR err$[rsp], 0

; 359  : 
; 360  :     if (!s) return Z_STREAM_ERROR;

  00011	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00017	75 0a		 jne	 SHORT $LN13@destroy
  00019	b8 fe ff ff ff	 mov	 eax, -2
  0001e	e9 24 01 00 00	 jmp	 $LN14@destroy
$LN13@destroy:

; 361  : 
; 362  :     TRYFREE(s->msg);

  00023	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00028	48 83 b8 80 00
	00 00 00	 cmp	 QWORD PTR [rax+128], 0
  00030	74 12		 je	 SHORT $LN12@destroy
  00032	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00037	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  0003e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN12@destroy:

; 363  : 
; 364  :     if (s->stream.state != NULL) {

  00044	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00049	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0004e	74 40		 je	 SHORT $LN11@destroy

; 365  :         if (s->mode == 'w') {

  00050	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00055	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  0005c	83 f8 77	 cmp	 eax, 119		; 00000077H
  0005f	75 10		 jne	 SHORT $LN10@destroy

; 366  : #ifdef NO_GZCOMPRESS
; 367  :             err = Z_STREAM_ERROR;
; 368  : #else
; 369  :             err = deflateEnd(&(s->stream));

  00061	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00066	e8 00 00 00 00	 call	 deflateEnd
  0006b	89 44 24 20	 mov	 DWORD PTR err$[rsp], eax
  0006f	eb 1f		 jmp	 SHORT $LN9@destroy
$LN10@destroy:

; 370  : #endif
; 371  :         } else if (s->mode == 'r') {

  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00076	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  0007d	83 f8 72	 cmp	 eax, 114		; 00000072H
  00080	75 0e		 jne	 SHORT $LN8@destroy

; 372  :             err = inflateEnd(&(s->stream));

  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00087	e8 00 00 00 00	 call	 inflateEnd
  0008c	89 44 24 20	 mov	 DWORD PTR err$[rsp], eax
$LN8@destroy:
$LN9@destroy:
$LN11@destroy:

; 373  :         }
; 374  :     }
; 375  :     if (s->file != NULL && fclose(s->file)) {

  00090	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00095	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0009a	74 26		 je	 SHORT $LN7@destroy
  0009c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000a1	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000a5	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fclose
  000ab	85 c0		 test	 eax, eax
  000ad	74 13		 je	 SHORT $LN7@destroy

; 376  : #ifdef ESPIPE
; 377  :         if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */

  000af	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  000b5	83 38 1d	 cmp	 DWORD PTR [rax], 29
  000b8	74 08		 je	 SHORT $LN6@destroy

; 378  : #endif
; 379  :             err = Z_ERRNO;

  000ba	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR err$[rsp], -1
$LN6@destroy:
$LN7@destroy:

; 380  :     }
; 381  :     if (s->z_err < 0) err = s->z_err;

  000c2	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000c7	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  000cb	7d 0c		 jge	 SHORT $LN5@destroy
  000cd	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000d2	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  000d5	89 44 24 20	 mov	 DWORD PTR err$[rsp], eax
$LN5@destroy:

; 382  : 
; 383  :     TRYFREE(s->inbuf);

  000d9	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000de	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000e3	74 0f		 je	 SHORT $LN4@destroy
  000e5	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  000ea	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000ee	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN4@destroy:

; 384  :     TRYFREE(s->outbuf);

  000f4	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  000f9	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  000fe	74 0f		 je	 SHORT $LN3@destroy
  00100	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00105	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00109	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN3@destroy:

; 385  :     TRYFREE(s->path);

  0010f	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00114	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  0011c	74 12		 je	 SHORT $LN2@destroy
  0011e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00123	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  0012a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN2@destroy:

; 386  :     TRYFREE(s);

  00130	48 83 7c 24 40
	00		 cmp	 QWORD PTR s$[rsp], 0
  00136	74 0b		 je	 SHORT $LN1@destroy
  00138	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0013d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_free
$LN1@destroy:

; 387  :     return err;

  00143	8b 44 24 20	 mov	 eax, DWORD PTR err$[rsp]
$LN14@destroy:

; 388  : }

  00147	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0014b	c3		 ret	 0
destroy	ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$check_header DD imagerel check_header
	DD	imagerel check_header+702
	DD	imagerel $unwind$check_header
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$check_header DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT check_header
_TEXT	SEGMENT
method$ = 32
flags$ = 36
len$ = 40
c$ = 44
tv185 = 48
s$ = 80
check_header PROC					; COMDAT

; 290  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 291  :     int method; /* method byte */
; 292  :     int flags;  /* flags byte */
; 293  :     uInt len;
; 294  :     int c;
; 295  : 
; 296  :     /* Assure two bytes in the buffer so we can peek ahead -- handle case
; 297  :        where first byte of header is at the end of the buffer after the last
; 298  :        gzip segment */
; 299  :     len = s->stream.avail_in;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00011	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 300  :     if (len < 2) {

  00015	83 7c 24 28 02	 cmp	 DWORD PTR len$[rsp], 2
  0001a	0f 83 ca 00 00
	00		 jae	 $LN24@check_head

; 301  :         if (len) s->inbuf[0] = s->stream.next_in[0];

  00020	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00025	74 16		 je	 SHORT $LN23@check_head
  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0002c	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0002f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00034	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00038	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0003b	88 01		 mov	 BYTE PTR [rcx], al
$LN23@check_head:

; 302  :         errno = 0;

  0003d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00043	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 303  :         len = (uInt)fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);

  00049	8b 4c 24 28	 mov	 ecx, DWORD PTR len$[rsp]
  0004d	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00052	d3 f8		 sar	 eax, cl
  00054	4c 63 c0	 movsxd	 r8, eax
  00057	8b 4c 24 28	 mov	 ecx, DWORD PTR len$[rsp]
  0005b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00060	48 03 48 68	 add	 rcx, QWORD PTR [rax+104]
  00064	4c 8b 4c 24 50	 mov	 r9, QWORD PTR s$[rsp]
  00069	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  0006d	ba 01 00 00 00	 mov	 edx, 1
  00072	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00078	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 304  :         if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;

  0007c	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00081	75 1f		 jne	 SHORT $LN22@check_head
  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00088	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0008c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00092	85 c0		 test	 eax, eax
  00094	74 0c		 je	 SHORT $LN22@check_head
  00096	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0009b	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1
$LN22@check_head:

; 305  :         s->stream.avail_in += len;

  000a2	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000a7	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  000aa	03 4c 24 28	 add	 ecx, DWORD PTR len$[rsp]
  000ae	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000b3	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 306  :         s->stream.next_in = s->inbuf;

  000b6	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000bb	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000c0	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  000c4	48 89 01	 mov	 QWORD PTR [rcx], rax

; 307  :         if (s->stream.avail_in < 2) {

  000c7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000cc	83 78 08 02	 cmp	 DWORD PTR [rax+8], 2
  000d0	73 18		 jae	 SHORT $LN21@check_head

; 308  :             s->transparent = s->stream.avail_in;

  000d2	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000d7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000dc	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000df	89 81 90 00 00
	00		 mov	 DWORD PTR [rcx+144], eax

; 309  :             return;

  000e5	e9 cf 01 00 00	 jmp	 $LN25@check_head
$LN21@check_head:
$LN24@check_head:

; 310  :         }
; 311  :     }
; 312  : 
; 313  :     /* Peek ahead to check the gzip magic header */
; 314  :     if (s->stream.next_in[0] != gz_magic[0] ||
; 315  :         s->stream.next_in[1] != gz_magic[1]) {

  000ea	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000ef	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000f2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000f5	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR gz_magic
  000fb	75 14		 jne	 SHORT $LN19@check_head
  000fd	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00102	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00105	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  00109	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR gz_magic+4
  0010f	74 14		 je	 SHORT $LN20@check_head
$LN19@check_head:

; 316  :         s->transparent = 1;

  00111	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00116	c7 80 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+144], 1

; 317  :         return;

  00120	e9 94 01 00 00	 jmp	 $LN25@check_head
$LN20@check_head:

; 318  :     }
; 319  :     s->stream.avail_in -= 2;

  00125	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0012a	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0012d	83 e9 02	 sub	 ecx, 2
  00130	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00135	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 320  :     s->stream.next_in += 2;

  00138	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0013d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00140	48 83 c1 02	 add	 rcx, 2
  00144	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00149	48 89 08	 mov	 QWORD PTR [rax], rcx

; 321  : 
; 322  :     /* Check the rest of the gzip header */
; 323  :     method = get_byte(s);

  0014c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00151	e8 00 00 00 00	 call	 get_byte
  00156	89 44 24 20	 mov	 DWORD PTR method$[rsp], eax

; 324  :     flags = get_byte(s);

  0015a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0015f	e8 00 00 00 00	 call	 get_byte
  00164	89 44 24 24	 mov	 DWORD PTR flags$[rsp], eax

; 325  :     if (method != Z_DEFLATED || (flags & RESERVED) != 0) {

  00168	83 7c 24 20 08	 cmp	 DWORD PTR method$[rsp], 8
  0016d	75 0d		 jne	 SHORT $LN17@check_head
  0016f	8b 44 24 24	 mov	 eax, DWORD PTR flags$[rsp]
  00173	25 e0 00 00 00	 and	 eax, 224		; 000000e0H
  00178	85 c0		 test	 eax, eax
  0017a	74 11		 je	 SHORT $LN18@check_head
$LN17@check_head:

; 326  :         s->z_err = Z_DATA_ERROR;

  0017c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00181	c7 40 58 fd ff
	ff ff		 mov	 DWORD PTR [rax+88], -3

; 327  :         return;

  00188	e9 2c 01 00 00	 jmp	 $LN25@check_head
$LN18@check_head:

; 328  :     }
; 329  : 
; 330  :     /* Discard time, xflags and OS code: */
; 331  :     for (len = 0; len < 6; len++) (void)get_byte(s);

  0018d	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00195	eb 0b		 jmp	 SHORT $LN16@check_head
$LN15@check_head:
  00197	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  0019b	83 c0 01	 add	 eax, 1
  0019e	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
$LN16@check_head:
  001a2	83 7c 24 28 06	 cmp	 DWORD PTR len$[rsp], 6
  001a7	73 0c		 jae	 SHORT $LN14@check_head
  001a9	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001ae	e8 00 00 00 00	 call	 get_byte
  001b3	eb e2		 jmp	 SHORT $LN15@check_head
$LN14@check_head:

; 332  : 
; 333  :     if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */

  001b5	8b 44 24 24	 mov	 eax, DWORD PTR flags$[rsp]
  001b9	83 e0 04	 and	 eax, 4
  001bc	85 c0		 test	 eax, eax
  001be	74 4b		 je	 SHORT $LN13@check_head

; 334  :         len  =  (uInt)get_byte(s);

  001c0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001c5	e8 00 00 00 00	 call	 get_byte
  001ca	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 335  :         len += ((uInt)get_byte(s))<<8;

  001ce	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001d3	e8 00 00 00 00	 call	 get_byte
  001d8	8b c8		 mov	 ecx, eax
  001da	c1 e1 08	 shl	 ecx, 8
  001dd	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  001e1	03 c1		 add	 eax, ecx
  001e3	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
$LN12@check_head:

; 336  :         /* len is garbage if EOF but the loop below will quit anyway */
; 337  :         while (len-- != 0 && get_byte(s) != EOF) ;

  001e7	8b 4c 24 28	 mov	 ecx, DWORD PTR len$[rsp]
  001eb	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  001ef	83 e8 01	 sub	 eax, 1
  001f2	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
  001f6	85 c9		 test	 ecx, ecx
  001f8	74 11		 je	 SHORT $LN11@check_head
  001fa	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  001ff	e8 00 00 00 00	 call	 get_byte
  00204	83 f8 ff	 cmp	 eax, -1
  00207	74 02		 je	 SHORT $LN11@check_head
  00209	eb dc		 jmp	 SHORT $LN12@check_head
$LN11@check_head:
$LN13@check_head:

; 338  :     }
; 339  :     if ((flags & ORIG_NAME) != 0) { /* skip the original file name */

  0020b	8b 44 24 24	 mov	 eax, DWORD PTR flags$[rsp]
  0020f	83 e0 08	 and	 eax, 8
  00212	85 c0		 test	 eax, eax
  00214	74 1e		 je	 SHORT $LN10@check_head
$LN9@check_head:

; 340  :         while ((c = get_byte(s)) != 0 && c != EOF) ;

  00216	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0021b	e8 00 00 00 00	 call	 get_byte
  00220	89 44 24 2c	 mov	 DWORD PTR c$[rsp], eax
  00224	83 7c 24 2c 00	 cmp	 DWORD PTR c$[rsp], 0
  00229	74 09		 je	 SHORT $LN8@check_head
  0022b	83 7c 24 2c ff	 cmp	 DWORD PTR c$[rsp], -1
  00230	74 02		 je	 SHORT $LN8@check_head
  00232	eb e2		 jmp	 SHORT $LN9@check_head
$LN8@check_head:
$LN10@check_head:

; 341  :     }
; 342  :     if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */

  00234	8b 44 24 24	 mov	 eax, DWORD PTR flags$[rsp]
  00238	83 e0 10	 and	 eax, 16
  0023b	85 c0		 test	 eax, eax
  0023d	74 1e		 je	 SHORT $LN7@check_head
$LN6@check_head:

; 343  :         while ((c = get_byte(s)) != 0 && c != EOF) ;

  0023f	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00244	e8 00 00 00 00	 call	 get_byte
  00249	89 44 24 2c	 mov	 DWORD PTR c$[rsp], eax
  0024d	83 7c 24 2c 00	 cmp	 DWORD PTR c$[rsp], 0
  00252	74 09		 je	 SHORT $LN5@check_head
  00254	83 7c 24 2c ff	 cmp	 DWORD PTR c$[rsp], -1
  00259	74 02		 je	 SHORT $LN5@check_head
  0025b	eb e2		 jmp	 SHORT $LN6@check_head
$LN5@check_head:
$LN7@check_head:

; 344  :     }
; 345  :     if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */

  0025d	8b 44 24 24	 mov	 eax, DWORD PTR flags$[rsp]
  00261	83 e0 02	 and	 eax, 2
  00264	85 c0		 test	 eax, eax
  00266	74 28		 je	 SHORT $LN4@check_head

; 346  :         for (len = 0; len < 2; len++) (void)get_byte(s);

  00268	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00270	eb 0b		 jmp	 SHORT $LN3@check_head
$LN2@check_head:
  00272	8b 44 24 28	 mov	 eax, DWORD PTR len$[rsp]
  00276	83 c0 01	 add	 eax, 1
  00279	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax
$LN3@check_head:
  0027d	83 7c 24 28 02	 cmp	 DWORD PTR len$[rsp], 2
  00282	73 0c		 jae	 SHORT $LN1@check_head
  00284	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00289	e8 00 00 00 00	 call	 get_byte
  0028e	eb e2		 jmp	 SHORT $LN2@check_head
$LN1@check_head:
$LN4@check_head:

; 347  :     }
; 348  :     s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;

  00290	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00295	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  00299	74 0a		 je	 SHORT $LN27@check_head
  0029b	c7 44 24 30 fd
	ff ff ff	 mov	 DWORD PTR tv185[rsp], -3
  002a3	eb 08		 jmp	 SHORT $LN28@check_head
$LN27@check_head:
  002a5	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv185[rsp], 0
$LN28@check_head:
  002ad	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  002b2	8b 44 24 30	 mov	 eax, DWORD PTR tv185[rsp]
  002b6	89 41 58	 mov	 DWORD PTR [rcx+88], eax
$LN25@check_head:

; 349  : }

  002b9	48 83 c4 48	 add	 rsp, 72			; 00000048H
  002bd	c3		 ret	 0
check_header ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$do_flush DD imagerel do_flush
	DD	imagerel do_flush+443
	DD	imagerel $unwind$do_flush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$do_flush DD 010d01H
	DD	0820dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT do_flush
_TEXT	SEGMENT
s$ = 32
len$ = 40
done$ = 44
tv139 = 48
tv147 = 52
file$ = 80
flush$ = 88
do_flush PROC						; COMDAT

; 708  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 709  :     uInt len;
; 710  :     int done = 0;

  0000d	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR done$[rsp], 0

; 711  :     gz_stream *s = (gz_stream*)file;

  00015	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  0001a	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 712  : 
; 713  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  0001f	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00025	74 11		 je	 SHORT $LN8@do_flush
  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0002c	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00033	83 f8 77	 cmp	 eax, 119		; 00000077H
  00036	74 0a		 je	 SHORT $LN9@do_flush
$LN8@do_flush:
  00038	b8 fe ff ff ff	 mov	 eax, -2
  0003d	e9 74 01 00 00	 jmp	 $LN10@do_flush
$LN9@do_flush:

; 714  : 
; 715  :     s->stream.avail_in = 0; /* should be zero already anyway */

  00042	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00047	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0
$LN7@do_flush:

; 716  : 
; 717  :     for (;;) {
; 718  :         len = Z_BUFSIZE - s->stream.avail_out;

  0004e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00053	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00058	2b 41 18	 sub	 eax, DWORD PTR [rcx+24]
  0005b	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 719  : 
; 720  :         if (len != 0) {

  0005f	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00064	74 5c		 je	 SHORT $LN5@do_flush

; 721  :             if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {

  00066	44 8b 44 24 28	 mov	 r8d, DWORD PTR len$[rsp]
  0006b	4c 8b 4c 24 20	 mov	 r9, QWORD PTR s$[rsp]
  00070	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  00074	ba 01 00 00 00	 mov	 edx, 1
  00079	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0007e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00082	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  00088	3b 44 24 28	 cmp	 eax, DWORD PTR len$[rsp]
  0008c	74 16		 je	 SHORT $LN4@do_flush

; 722  :                 s->z_err = Z_ERRNO;

  0008e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00093	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1

; 723  :                 return Z_ERRNO;

  0009a	b8 ff ff ff ff	 mov	 eax, -1
  0009f	e9 12 01 00 00	 jmp	 $LN10@do_flush
$LN4@do_flush:

; 724  :             }
; 725  :             s->stream.next_out = s->outbuf;

  000a4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000a9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ae	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  000b2	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 726  :             s->stream.avail_out = Z_BUFSIZE;

  000b6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000bb	c7 40 18 00 40
	00 00		 mov	 DWORD PTR [rax+24], 16384 ; 00004000H
$LN5@do_flush:

; 727  :         }
; 728  :         if (done) break;

  000c2	83 7c 24 2c 00	 cmp	 DWORD PTR done$[rsp], 0
  000c7	74 05		 je	 SHORT $LN3@do_flush
  000c9	e9 c3 00 00 00	 jmp	 $LN6@do_flush
$LN3@do_flush:

; 729  :         s->out += s->stream.avail_out;

  000ce	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000d3	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  000d9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000de	03 48 18	 add	 ecx, DWORD PTR [rax+24]
  000e1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e6	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 730  :         s->z_err = deflate(&(s->stream), flush);

  000ec	8b 54 24 58	 mov	 edx, DWORD PTR flush$[rsp]
  000f0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000f5	e8 00 00 00 00	 call	 deflate
  000fa	44 8b d8	 mov	 r11d, eax
  000fd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00102	44 89 58 58	 mov	 DWORD PTR [rax+88], r11d

; 731  :         s->out -= s->stream.avail_out;

  00106	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0010b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00110	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00113	8b 89 a0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+160]
  00119	2b c8		 sub	 ecx, eax
  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00120	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 732  : 
; 733  :         /* Ignore the second of two consecutive flushes: */
; 734  :         if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

  00126	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  0012b	75 17		 jne	 SHORT $LN2@do_flush
  0012d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00132	83 78 58 fb	 cmp	 DWORD PTR [rax+88], -5
  00136	75 0c		 jne	 SHORT $LN2@do_flush
  00138	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0013d	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0
$LN2@do_flush:

; 735  : 
; 736  :         /* deflate has finished flushing only when it hasn't used up
; 737  :          * all the available space in the output buffer:
; 738  :          */
; 739  :         done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);

  00144	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00149	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0014d	75 15		 jne	 SHORT $LN12@do_flush
  0014f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00154	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00158	74 0a		 je	 SHORT $LN12@do_flush
  0015a	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR tv139[rsp], 0
  00162	eb 08		 jmp	 SHORT $LN13@do_flush
$LN12@do_flush:
  00164	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR tv139[rsp], 1
$LN13@do_flush:
  0016c	8b 44 24 30	 mov	 eax, DWORD PTR tv139[rsp]
  00170	89 44 24 2c	 mov	 DWORD PTR done$[rsp], eax

; 740  : 
; 741  :         if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;

  00174	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00179	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  0017d	74 0d		 je	 SHORT $LN1@do_flush
  0017f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00184	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00188	74 02		 je	 SHORT $LN1@do_flush
  0018a	eb 05		 jmp	 SHORT $LN6@do_flush
$LN1@do_flush:

; 742  :     }

  0018c	e9 bd fe ff ff	 jmp	 $LN7@do_flush
$LN6@do_flush:

; 743  :     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;

  00191	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00196	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  0019a	75 0a		 jne	 SHORT $LN14@do_flush
  0019c	c7 44 24 34 00
	00 00 00	 mov	 DWORD PTR tv147[rsp], 0
  001a4	eb 0c		 jmp	 SHORT $LN15@do_flush
$LN14@do_flush:
  001a6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ab	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  001ae	89 44 24 34	 mov	 DWORD PTR tv147[rsp], eax
$LN15@do_flush:
  001b2	8b 44 24 34	 mov	 eax, DWORD PTR tv147[rsp]
$LN10@do_flush:

; 744  : }

  001b6	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001ba	c3		 ret	 0
do_flush ENDP
_TEXT	ENDS
PUBLIC	gzwrite
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzwrite DD imagerel $LN10
	DD	imagerel $LN10+425
	DD	imagerel $unwind$gzwrite
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzwrite DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzwrite
_TEXT	SEGMENT
s$ = 32
file$ = 64
buf$ = 72
len$ = 80
gzwrite	PROC						; COMDAT

; 563  : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 564  :     gz_stream *s = (gz_stream*)file;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 565  : 
; 566  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  0001d	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00023	74 11		 je	 SHORT $LN6@gzwrite
  00025	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0002a	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00031	83 f8 77	 cmp	 eax, 119		; 00000077H
  00034	74 0a		 je	 SHORT $LN7@gzwrite
$LN6@gzwrite:
  00036	b8 fe ff ff ff	 mov	 eax, -2
  0003b	e9 64 01 00 00	 jmp	 $LN8@gzwrite
$LN7@gzwrite:

; 567  : 
; 568  :     s->stream.next_in = (Bytef*)buf;

  00040	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00045	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]
  0004a	48 89 01	 mov	 QWORD PTR [rcx], rax

; 569  :     s->stream.avail_in = len;

  0004d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00052	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00056	89 41 08	 mov	 DWORD PTR [rcx+8], eax
$LN5@gzwrite:

; 570  : 
; 571  :     while (s->stream.avail_in != 0) {

  00059	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0005e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00062	0f 84 0b 01 00
	00		 je	 $LN4@gzwrite

; 572  : 
; 573  :         if (s->stream.avail_out == 0) {

  00068	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0006d	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00071	75 5a		 jne	 SHORT $LN3@gzwrite

; 574  : 
; 575  :             s->stream.next_out = s->outbuf;

  00073	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00078	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0007d	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00081	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 576  :             if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {

  00085	4c 8b 4c 24 20	 mov	 r9, QWORD PTR s$[rsp]
  0008a	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  0008e	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  00094	ba 01 00 00 00	 mov	 edx, 1
  00099	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0009e	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  000a2	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  000a8	48 3d 00 40 00
	00		 cmp	 rax, 16384		; 00004000H
  000ae	74 11		 je	 SHORT $LN2@gzwrite

; 577  :                 s->z_err = Z_ERRNO;

  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b5	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1

; 578  :                 break;

  000bc	e9 b2 00 00 00	 jmp	 $LN4@gzwrite
$LN2@gzwrite:

; 579  :             }
; 580  :             s->stream.avail_out = Z_BUFSIZE;

  000c1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000c6	c7 40 18 00 40
	00 00		 mov	 DWORD PTR [rax+24], 16384 ; 00004000H
$LN3@gzwrite:

; 581  :         }
; 582  :         s->in += s->stream.avail_in;

  000cd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000d2	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  000d8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000dd	03 48 08	 add	 ecx, DWORD PTR [rax+8]
  000e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e5	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 583  :         s->out += s->stream.avail_out;

  000eb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000f0	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  000f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000fb	03 48 18	 add	 ecx, DWORD PTR [rax+24]
  000fe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00103	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 584  :         s->z_err = deflate(&(s->stream), Z_NO_FLUSH);

  00109	33 d2		 xor	 edx, edx
  0010b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00110	e8 00 00 00 00	 call	 deflate
  00115	44 8b d8	 mov	 r11d, eax
  00118	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0011d	44 89 58 58	 mov	 DWORD PTR [rax+88], r11d

; 585  :         s->in -= s->stream.avail_in;

  00121	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00126	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0012b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0012e	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00134	2b c8		 sub	 ecx, eax
  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0013b	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 586  :         s->out -= s->stream.avail_out;

  00141	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00146	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0014b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0014e	8b 89 a0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+160]
  00154	2b c8		 sub	 ecx, eax
  00156	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0015b	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 587  :         if (s->z_err != Z_OK) break;

  00161	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00166	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  0016a	74 02		 je	 SHORT $LN1@gzwrite
  0016c	eb 05		 jmp	 SHORT $LN4@gzwrite
$LN1@gzwrite:

; 588  :     }

  0016e	e9 e6 fe ff ff	 jmp	 $LN5@gzwrite
$LN4@gzwrite:

; 589  :     s->crc = crc32(s->crc, (const Bytef *)buf, len);

  00173	44 8b 44 24 50	 mov	 r8d, DWORD PTR len$[rsp]
  00178	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  0017d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00182	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  00185	e8 00 00 00 00	 call	 crc32
  0018a	44 8b d8	 mov	 r11d, eax
  0018d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00192	44 89 58 78	 mov	 DWORD PTR [rax+120], r11d

; 590  : 
; 591  :     return (int)(len - s->stream.avail_in);

  00196	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0019b	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  0019e	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  001a2	2b c1		 sub	 eax, ecx
$LN8@gzwrite:

; 592  : }

  001a4	48 83 c4 38	 add	 rsp, 56			; 00000038H
  001a8	c3		 ret	 0
gzwrite	ENDP
_TEXT	ENDS
PUBLIC	gzread
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzread DD imagerel $LN28
	DD	imagerel $LN28+1360
	DD	imagerel $unwind$gzread
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzread DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzread
_TEXT	SEGMENT
next_out$ = 32
s$ = 40
start$ = 48
n$79806 = 56
file$ = 80
buf$ = 88
len$ = 96
gzread	PROC						; COMDAT

; 398  : {

$LN28:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 399  :     gz_stream *s = (gz_stream*)file;

  00013	48 8b 44 24 50	 mov	 rax, QWORD PTR file$[rsp]
  00018	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 400  :     Bytef *start = (Bytef*)buf; /* starting point for crc computation */

  0001d	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00022	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 401  :     Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
; 402  : 
; 403  :     if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

  00027	48 83 7c 24 28
	00		 cmp	 QWORD PTR s$[rsp], 0
  0002d	74 11		 je	 SHORT $LN24@gzread
  0002f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00034	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  0003b	83 f8 72	 cmp	 eax, 114		; 00000072H
  0003e	74 0a		 je	 SHORT $LN25@gzread
$LN24@gzread:
  00040	b8 fe ff ff ff	 mov	 eax, -2
  00045	e9 01 05 00 00	 jmp	 $LN26@gzread
$LN25@gzread:

; 404  : 
; 405  :     if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;

  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0004f	83 78 58 fd	 cmp	 DWORD PTR [rax+88], -3
  00053	74 0b		 je	 SHORT $LN22@gzread
  00055	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0005a	83 78 58 ff	 cmp	 DWORD PTR [rax+88], -1
  0005e	75 0a		 jne	 SHORT $LN23@gzread
$LN22@gzread:
  00060	b8 ff ff ff ff	 mov	 eax, -1
  00065	e9 e1 04 00 00	 jmp	 $LN26@gzread
$LN23@gzread:

; 406  :     if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

  0006a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0006f	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00073	75 07		 jne	 SHORT $LN21@gzread
  00075	33 c0		 xor	 eax, eax
  00077	e9 cf 04 00 00	 jmp	 $LN26@gzread
$LN21@gzread:

; 407  : 
; 408  :     next_out = (Byte*)buf;

  0007c	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00081	48 89 44 24 20	 mov	 QWORD PTR next_out$[rsp], rax

; 409  :     s->stream.next_out = (Bytef*)buf;

  00086	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0008b	48 8b 44 24 58	 mov	 rax, QWORD PTR buf$[rsp]
  00090	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 410  :     s->stream.avail_out = len;

  00094	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00099	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  0009d	89 41 18	 mov	 DWORD PTR [rcx+24], eax

; 411  : 
; 412  :     if (s->stream.avail_out && s->back != EOF) {

  000a0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000a5	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000a9	0f 84 b6 00 00
	00		 je	 $LN20@gzread
  000af	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000b4	83 b8 a4 00 00
	00 ff		 cmp	 DWORD PTR [rax+164], -1
  000bb	0f 84 a4 00 00
	00		 je	 $LN20@gzread

; 413  :         *next_out++ = s->back;

  000c1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR next_out$[rsp]
  000c6	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000cb	0f b6 80 a4 00
	00 00		 movzx	 eax, BYTE PTR [rax+164]
  000d2	88 01		 mov	 BYTE PTR [rcx], al
  000d4	48 8b 44 24 20	 mov	 rax, QWORD PTR next_out$[rsp]
  000d9	48 83 c0 01	 add	 rax, 1
  000dd	48 89 44 24 20	 mov	 QWORD PTR next_out$[rsp], rax

; 414  :         s->stream.next_out++;

  000e2	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  000e7	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  000eb	48 83 c1 01	 add	 rcx, 1
  000ef	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000f4	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 415  :         s->stream.avail_out--;

  000f8	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000fd	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00100	83 e9 01	 sub	 ecx, 1
  00103	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00108	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 416  :         s->back = EOF;

  0010b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00110	c7 80 a4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+164], -1

; 417  :         s->out++;

  0011a	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0011f	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  00125	83 c1 01	 add	 ecx, 1
  00128	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0012d	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 418  :         start++;

  00133	48 8b 44 24 30	 mov	 rax, QWORD PTR start$[rsp]
  00138	48 83 c0 01	 add	 rax, 1
  0013c	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 419  :         if (s->last) {

  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00146	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [rax+168], 0
  0014d	74 16		 je	 SHORT $LN19@gzread

; 420  :             s->z_err = Z_STREAM_END;

  0014f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00154	c7 40 58 01 00
	00 00		 mov	 DWORD PTR [rax+88], 1

; 421  :             return 1;

  0015b	b8 01 00 00 00	 mov	 eax, 1
  00160	e9 e6 03 00 00	 jmp	 $LN26@gzread
$LN19@gzread:
$LN20@gzread:
$LN18@gzread:

; 422  :         }
; 423  :     }
; 424  : 
; 425  :     while (s->stream.avail_out != 0) {

  00165	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0016a	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0016e	0f 84 6c 03 00
	00		 je	 $LN17@gzread

; 426  : 
; 427  :         if (s->transparent) {

  00174	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00179	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  00180	0f 84 4d 01 00
	00		 je	 $LN16@gzread

; 428  :             /* Copy first the lookahead bytes: */
; 429  :             uInt n = s->stream.avail_in;

  00186	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0018b	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0018e	89 44 24 38	 mov	 DWORD PTR n$79806[rsp], eax

; 430  :             if (n > s->stream.avail_out) n = s->stream.avail_out;

  00192	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00197	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0019a	39 44 24 38	 cmp	 DWORD PTR n$79806[rsp], eax
  0019e	76 0c		 jbe	 SHORT $LN15@gzread
  001a0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001a5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  001a8	89 44 24 38	 mov	 DWORD PTR n$79806[rsp], eax
$LN15@gzread:

; 431  :             if (n > 0) {

  001ac	83 7c 24 38 00	 cmp	 DWORD PTR n$79806[rsp], 0
  001b1	76 7b		 jbe	 SHORT $LN14@gzread

; 432  :                 zmemcpy(s->stream.next_out, s->stream.next_in, n);

  001b3	44 8b 44 24 38	 mov	 r8d, DWORD PTR n$79806[rsp]
  001b8	48 8b 54 24 28	 mov	 rdx, QWORD PTR s$[rsp]
  001bd	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  001c0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001c5	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  001c9	e8 00 00 00 00	 call	 memcpy

; 433  :                 next_out += n;

  001ce	44 8b 5c 24 38	 mov	 r11d, DWORD PTR n$79806[rsp]
  001d3	48 8b 44 24 20	 mov	 rax, QWORD PTR next_out$[rsp]
  001d8	49 03 c3	 add	 rax, r11
  001db	48 89 44 24 20	 mov	 QWORD PTR next_out$[rsp], rax

; 434  :                 s->stream.next_out = next_out;

  001e0	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  001e5	48 8b 44 24 20	 mov	 rax, QWORD PTR next_out$[rsp]
  001ea	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 435  :                 s->stream.next_in   += n;

  001ee	8b 4c 24 38	 mov	 ecx, DWORD PTR n$79806[rsp]
  001f2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001f7	48 03 08	 add	 rcx, QWORD PTR [rax]
  001fa	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001ff	48 89 08	 mov	 QWORD PTR [rax], rcx

; 436  :                 s->stream.avail_out -= n;

  00202	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00207	8b 44 24 38	 mov	 eax, DWORD PTR n$79806[rsp]
  0020b	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  0020e	2b c8		 sub	 ecx, eax
  00210	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00215	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 437  :                 s->stream.avail_in  -= n;

  00218	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0021d	8b 44 24 38	 mov	 eax, DWORD PTR n$79806[rsp]
  00221	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00224	2b c8		 sub	 ecx, eax
  00226	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0022b	89 48 08	 mov	 DWORD PTR [rax+8], ecx
$LN14@gzread:

; 438  :             }
; 439  :             if (s->stream.avail_out > 0) {

  0022e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00233	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00237	76 38		 jbe	 SHORT $LN13@gzread

; 440  :                 s->stream.avail_out -=
; 441  :                     (uInt)fread(next_out, 1, s->stream.avail_out, s->file);

  00239	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0023e	44 8b 40 18	 mov	 r8d, DWORD PTR [rax+24]
  00242	4c 8b 4c 24 28	 mov	 r9, QWORD PTR s$[rsp]
  00247	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  0024b	ba 01 00 00 00	 mov	 edx, 1
  00250	48 8b 4c 24 20	 mov	 rcx, QWORD PTR next_out$[rsp]
  00255	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  0025b	4c 8b d8	 mov	 r11, rax
  0025e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00263	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00266	41 2b cb	 sub	 ecx, r11d
  00269	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0026e	89 48 18	 mov	 DWORD PTR [rax+24], ecx
$LN13@gzread:

; 442  :             }
; 443  :             len -= s->stream.avail_out;

  00271	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00276	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00279	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  0027d	2b c1		 sub	 eax, ecx
  0027f	89 44 24 60	 mov	 DWORD PTR len$[rsp], eax

; 444  :             s->in  += len;

  00283	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00288	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  0028e	03 4c 24 60	 add	 ecx, DWORD PTR len$[rsp]
  00292	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00297	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 445  :             s->out += len;

  0029d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002a2	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  002a8	03 4c 24 60	 add	 ecx, DWORD PTR len$[rsp]
  002ac	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002b1	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 446  :             if (len == 0) s->z_eof = 1;

  002b7	83 7c 24 60 00	 cmp	 DWORD PTR len$[rsp], 0
  002bc	75 0c		 jne	 SHORT $LN12@gzread
  002be	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002c3	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [rax+92], 1
$LN12@gzread:

; 447  :             return (int)len;

  002ca	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  002ce	e9 78 02 00 00	 jmp	 $LN26@gzread
$LN16@gzread:

; 448  :         }
; 449  :         if (s->stream.avail_in == 0 && !s->z_eof) {

  002d3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002d8	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  002dc	0f 85 96 00 00
	00		 jne	 $LN11@gzread
  002e2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  002e7	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  002eb	0f 85 87 00 00
	00		 jne	 $LN11@gzread

; 450  : 
; 451  :             errno = 0;

  002f1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  002f7	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 452  :             s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);

  002fd	4c 8b 4c 24 28	 mov	 r9, QWORD PTR s$[rsp]
  00302	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  00306	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  0030c	ba 01 00 00 00	 mov	 edx, 1
  00311	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00316	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0031a	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fread
  00320	4c 8b d8	 mov	 r11, rax
  00323	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00328	44 89 58 08	 mov	 DWORD PTR [rax+8], r11d

; 453  :             if (s->stream.avail_in == 0) {

  0032c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00331	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00335	75 30		 jne	 SHORT $LN10@gzread

; 454  :                 s->z_eof = 1;

  00337	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0033c	c7 40 5c 01 00
	00 00		 mov	 DWORD PTR [rax+92], 1

; 455  :                 if (ferror(s->file)) {

  00343	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00348	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0034c	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ferror
  00352	85 c0		 test	 eax, eax
  00354	74 11		 je	 SHORT $LN9@gzread

; 456  :                     s->z_err = Z_ERRNO;

  00356	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0035b	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1

; 457  :                     break;

  00362	e9 79 01 00 00	 jmp	 $LN17@gzread
$LN9@gzread:
$LN10@gzread:

; 458  :                 }
; 459  :             }
; 460  :             s->stream.next_in = s->inbuf;

  00367	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0036c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00371	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00375	48 89 01	 mov	 QWORD PTR [rcx], rax
$LN11@gzread:

; 461  :         }
; 462  :         s->in += s->stream.avail_in;

  00378	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0037d	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00383	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00388	03 48 08	 add	 ecx, DWORD PTR [rax+8]
  0038b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00390	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 463  :         s->out += s->stream.avail_out;

  00396	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0039b	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  003a1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003a6	03 48 18	 add	 ecx, DWORD PTR [rax+24]
  003a9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003ae	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 464  :         s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

  003b4	33 d2		 xor	 edx, edx
  003b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  003bb	e8 00 00 00 00	 call	 inflate
  003c0	44 8b d8	 mov	 r11d, eax
  003c3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003c8	44 89 58 58	 mov	 DWORD PTR [rax+88], r11d

; 465  :         s->in -= s->stream.avail_in;

  003cc	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  003d1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003d6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  003d9	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  003df	2b c8		 sub	 ecx, eax
  003e1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003e6	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 466  :         s->out -= s->stream.avail_out;

  003ec	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  003f1	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  003f6	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003f9	8b 89 a0 00 00
	00		 mov	 ecx, DWORD PTR [rcx+160]
  003ff	2b c8		 sub	 ecx, eax
  00401	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00406	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 467  : 
; 468  :         if (s->z_err == Z_STREAM_END) {

  0040c	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00411	83 78 58 01	 cmp	 DWORD PTR [rax+88], 1
  00415	0f 85 a8 00 00
	00		 jne	 $LN8@gzread

; 469  :             /* Check CRC and original size */
; 470  :             s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

  0041b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00420	48 8b 4c 24 30	 mov	 rcx, QWORD PTR start$[rsp]
  00425	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00429	48 2b c1	 sub	 rax, rcx
  0042c	44 8b c0	 mov	 r8d, eax
  0042f	48 8b 54 24 30	 mov	 rdx, QWORD PTR start$[rsp]
  00434	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00439	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  0043c	e8 00 00 00 00	 call	 crc32
  00441	44 8b d8	 mov	 r11d, eax
  00444	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00449	44 89 58 78	 mov	 DWORD PTR [rax+120], r11d

; 471  :             start = s->stream.next_out;

  0044d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00452	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00456	48 89 44 24 30	 mov	 QWORD PTR start$[rsp], rax

; 472  : 
; 473  :             if (getLong(s) != s->crc) {

  0045b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00460	e8 00 00 00 00	 call	 getLong
  00465	44 8b d8	 mov	 r11d, eax
  00468	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0046d	44 3b 58 78	 cmp	 r11d, DWORD PTR [rax+120]
  00471	74 0e		 je	 SHORT $LN7@gzread

; 474  :                 s->z_err = Z_DATA_ERROR;

  00473	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00478	c7 40 58 fd ff
	ff ff		 mov	 DWORD PTR [rax+88], -3

; 475  :             } else {

  0047f	eb 42		 jmp	 SHORT $LN6@gzread
$LN7@gzread:

; 476  :                 (void)getLong(s);

  00481	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00486	e8 00 00 00 00	 call	 getLong

; 477  :                 /* The uncompressed length returned by above getlong() may be
; 478  :                  * different from s->out in case of concatenated .gz files.
; 479  :                  * Check for such files:
; 480  :                  */
; 481  :                 check_header(s);

  0048b	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00490	e8 00 00 00 00	 call	 check_header

; 482  :                 if (s->z_err == Z_OK) {

  00495	4c 8b 5c 24 28	 mov	 r11, QWORD PTR s$[rsp]
  0049a	41 83 7b 58 00	 cmp	 DWORD PTR [r11+88], 0
  0049f	75 22		 jne	 SHORT $LN5@gzread

; 483  :                     inflateReset(&(s->stream));

  004a1	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  004a6	e8 00 00 00 00	 call	 inflateReset

; 484  :                     s->crc = crc32(0L, Z_NULL, 0);

  004ab	45 33 c0	 xor	 r8d, r8d
  004ae	33 d2		 xor	 edx, edx
  004b0	33 c9		 xor	 ecx, ecx
  004b2	e8 00 00 00 00	 call	 crc32
  004b7	44 8b d8	 mov	 r11d, eax
  004ba	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004bf	44 89 58 78	 mov	 DWORD PTR [rax+120], r11d
$LN5@gzread:
$LN6@gzread:
$LN8@gzread:

; 485  :                 }
; 486  :             }
; 487  :         }
; 488  :         if (s->z_err != Z_OK || s->z_eof) break;

  004c3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004c8	83 78 58 00	 cmp	 DWORD PTR [rax+88], 0
  004cc	75 0b		 jne	 SHORT $LN3@gzread
  004ce	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004d3	83 78 5c 00	 cmp	 DWORD PTR [rax+92], 0
  004d7	74 02		 je	 SHORT $LN4@gzread
$LN3@gzread:
  004d9	eb 05		 jmp	 SHORT $LN17@gzread
$LN4@gzread:

; 489  :     }

  004db	e9 85 fc ff ff	 jmp	 $LN18@gzread
$LN17@gzread:

; 490  :     s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

  004e0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004e5	48 8b 4c 24 30	 mov	 rcx, QWORD PTR start$[rsp]
  004ea	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  004ee	48 2b c1	 sub	 rax, rcx
  004f1	44 8b c0	 mov	 r8d, eax
  004f4	48 8b 54 24 30	 mov	 rdx, QWORD PTR start$[rsp]
  004f9	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  004fe	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  00501	e8 00 00 00 00	 call	 crc32
  00506	44 8b d8	 mov	 r11d, eax
  00509	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0050e	44 89 58 78	 mov	 DWORD PTR [rax+120], r11d

; 491  : 
; 492  :     if (len == s->stream.avail_out &&
; 493  :         (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO))

  00512	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00517	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0051a	39 44 24 60	 cmp	 DWORD PTR len$[rsp], eax
  0051e	75 1d		 jne	 SHORT $LN2@gzread
  00520	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00525	83 78 58 fd	 cmp	 DWORD PTR [rax+88], -3
  00529	74 0b		 je	 SHORT $LN1@gzread
  0052b	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00530	83 78 58 ff	 cmp	 DWORD PTR [rax+88], -1
  00534	75 07		 jne	 SHORT $LN2@gzread
$LN1@gzread:

; 494  :         return -1;

  00536	b8 ff ff ff ff	 mov	 eax, -1
  0053b	eb 0e		 jmp	 SHORT $LN26@gzread
$LN2@gzread:

; 495  :     return (int)(len - s->stream.avail_out);

  0053d	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00542	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00545	8b 44 24 60	 mov	 eax, DWORD PTR len$[rsp]
  00549	2b c1		 sub	 eax, ecx
$LN26@gzread:

; 496  : }

  0054b	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0054f	c3		 ret	 0
gzread	ENDP
_TEXT	ENDS
PUBLIC	gzsetparams
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzsetparams DD imagerel $LN7
	DD	imagerel $LN7+180
	DD	imagerel $unwind$gzsetparams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzsetparams DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzsetparams
_TEXT	SEGMENT
s$ = 32
file$ = 64
level$ = 72
strategy$ = 80
gzsetparams PROC					; COMDAT

; 238  : {

$LN7:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 239  :     gz_stream *s = (gz_stream*)file;

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00017	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 240  : 
; 241  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  0001c	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00022	74 11		 je	 SHORT $LN3@gzsetparam
  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00029	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00030	83 f8 77	 cmp	 eax, 119		; 00000077H
  00033	74 07		 je	 SHORT $LN4@gzsetparam
$LN3@gzsetparam:
  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	eb 73		 jmp	 SHORT $LN5@gzsetparam
$LN4@gzsetparam:

; 242  : 
; 243  :     /* Make room to allow flushing */
; 244  :     if (s->stream.avail_out == 0) {

  0003c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00041	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00045	75 55		 jne	 SHORT $LN2@gzsetparam

; 245  : 
; 246  :         s->stream.next_out = s->outbuf;

  00047	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0004c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00051	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  00055	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 247  :         if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {

  00059	4c 8b 4c 24 20	 mov	 r9, QWORD PTR s$[rsp]
  0005e	4d 8b 49 60	 mov	 r9, QWORD PTR [r9+96]
  00062	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  00068	ba 01 00 00 00	 mov	 edx, 1
  0006d	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00072	48 8b 49 70	 mov	 rcx, QWORD PTR [rcx+112]
  00076	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fwrite
  0007c	48 3d 00 40 00
	00		 cmp	 rax, 16384		; 00004000H
  00082	74 0c		 je	 SHORT $LN1@gzsetparam

; 248  :             s->z_err = Z_ERRNO;

  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00089	c7 40 58 ff ff
	ff ff		 mov	 DWORD PTR [rax+88], -1
$LN1@gzsetparam:

; 249  :         }
; 250  :         s->stream.avail_out = Z_BUFSIZE;

  00090	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00095	c7 40 18 00 40
	00 00		 mov	 DWORD PTR [rax+24], 16384 ; 00004000H
$LN2@gzsetparam:

; 251  :     }
; 252  : 
; 253  :     return deflateParams (&(s->stream), level, strategy);

  0009c	44 8b 44 24 50	 mov	 r8d, DWORD PTR strategy$[rsp]
  000a1	8b 54 24 48	 mov	 edx, DWORD PTR level$[rsp]
  000a5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000aa	e8 00 00 00 00	 call	 deflateParams
$LN5@gzsetparam:

; 254  : }

  000af	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b3	c3		 ret	 0
gzsetparams ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$gz_open DD imagerel gz_open
	DD	imagerel gz_open+1398
	DD	imagerel $unwind$gz_open
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gz_open DD 021601H
	DD	01f0116H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gz_open
_TEXT	SEGMENT
p$ = 96
level$ = 104
s$ = 112
strategy$ = 120
err$ = 124
m$ = 128
fmode$ = 144
tv209 = 224
path$ = 256
mode$ = 264
fd$ = 272
gz_open	PROC						; COMDAT

; 97   : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 81 ec f8 00
	00 00		 sub	 rsp, 248		; 000000f8H

; 98   :     int err;
; 99   :     int level = Z_DEFAULT_COMPRESSION; /* compression level */

  00016	c7 44 24 68 ff
	ff ff ff	 mov	 DWORD PTR level$[rsp], -1

; 100  :     int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */

  0001e	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR strategy$[rsp], 0

; 101  :     char *p = (char*)mode;

  00026	48 8b 84 24 08
	01 00 00	 mov	 rax, QWORD PTR mode$[rsp]
  0002e	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax

; 102  :     gz_stream *s;
; 103  :     char fmode[80]; /* copy of mode, without the compression level */
; 104  :     char *m = fmode;

  00033	48 8d 84 24 90
	00 00 00	 lea	 rax, QWORD PTR fmode$[rsp]
  0003b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR m$[rsp], rax

; 105  : 
; 106  :     if (!path || !mode) return Z_NULL;

  00043	48 83 bc 24 00
	01 00 00 00	 cmp	 QWORD PTR path$[rsp], 0
  0004c	74 0b		 je	 SHORT $LN28@gz_open
  0004e	48 83 bc 24 08
	01 00 00 00	 cmp	 QWORD PTR mode$[rsp], 0
  00057	75 07		 jne	 SHORT $LN29@gz_open
$LN28@gz_open:
  00059	33 c0		 xor	 eax, eax
  0005b	e9 0e 05 00 00	 jmp	 $LN30@gz_open
$LN29@gz_open:

; 107  : 
; 108  :     s = (gz_stream *)ALLOC(sizeof(gz_stream));

  00060	b9 b0 00 00 00	 mov	 ecx, 176		; 000000b0H
  00065	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0006b	48 89 44 24 70	 mov	 QWORD PTR s$[rsp], rax

; 109  :     if (!s) return Z_NULL;

  00070	48 83 7c 24 70
	00		 cmp	 QWORD PTR s$[rsp], 0
  00076	75 07		 jne	 SHORT $LN27@gz_open
  00078	33 c0		 xor	 eax, eax
  0007a	e9 ef 04 00 00	 jmp	 $LN30@gz_open
$LN27@gz_open:

; 110  : 
; 111  :     s->stream.zalloc = (alloc_func)0;

  0007f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00084	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 112  :     s->stream.zfree = (free_func)0;

  0008c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00091	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 113  :     s->stream.opaque = (voidpf)0;

  00099	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0009e	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0

; 114  :     s->stream.next_in = s->inbuf = Z_NULL;

  000a6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000ab	48 c7 40 68 00
	00 00 00	 mov	 QWORD PTR [rax+104], 0
  000b3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b8	48 c7 00 00 00
	00 00		 mov	 QWORD PTR [rax], 0

; 115  :     s->stream.next_out = s->outbuf = Z_NULL;

  000bf	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000c4	48 c7 40 70 00
	00 00 00	 mov	 QWORD PTR [rax+112], 0
  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000d1	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0

; 116  :     s->stream.avail_in = s->stream.avail_out = 0;

  000d9	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000de	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [rax+24], 0
  000e5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000ea	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 117  :     s->file = NULL;

  000f1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000f6	48 c7 40 60 00
	00 00 00	 mov	 QWORD PTR [rax+96], 0

; 118  :     s->z_err = Z_OK;

  000fe	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00103	c7 40 58 00 00
	00 00		 mov	 DWORD PTR [rax+88], 0

; 119  :     s->z_eof = 0;

  0010a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0010f	c7 40 5c 00 00
	00 00		 mov	 DWORD PTR [rax+92], 0

; 120  :     s->in = 0;

  00116	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0011b	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 121  :     s->out = 0;

  00125	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0012a	c7 80 a0 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+160], 0

; 122  :     s->back = EOF;

  00134	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00139	c7 80 a4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+164], -1

; 123  :     s->crc = crc32(0L, Z_NULL, 0);

  00143	45 33 c0	 xor	 r8d, r8d
  00146	33 d2		 xor	 edx, edx
  00148	33 c9		 xor	 ecx, ecx
  0014a	e8 00 00 00 00	 call	 crc32
  0014f	44 8b d8	 mov	 r11d, eax
  00152	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00157	44 89 58 78	 mov	 DWORD PTR [rax+120], r11d

; 124  :     s->msg = NULL;

  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00160	48 c7 80 80 00
	00 00 00 00 00
	00		 mov	 QWORD PTR [rax+128], 0

; 125  :     s->transparent = 0;

  0016b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00170	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 126  : 
; 127  :     s->path = (char*)ALLOC(strlen(path)+1);

  0017a	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00182	e8 00 00 00 00	 call	 strlen
  00187	48 8b c8	 mov	 rcx, rax
  0018a	48 83 c1 01	 add	 rcx, 1
  0018e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00194	4c 8b d8	 mov	 r11, rax
  00197	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0019c	4c 89 98 88 00
	00 00		 mov	 QWORD PTR [rax+136], r11

; 128  :     if (s->path == NULL) {

  001a3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001a8	48 83 b8 88 00
	00 00 00	 cmp	 QWORD PTR [rax+136], 0
  001b0	75 11		 jne	 SHORT $LN26@gz_open

; 129  :         return destroy(s), (gzFile)Z_NULL;

  001b2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001b7	e8 00 00 00 00	 call	 destroy
  001bc	33 c0		 xor	 eax, eax
  001be	e9 ab 03 00 00	 jmp	 $LN30@gz_open
$LN26@gz_open:

; 130  :     }
; 131  :     strcpy(s->path, path); /* do this early for debugging */

  001c3	48 8b 94 24 00
	01 00 00	 mov	 rdx, QWORD PTR path$[rsp]
  001cb	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001d0	48 8b 89 88 00
	00 00		 mov	 rcx, QWORD PTR [rcx+136]
  001d7	e8 00 00 00 00	 call	 strcpy

; 132  : 
; 133  :     s->mode = '\0';

  001dc	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  001e1	41 c6 83 94 00
	00 00 00	 mov	 BYTE PTR [r11+148], 0
$LN25@gz_open:

; 134  :     do {
; 135  :         if (*p == 'r') s->mode = 'r';

  001e9	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  001ee	0f be 00	 movsx	 eax, BYTE PTR [rax]
  001f1	83 f8 72	 cmp	 eax, 114		; 00000072H
  001f4	75 0c		 jne	 SHORT $LN22@gz_open
  001f6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001fb	c6 80 94 00 00
	00 72		 mov	 BYTE PTR [rax+148], 114	; 00000072H
$LN22@gz_open:

; 136  :         if (*p == 'w' || *p == 'a') s->mode = 'w';

  00202	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00207	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0020a	83 f8 77	 cmp	 eax, 119		; 00000077H
  0020d	74 0d		 je	 SHORT $LN20@gz_open
  0020f	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00214	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00217	83 f8 61	 cmp	 eax, 97			; 00000061H
  0021a	75 0c		 jne	 SHORT $LN21@gz_open
$LN20@gz_open:
  0021c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00221	c6 80 94 00 00
	00 77		 mov	 BYTE PTR [rax+148], 119	; 00000077H
$LN21@gz_open:

; 137  :         if (*p >= '0' && *p <= '9') {

  00228	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0022d	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00230	83 f8 30	 cmp	 eax, 48			; 00000030H
  00233	7c 1e		 jl	 SHORT $LN19@gz_open
  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0023a	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0023d	83 f8 39	 cmp	 eax, 57			; 00000039H
  00240	7f 11		 jg	 SHORT $LN19@gz_open

; 138  :             level = *p - '0';

  00242	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00247	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0024a	83 e8 30	 sub	 eax, 48			; 00000030H
  0024d	89 44 24 68	 mov	 DWORD PTR level$[rsp], eax
  00251	eb 6b		 jmp	 SHORT $LN18@gz_open
$LN19@gz_open:

; 139  :         } else if (*p == 'f') {

  00253	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00258	0f be 00	 movsx	 eax, BYTE PTR [rax]
  0025b	83 f8 66	 cmp	 eax, 102		; 00000066H
  0025e	75 0a		 jne	 SHORT $LN17@gz_open

; 140  :           strategy = Z_FILTERED;

  00260	c7 44 24 78 01
	00 00 00	 mov	 DWORD PTR strategy$[rsp], 1
  00268	eb 54		 jmp	 SHORT $LN16@gz_open
$LN17@gz_open:

; 141  :         } else if (*p == 'h') {

  0026a	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  0026f	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00272	83 f8 68	 cmp	 eax, 104		; 00000068H
  00275	75 0a		 jne	 SHORT $LN15@gz_open

; 142  :           strategy = Z_HUFFMAN_ONLY;

  00277	c7 44 24 78 02
	00 00 00	 mov	 DWORD PTR strategy$[rsp], 2
  0027f	eb 3d		 jmp	 SHORT $LN14@gz_open
$LN15@gz_open:

; 143  :         } else if (*p == 'R') {

  00281	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  00286	0f be 00	 movsx	 eax, BYTE PTR [rax]
  00289	83 f8 52	 cmp	 eax, 82			; 00000052H
  0028c	75 0a		 jne	 SHORT $LN13@gz_open

; 144  :           strategy = Z_RLE;

  0028e	c7 44 24 78 03
	00 00 00	 mov	 DWORD PTR strategy$[rsp], 3

; 145  :         } else {

  00296	eb 26		 jmp	 SHORT $LN12@gz_open
$LN13@gz_open:

; 146  :             *m++ = *p; /* copy the mode */

  00298	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR m$[rsp]
  002a0	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  002a5	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a8	88 01		 mov	 BYTE PTR [rcx], al
  002aa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR m$[rsp]
  002b2	48 83 c0 01	 add	 rax, 1
  002b6	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR m$[rsp], rax
$LN12@gz_open:
$LN14@gz_open:
$LN16@gz_open:
$LN18@gz_open:

; 147  :         }
; 148  :     } while (*p++ && m != fmode + sizeof(fmode));

  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  002c3	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  002c6	48 8b 44 24 60	 mov	 rax, QWORD PTR p$[rsp]
  002cb	48 83 c0 01	 add	 rax, 1
  002cf	48 89 44 24 60	 mov	 QWORD PTR p$[rsp], rax
  002d4	85 c9		 test	 ecx, ecx
  002d6	74 16		 je	 SHORT $LN11@gz_open
  002d8	48 8d 84 24 e0
	00 00 00	 lea	 rax, QWORD PTR fmode$[rsp+80]
  002e0	48 39 84 24 80
	00 00 00	 cmp	 QWORD PTR m$[rsp], rax
  002e8	0f 85 fb fe ff
	ff		 jne	 $LN25@gz_open
$LN11@gz_open:

; 149  :     if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;

  002ee	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002f3	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  002fa	85 c0		 test	 eax, eax
  002fc	75 11		 jne	 SHORT $LN10@gz_open
  002fe	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00303	e8 00 00 00 00	 call	 destroy
  00308	33 c0		 xor	 eax, eax
  0030a	e9 5f 02 00 00	 jmp	 $LN30@gz_open
$LN10@gz_open:

; 150  : 
; 151  :     if (s->mode == 'w') {

  0030f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00314	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  0031b	83 f8 77	 cmp	 eax, 119		; 00000077H
  0031e	0f 85 91 00 00
	00		 jne	 $LN9@gz_open

; 152  : #ifdef NO_GZCOMPRESS
; 153  :         err = Z_STREAM_ERROR;
; 154  : #else
; 155  :         err = deflateInit2(&(s->stream), level,
; 156  :                            Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);

  00324	c7 44 24 38 58
	00 00 00	 mov	 DWORD PTR [rsp+56], 88	; 00000058H
  0032c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_05GDHACFMB@1?42?43?$AA@
  00333	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00338	8b 44 24 78	 mov	 eax, DWORD PTR strategy$[rsp]
  0033c	89 44 24 28	 mov	 DWORD PTR [rsp+40], eax
  00340	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00348	41 b9 f1 ff ff
	ff		 mov	 r9d, -15
  0034e	41 b8 08 00 00
	00		 mov	 r8d, 8
  00354	8b 54 24 68	 mov	 edx, DWORD PTR level$[rsp]
  00358	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0035d	e8 00 00 00 00	 call	 deflateInit2_
  00362	89 44 24 7c	 mov	 DWORD PTR err$[rsp], eax

; 157  :         /* windowBits is passed < 0 to suppress zlib header */
; 158  : 
; 159  :         s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);

  00366	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0036b	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  00371	4c 8b d8	 mov	 r11, rax
  00374	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00379	4c 89 58 70	 mov	 QWORD PTR [rax+112], r11
  0037d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00382	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00387	48 8b 40 70	 mov	 rax, QWORD PTR [rax+112]
  0038b	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 160  : #endif
; 161  :         if (err != Z_OK || s->outbuf == Z_NULL) {

  0038f	83 7c 24 7c 00	 cmp	 DWORD PTR err$[rsp], 0
  00394	75 0c		 jne	 SHORT $LN7@gz_open
  00396	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0039b	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  003a0	75 11		 jne	 SHORT $LN8@gz_open
$LN7@gz_open:

; 162  :             return destroy(s), (gzFile)Z_NULL;

  003a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003a7	e8 00 00 00 00	 call	 destroy
  003ac	33 c0		 xor	 eax, eax
  003ae	e9 bb 01 00 00	 jmp	 $LN30@gz_open
$LN8@gz_open:

; 163  :         }
; 164  :     } else {

  003b3	eb 6c		 jmp	 SHORT $LN6@gz_open
$LN9@gz_open:

; 165  :         s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

  003b5	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  003ba	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  003c0	4c 8b d8	 mov	 r11, rax
  003c3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003c8	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11
  003cc	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003d1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003d6	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  003da	48 89 01	 mov	 QWORD PTR [rcx], rax

; 166  : 
; 167  :         err = inflateInit2(&(s->stream), -MAX_WBITS);

  003dd	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  003e3	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05GDHACFMB@1?42?43?$AA@
  003ea	ba f1 ff ff ff	 mov	 edx, -15
  003ef	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003f4	e8 00 00 00 00	 call	 inflateInit2_
  003f9	89 44 24 7c	 mov	 DWORD PTR err$[rsp], eax

; 168  :         /* windowBits is passed < 0 to tell that there is no zlib header.
; 169  :          * Note that in this case inflate *requires* an extra "dummy" byte
; 170  :          * after the compressed stream in order to complete decompression and
; 171  :          * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
; 172  :          * present after the compressed stream.
; 173  :          */
; 174  :         if (err != Z_OK || s->inbuf == Z_NULL) {

  003fd	83 7c 24 7c 00	 cmp	 DWORD PTR err$[rsp], 0
  00402	75 0c		 jne	 SHORT $LN4@gz_open
  00404	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00409	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0040e	75 11		 jne	 SHORT $LN5@gz_open
$LN4@gz_open:

; 175  :             return destroy(s), (gzFile)Z_NULL;

  00410	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00415	e8 00 00 00 00	 call	 destroy
  0041a	33 c0		 xor	 eax, eax
  0041c	e9 4d 01 00 00	 jmp	 $LN30@gz_open
$LN5@gz_open:
$LN6@gz_open:

; 176  :         }
; 177  :     }
; 178  :     s->stream.avail_out = Z_BUFSIZE;

  00421	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00426	c7 40 18 00 40
	00 00		 mov	 DWORD PTR [rax+24], 16384 ; 00004000H

; 179  : 
; 180  :     errno = 0;

  0042d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__errno
  00433	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 181  :     s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

  00439	83 bc 24 10 01
	00 00 00	 cmp	 DWORD PTR fd$[rsp], 0
  00441	7d 20		 jge	 SHORT $LN32@gz_open
  00443	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR fmode$[rsp]
  0044b	48 8b 8c 24 00
	01 00 00	 mov	 rcx, QWORD PTR path$[rsp]
  00453	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fopen
  00459	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv209[rsp], rax
  00461	eb 1d		 jmp	 SHORT $LN33@gz_open
$LN32@gz_open:
  00463	48 8d 94 24 90
	00 00 00	 lea	 rdx, QWORD PTR fmode$[rsp]
  0046b	8b 8c 24 10 01
	00 00		 mov	 ecx, DWORD PTR fd$[rsp]
  00472	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__fdopen
  00478	48 89 84 24 e0
	00 00 00	 mov	 QWORD PTR tv209[rsp], rax
$LN33@gz_open:
  00480	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00485	48 8b 84 24 e0
	00 00 00	 mov	 rax, QWORD PTR tv209[rsp]
  0048d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 182  : 
; 183  :     if (s->file == NULL) {

  00491	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00496	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  0049b	75 11		 jne	 SHORT $LN3@gz_open

; 184  :         return destroy(s), (gzFile)Z_NULL;

  0049d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004a2	e8 00 00 00 00	 call	 destroy
  004a7	33 c0		 xor	 eax, eax
  004a9	e9 c0 00 00 00	 jmp	 $LN30@gz_open
$LN3@gz_open:

; 185  :     }
; 186  :     if (s->mode == 'w') {

  004ae	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004b3	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  004ba	83 f8 77	 cmp	 eax, 119		; 00000077H
  004bd	75 7c		 jne	 SHORT $LN2@gz_open

; 187  :         /* Write a very simple .gz header:
; 188  :          */
; 189  :         fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
; 190  :              Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);

  004bf	c7 44 24 58 0b
	00 00 00	 mov	 DWORD PTR [rsp+88], 11
  004c7	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR [rsp+80], 0
  004d0	48 c7 44 24 48
	00 00 00 00	 mov	 QWORD PTR [rsp+72], 0
  004d9	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR [rsp+64], 0
  004e2	48 c7 44 24 38
	00 00 00 00	 mov	 QWORD PTR [rsp+56], 0
  004eb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR [rsp+48], 0
  004f4	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR [rsp+40], 0
  004fd	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00505	44 8b 0d 04 00
	00 00		 mov	 r9d, DWORD PTR gz_magic+4
  0050c	44 8b 05 00 00
	00 00		 mov	 r8d, DWORD PTR gz_magic
  00513	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
  0051a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0051f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00523	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fprintf

; 191  :         s->start = 10L;

  00529	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  0052e	41 c7 83 98 00
	00 00 0a 00 00
	00		 mov	 DWORD PTR [r11+152], 10

; 192  :         /* We use 10L instead of ftell(s->file) to because ftell causes an
; 193  :          * fflush on some systems. This version of the library doesn't use
; 194  :          * start anyway in write mode, so this initialization is not
; 195  :          * necessary.
; 196  :          */
; 197  :     } else {

  00539	eb 2e		 jmp	 SHORT $LN1@gz_open
$LN2@gz_open:

; 198  :         check_header(s); /* skip the .gz header */

  0053b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00540	e8 00 00 00 00	 call	 check_header

; 199  :         s->start = ftell(s->file) - s->stream.avail_in;

  00545	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0054a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0054e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_ftell
  00554	8b c8		 mov	 ecx, eax
  00556	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0055b	2b 48 08	 sub	 ecx, DWORD PTR [rax+8]
  0055e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00563	89 88 98 00 00
	00		 mov	 DWORD PTR [rax+152], ecx
$LN1@gz_open:

; 200  :     }
; 201  : 
; 202  :     return (gzFile)s;

  00569	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
$LN30@gz_open:

; 203  : }

  0056e	48 81 c4 f8 00
	00 00		 add	 rsp, 248		; 000000f8H
  00575	c3		 ret	 0
gz_open	ENDP
PUBLIC	gzclose
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzclose DD imagerel $LN6
	DD	imagerel $LN6+145
	DD	imagerel $unwind$gzclose
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzclose DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzclose
_TEXT	SEGMENT
s$ = 32
file$ = 64
gzclose	PROC						; COMDAT

; 955  : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 956  :     gz_stream *s = (gz_stream*)file;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  0000e	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 957  : 
; 958  :     if (s == NULL) return Z_STREAM_ERROR;

  00013	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00019	75 07		 jne	 SHORT $LN3@gzclose
  0001b	b8 fe ff ff ff	 mov	 eax, -2
  00020	eb 6a		 jmp	 SHORT $LN4@gzclose
$LN3@gzclose:

; 959  : 
; 960  :     if (s->mode == 'w') {

  00022	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00027	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  0002e	83 f8 77	 cmp	 eax, 119		; 00000077H
  00031	75 4f		 jne	 SHORT $LN2@gzclose

; 961  : #ifdef NO_GZCOMPRESS
; 962  :         return Z_STREAM_ERROR;
; 963  : #else
; 964  :         if (do_flush (file, Z_FINISH) != Z_OK)

  00033	ba 04 00 00 00	 mov	 edx, 4
  00038	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0003d	e8 00 00 00 00	 call	 do_flush
  00042	85 c0		 test	 eax, eax
  00044	74 0c		 je	 SHORT $LN1@gzclose

; 965  :             return destroy((gz_stream*)file);

  00046	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  0004b	e8 00 00 00 00	 call	 destroy
  00050	eb 3a		 jmp	 SHORT $LN4@gzclose
$LN1@gzclose:

; 966  : 
; 967  :         putLong (s->file, s->crc);

  00052	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00057	8b 50 78	 mov	 edx, DWORD PTR [rax+120]
  0005a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0005f	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00063	e8 00 00 00 00	 call	 putLong

; 968  :         putLong (s->file, (uLong)(s->in & 0xffffffff));

  00068	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  0006d	41 8b 93 9c 00
	00 00		 mov	 edx, DWORD PTR [r11+156]
  00074	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00079	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0007d	e8 00 00 00 00	 call	 putLong
$LN2@gzclose:

; 969  : #endif
; 970  :     }
; 971  :     return destroy((gz_stream*)file);

  00082	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00087	e8 00 00 00 00	 call	 destroy
$LN4@gzclose:

; 972  : }

  0008c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00090	c3		 ret	 0
gzclose	ENDP
_TEXT	ENDS
PUBLIC	gzseek
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzseek DD imagerel $LN29
	DD	imagerel $LN29+841
	DD	imagerel $unwind$gzseek
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzseek DD 011201H
	DD	06212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzseek
_TEXT	SEGMENT
s$ = 32
size$79946 = 40
size$79965 = 44
file$ = 64
offset$ = 72
whence$ = 80
gzseek	PROC						; COMDAT

; 771  : {

$LN29:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 772  :     gz_stream *s = (gz_stream*)file;

  00012	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00017	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 773  : 
; 774  :     if (s == NULL || whence == SEEK_END ||
; 775  :         s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {

  0001c	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  00022	74 1d		 je	 SHORT $LN25@gzseek
  00024	83 7c 24 50 02	 cmp	 DWORD PTR whence$[rsp], 2
  00029	74 16		 je	 SHORT $LN25@gzseek
  0002b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00030	83 78 58 ff	 cmp	 DWORD PTR [rax+88], -1
  00034	74 0b		 je	 SHORT $LN25@gzseek
  00036	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0003b	83 78 58 fd	 cmp	 DWORD PTR [rax+88], -3
  0003f	75 0a		 jne	 SHORT $LN26@gzseek
$LN25@gzseek:

; 776  :         return -1L;

  00041	b8 ff ff ff ff	 mov	 eax, -1
  00046	e9 f9 02 00 00	 jmp	 $LN27@gzseek
$LN26@gzseek:

; 777  :     }
; 778  : 
; 779  :     if (s->mode == 'w') {

  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00050	0f be 80 94 00
	00 00		 movsx	 eax, BYTE PTR [rax+148]
  00057	83 f8 77	 cmp	 eax, 119		; 00000077H
  0005a	0f 85 ea 00 00
	00		 jne	 $LN24@gzseek

; 780  : #ifdef NO_GZCOMPRESS
; 781  :         return -1L;
; 782  : #else
; 783  :         if (whence == SEEK_SET) {

  00060	83 7c 24 50 00	 cmp	 DWORD PTR whence$[rsp], 0
  00065	75 15		 jne	 SHORT $LN23@gzseek

; 784  :             offset -= s->in;

  00067	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0006c	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00072	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00076	2b c1		 sub	 eax, ecx
  00078	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax
$LN23@gzseek:

; 785  :         }
; 786  :         if (offset < 0) return -1L;

  0007c	83 7c 24 48 00	 cmp	 DWORD PTR offset$[rsp], 0
  00081	7d 0a		 jge	 SHORT $LN22@gzseek
  00083	b8 ff ff ff ff	 mov	 eax, -1
  00088	e9 b7 02 00 00	 jmp	 $LN27@gzseek
$LN22@gzseek:

; 787  : 
; 788  :         /* At this point, offset is the number of zero bytes to write. */
; 789  :         if (s->inbuf == Z_NULL) {

  0008d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00092	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00097	75 43		 jne	 SHORT $LN21@gzseek

; 790  :             s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */

  00099	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  0009e	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  000a4	4c 8b d8	 mov	 r11, rax
  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ac	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11

; 791  :             if (s->inbuf == Z_NULL) return -1L;

  000b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b5	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000ba	75 0a		 jne	 SHORT $LN20@gzseek
  000bc	b8 ff ff ff ff	 mov	 eax, -1
  000c1	e9 7e 02 00 00	 jmp	 $LN27@gzseek
$LN20@gzseek:

; 792  :             zmemzero(s->inbuf, Z_BUFSIZE);

  000c6	41 b8 00 40 00
	00		 mov	 r8d, 16384		; 00004000H
  000cc	33 d2		 xor	 edx, edx
  000ce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000d3	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  000d7	e8 00 00 00 00	 call	 memset
$LN21@gzseek:
$LN19@gzseek:

; 793  :         }
; 794  :         while (offset > 0)  {

  000dc	83 7c 24 48 00	 cmp	 DWORD PTR offset$[rsp], 0
  000e1	7e 57		 jle	 SHORT $LN18@gzseek

; 795  :             uInt size = Z_BUFSIZE;

  000e3	c7 44 24 28 00
	40 00 00	 mov	 DWORD PTR size$79946[rsp], 16384 ; 00004000H

; 796  :             if (offset < Z_BUFSIZE) size = (uInt)offset;

  000eb	81 7c 24 48 00
	40 00 00	 cmp	 DWORD PTR offset$[rsp], 16384 ; 00004000H
  000f3	7d 08		 jge	 SHORT $LN17@gzseek
  000f5	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  000f9	89 44 24 28	 mov	 DWORD PTR size$79946[rsp], eax
$LN17@gzseek:

; 797  : 
; 798  :             size = gzwrite(file, s->inbuf, size);

  000fd	44 8b 44 24 28	 mov	 r8d, DWORD PTR size$79946[rsp]
  00102	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00107	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  0010b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00110	e8 00 00 00 00	 call	 gzwrite
  00115	89 44 24 28	 mov	 DWORD PTR size$79946[rsp], eax

; 799  :             if (size == 0) return -1L;

  00119	83 7c 24 28 00	 cmp	 DWORD PTR size$79946[rsp], 0
  0011e	75 0a		 jne	 SHORT $LN16@gzseek
  00120	b8 ff ff ff ff	 mov	 eax, -1
  00125	e9 1a 02 00 00	 jmp	 $LN27@gzseek
$LN16@gzseek:

; 800  : 
; 801  :             offset -= size;

  0012a	8b 4c 24 28	 mov	 ecx, DWORD PTR size$79946[rsp]
  0012e	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00132	2b c1		 sub	 eax, ecx
  00134	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 802  :         }

  00138	eb a2		 jmp	 SHORT $LN19@gzseek
$LN18@gzseek:

; 803  :         return s->in;

  0013a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0013f	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00145	e9 fa 01 00 00	 jmp	 $LN27@gzseek
$LN24@gzseek:

; 804  : #endif
; 805  :     }
; 806  :     /* Rest of function is for reading only */
; 807  : 
; 808  :     /* compute absolute position */
; 809  :     if (whence == SEEK_CUR) {

  0014a	83 7c 24 50 01	 cmp	 DWORD PTR whence$[rsp], 1
  0014f	75 15		 jne	 SHORT $LN15@gzseek

; 810  :         offset += s->out;

  00151	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00156	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  0015c	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00160	03 c1		 add	 eax, ecx
  00162	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax
$LN15@gzseek:

; 811  :     }
; 812  :     if (offset < 0) return -1L;

  00166	83 7c 24 48 00	 cmp	 DWORD PTR offset$[rsp], 0
  0016b	7d 0a		 jge	 SHORT $LN14@gzseek
  0016d	b8 ff ff ff ff	 mov	 eax, -1
  00172	e9 cd 01 00 00	 jmp	 $LN27@gzseek
$LN14@gzseek:

; 813  : 
; 814  :     if (s->transparent) {

  00177	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0017c	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  00183	74 77		 je	 SHORT $LN13@gzseek

; 815  :         /* map to fseek */
; 816  :         s->back = EOF;

  00185	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0018a	c7 80 a4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+164], -1

; 817  :         s->stream.avail_in = 0;

  00194	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00199	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 818  :         s->stream.next_in = s->inbuf;

  001a0	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001a5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001aa	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  001ae	48 89 01	 mov	 QWORD PTR [rcx], rax

; 819  :         if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

  001b1	45 33 c0	 xor	 r8d, r8d
  001b4	8b 54 24 48	 mov	 edx, DWORD PTR offset$[rsp]
  001b8	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001bd	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001c1	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fseek
  001c7	85 c0		 test	 eax, eax
  001c9	7d 0a		 jge	 SHORT $LN12@gzseek
  001cb	b8 ff ff ff ff	 mov	 eax, -1
  001d0	e9 6f 01 00 00	 jmp	 $LN27@gzseek
$LN12@gzseek:

; 820  : 
; 821  :         s->in = s->out = offset;

  001d5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001da	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  001de	89 81 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], eax
  001e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001e9	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  001ed	89 81 9c 00 00
	00		 mov	 DWORD PTR [rcx+156], eax

; 822  :         return offset;

  001f3	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  001f7	e9 48 01 00 00	 jmp	 $LN27@gzseek
$LN13@gzseek:

; 823  :     }
; 824  : 
; 825  :     /* For a negative seek, rewind and use positive seek */
; 826  :     if (offset >= s->out) {

  001fc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00201	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00207	39 44 24 48	 cmp	 DWORD PTR offset$[rsp], eax
  0020b	7c 17		 jl	 SHORT $LN11@gzseek

; 827  :         offset -= s->out;

  0020d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00212	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  00218	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  0021c	2b c1		 sub	 eax, ecx
  0021e	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax
  00222	eb 18		 jmp	 SHORT $LN10@gzseek
$LN11@gzseek:

; 828  :     } else if (gzrewind(file) < 0) {

  00224	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00229	e8 00 00 00 00	 call	 gzrewind
  0022e	85 c0		 test	 eax, eax
  00230	7d 0a		 jge	 SHORT $LN9@gzseek

; 829  :         return -1L;

  00232	b8 ff ff ff ff	 mov	 eax, -1
  00237	e9 08 01 00 00	 jmp	 $LN27@gzseek
$LN9@gzseek:
$LN10@gzseek:

; 830  :     }
; 831  :     /* offset is now the number of bytes to skip. */
; 832  : 
; 833  :     if (offset != 0 && s->outbuf == Z_NULL) {

  0023c	83 7c 24 48 00	 cmp	 DWORD PTR offset$[rsp], 0
  00241	74 39		 je	 SHORT $LN8@gzseek
  00243	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00248	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  0024d	75 2d		 jne	 SHORT $LN8@gzseek

; 834  :         s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);

  0024f	b9 00 40 00 00	 mov	 ecx, 16384		; 00004000H
  00254	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_malloc
  0025a	4c 8b d8	 mov	 r11, rax
  0025d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00262	4c 89 58 70	 mov	 QWORD PTR [rax+112], r11

; 835  :         if (s->outbuf == Z_NULL) return -1L;

  00266	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0026b	48 83 78 70 00	 cmp	 QWORD PTR [rax+112], 0
  00270	75 0a		 jne	 SHORT $LN7@gzseek
  00272	b8 ff ff ff ff	 mov	 eax, -1
  00277	e9 c8 00 00 00	 jmp	 $LN27@gzseek
$LN7@gzseek:
$LN8@gzseek:

; 836  :     }
; 837  :     if (offset && s->back != EOF) {

  0027c	83 7c 24 48 00	 cmp	 DWORD PTR offset$[rsp], 0
  00281	74 5b		 je	 SHORT $LN6@gzseek
  00283	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00288	83 b8 a4 00 00
	00 ff		 cmp	 DWORD PTR [rax+164], -1
  0028f	74 4d		 je	 SHORT $LN6@gzseek

; 838  :         s->back = EOF;

  00291	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00296	c7 80 a4 00 00
	00 ff ff ff ff	 mov	 DWORD PTR [rax+164], -1

; 839  :         s->out++;

  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002a5	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  002ab	83 c1 01	 add	 ecx, 1
  002ae	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b3	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx

; 840  :         offset--;

  002b9	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  002bd	83 e8 01	 sub	 eax, 1
  002c0	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 841  :         if (s->last) s->z_err = Z_STREAM_END;

  002c4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002c9	83 b8 a8 00 00
	00 00		 cmp	 DWORD PTR [rax+168], 0
  002d0	74 0c		 je	 SHORT $LN5@gzseek
  002d2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002d7	c7 40 58 01 00
	00 00		 mov	 DWORD PTR [rax+88], 1
$LN5@gzseek:
$LN6@gzseek:
$LN4@gzseek:

; 842  :     }
; 843  :     while (offset > 0)  {

  002de	83 7c 24 48 00	 cmp	 DWORD PTR offset$[rsp], 0
  002e3	7e 54		 jle	 SHORT $LN3@gzseek

; 844  :         int size = Z_BUFSIZE;

  002e5	c7 44 24 2c 00
	40 00 00	 mov	 DWORD PTR size$79965[rsp], 16384 ; 00004000H

; 845  :         if (offset < Z_BUFSIZE) size = (int)offset;

  002ed	81 7c 24 48 00
	40 00 00	 cmp	 DWORD PTR offset$[rsp], 16384 ; 00004000H
  002f5	7d 08		 jge	 SHORT $LN2@gzseek
  002f7	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  002fb	89 44 24 2c	 mov	 DWORD PTR size$79965[rsp], eax
$LN2@gzseek:

; 846  : 
; 847  :         size = gzread(file, s->outbuf, (uInt)size);

  002ff	44 8b 44 24 2c	 mov	 r8d, DWORD PTR size$79965[rsp]
  00304	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00309	48 8b 52 70	 mov	 rdx, QWORD PTR [rdx+112]
  0030d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00312	e8 00 00 00 00	 call	 gzread
  00317	89 44 24 2c	 mov	 DWORD PTR size$79965[rsp], eax

; 848  :         if (size <= 0) return -1L;

  0031b	83 7c 24 2c 00	 cmp	 DWORD PTR size$79965[rsp], 0
  00320	7f 07		 jg	 SHORT $LN1@gzseek
  00322	b8 ff ff ff ff	 mov	 eax, -1
  00327	eb 1b		 jmp	 SHORT $LN27@gzseek
$LN1@gzseek:

; 849  :         offset -= size;

  00329	8b 4c 24 2c	 mov	 ecx, DWORD PTR size$79965[rsp]
  0032d	8b 44 24 48	 mov	 eax, DWORD PTR offset$[rsp]
  00331	2b c1		 sub	 eax, ecx
  00333	89 44 24 48	 mov	 DWORD PTR offset$[rsp], eax

; 850  :     }

  00337	eb a5		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:

; 851  :     return s->out;

  00339	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0033e	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
$LN27@gzseek:

; 852  : }

  00344	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00348	c3		 ret	 0
gzseek	ENDP
_TEXT	ENDS
PUBLIC	gzflush
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzflush DD imagerel $LN6
	DD	imagerel $LN6+112
	DD	imagerel $unwind$gzflush
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzflush DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzflush
_TEXT	SEGMENT
s$ = 32
err$ = 40
tv73 = 44
file$ = 64
flush$ = 72
gzflush	PROC						; COMDAT

; 749  : {

$LN6:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 750  :     gz_stream *s = (gz_stream*)file;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR file$[rsp]
  00012	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 751  :     int err = do_flush (file, flush);

  00017	8b 54 24 48	 mov	 edx, DWORD PTR flush$[rsp]
  0001b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00020	e8 00 00 00 00	 call	 do_flush
  00025	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax

; 752  : 
; 753  :     if (err) return err;

  00029	83 7c 24 28 00	 cmp	 DWORD PTR err$[rsp], 0
  0002e	74 06		 je	 SHORT $LN1@gzflush
  00030	8b 44 24 28	 mov	 eax, DWORD PTR err$[rsp]
  00034	eb 35		 jmp	 SHORT $LN2@gzflush
$LN1@gzflush:

; 754  :     fflush(s->file);

  00036	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0003b	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0003f	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_fflush

; 755  :     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;

  00045	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  0004a	41 83 7b 58 01	 cmp	 DWORD PTR [r11+88], 1
  0004f	75 0a		 jne	 SHORT $LN4@gzflush
  00051	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
  00059	eb 0c		 jmp	 SHORT $LN5@gzflush
$LN4@gzflush:
  0005b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00060	8b 40 58	 mov	 eax, DWORD PTR [rax+88]
  00063	89 44 24 2c	 mov	 DWORD PTR tv73[rsp], eax
$LN5@gzflush:
  00067	8b 44 24 2c	 mov	 eax, DWORD PTR tv73[rsp]
$LN2@gzflush:

; 756  : }

  0006b	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0006f	c3		 ret	 0
gzflush	ENDP
_TEXT	ENDS
PUBLIC	gzputs
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputs DD imagerel $LN3
	DD	imagerel $LN3+47
	DD	imagerel $unwind$gzputs
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputs DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzputs
_TEXT	SEGMENT
file$ = 48
s$ = 56
gzputs	PROC						; COMDAT

; 696  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 697  :     return gzwrite(file, (char*)s, (unsigned)strlen(s));

  0000e	48 8b 4c 24 38	 mov	 rcx, QWORD PTR s$[rsp]
  00013	e8 00 00 00 00	 call	 strlen
  00018	44 8b c0	 mov	 r8d, eax
  0001b	48 8b 54 24 38	 mov	 rdx, QWORD PTR s$[rsp]
  00020	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00025	e8 00 00 00 00	 call	 gzwrite

; 698  : }

  0002a	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0002e	c3		 ret	 0
gzputs	ENDP
_TEXT	ENDS
PUBLIC	gzputc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzputc DD imagerel $LN5
	DD	imagerel $LN5+76
	DD	imagerel $unwind$gzputc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzputc DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzputc
_TEXT	SEGMENT
cc$ = 32
tv70 = 36
file$ = 64
c$ = 72
gzputc	PROC						; COMDAT

; 681  : {

$LN5:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 682  :     unsigned char cc = (unsigned char) c; /* required for big endian systems */

  0000d	0f b6 44 24 48	 movzx	 eax, BYTE PTR c$[rsp]
  00012	88 44 24 20	 mov	 BYTE PTR cc$[rsp], al

; 683  : 
; 684  :     return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;

  00016	41 b8 01 00 00
	00		 mov	 r8d, 1
  0001c	48 8d 54 24 20	 lea	 rdx, QWORD PTR cc$[rsp]
  00021	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00026	e8 00 00 00 00	 call	 gzwrite
  0002b	83 f8 01	 cmp	 eax, 1
  0002e	75 0b		 jne	 SHORT $LN3@gzputc
  00030	0f b6 44 24 20	 movzx	 eax, BYTE PTR cc$[rsp]
  00035	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
  00039	eb 08		 jmp	 SHORT $LN4@gzputc
$LN3@gzputc:
  0003b	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv70[rsp], -1
$LN4@gzputc:
  00043	8b 44 24 24	 mov	 eax, DWORD PTR tv70[rsp]

; 685  : }

  00047	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0004b	c3		 ret	 0
gzputc	ENDP
_TEXT	ENDS
PUBLIC	gzprintf
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzprintf DD imagerel $LN5
	DD	imagerel $LN5+160
	DD	imagerel $unwind$gzprintf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzprintf DD 022101H
	DD	02070121H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzprintf
_TEXT	SEGMENT
va$ = 32
len$ = 40
buf$ = 48
file$ = 4160
format$ = 4168
gzprintf PROC						; COMDAT

; 604  : {

$LN5:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000f	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00014	b8 38 10 00 00	 mov	 eax, 4152		; 00001038H
  00019	e8 00 00 00 00	 call	 __chkstk
  0001e	48 2b e0	 sub	 rsp, rax

; 605  :     char buf[Z_PRINTF_BUFSIZE];
; 606  :     va_list va;
; 607  :     int len;
; 608  : 
; 609  :     buf[sizeof(buf) - 1] = 0;

  00021	c6 84 24 2f 10
	00 00 00	 mov	 BYTE PTR buf$[rsp+4095], 0

; 610  :     va_start(va, format);

  00029	48 8d 84 24 50
	10 00 00	 lea	 rax, QWORD PTR format$[rsp+8]
  00031	48 89 44 24 20	 mov	 QWORD PTR va$[rsp], rax

; 611  : #ifdef NO_vsnprintf
; 612  : #  ifdef HAS_vsprintf_void
; 613  :     (void)vsprintf(buf, format, va);
; 614  :     va_end(va);
; 615  :     for (len = 0; len < sizeof(buf); len++)
; 616  :         if (buf[len] == 0) break;
; 617  : #  else
; 618  :     len = vsprintf(buf, format, va);
; 619  :     va_end(va);
; 620  : #  endif
; 621  : #else
; 622  : #  ifdef HAS_vsnprintf_void
; 623  :     (void)vsnprintf(buf, sizeof(buf), format, va);
; 624  :     va_end(va);
; 625  :     len = strlen(buf);
; 626  : #  else
; 627  :     len = vsnprintf(buf, sizeof(buf), format, va);

  00036	4c 8b 4c 24 20	 mov	 r9, QWORD PTR va$[rsp]
  0003b	4c 8b 84 24 48
	10 00 00	 mov	 r8, QWORD PTR format$[rsp]
  00043	ba 00 10 00 00	 mov	 edx, 4096		; 00001000H
  00048	48 8d 4c 24 30	 lea	 rcx, QWORD PTR buf$[rsp]
  0004d	ff 15 00 00 00
	00		 call	 QWORD PTR __imp__vsnprintf
  00053	89 44 24 28	 mov	 DWORD PTR len$[rsp], eax

; 628  :     va_end(va);

  00057	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR va$[rsp], 0

; 629  : #  endif
; 630  : #endif
; 631  :     if (len <= 0 || len >= (int)sizeof(buf) || buf[sizeof(buf) - 1] != 0)

  00060	83 7c 24 28 00	 cmp	 DWORD PTR len$[rsp], 0
  00065	7e 16		 jle	 SHORT $LN1@gzprintf
  00067	81 7c 24 28 00
	10 00 00	 cmp	 DWORD PTR len$[rsp], 4096 ; 00001000H
  0006f	7d 0c		 jge	 SHORT $LN1@gzprintf
  00071	0f be 84 24 2f
	10 00 00	 movsx	 eax, BYTE PTR buf$[rsp+4095]
  00079	85 c0		 test	 eax, eax
  0007b	74 04		 je	 SHORT $LN2@gzprintf
$LN1@gzprintf:

; 632  :         return 0;

  0007d	33 c0		 xor	 eax, eax
  0007f	eb 17		 jmp	 SHORT $LN3@gzprintf
$LN2@gzprintf:

; 633  :     return gzwrite(file, buf, (unsigned)len);

  00081	44 8b 44 24 28	 mov	 r8d, DWORD PTR len$[rsp]
  00086	48 8d 54 24 30	 lea	 rdx, QWORD PTR buf$[rsp]
  0008b	48 8b 8c 24 40
	10 00 00	 mov	 rcx, QWORD PTR file$[rsp]
  00093	e8 00 00 00 00	 call	 gzwrite
$LN3@gzprintf:

; 634  : }

  00098	48 81 c4 38 10
	00 00		 add	 rsp, 4152		; 00001038H
  0009f	c3		 ret	 0
gzprintf ENDP
_TEXT	ENDS
PUBLIC	gzgets
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgets DD imagerel $LN9
	DD	imagerel $LN9+179
	DD	imagerel $unwind$gzgets
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgets DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzgets
_TEXT	SEGMENT
b$ = 32
tv78 = 40
file$ = 64
buf$ = 72
len$ = 80
gzgets	PROC						; COMDAT

; 544  : {

$LN9:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 545  :     char *b = buf;

  00013	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]
  00018	48 89 44 24 20	 mov	 QWORD PTR b$[rsp], rax

; 546  :     if (buf == Z_NULL || len <= 0) return Z_NULL;

  0001d	48 83 7c 24 48
	00		 cmp	 QWORD PTR buf$[rsp], 0
  00023	74 07		 je	 SHORT $LN3@gzgets
  00025	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  0002a	7f 04		 jg	 SHORT $LN4@gzgets
$LN3@gzgets:
  0002c	33 c0		 xor	 eax, eax
  0002e	eb 7e		 jmp	 SHORT $LN5@gzgets
$LN4@gzgets:
$LN2@gzgets:

; 547  : 
; 548  :     while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;

  00030	8b 44 24 50	 mov	 eax, DWORD PTR len$[rsp]
  00034	83 e8 01	 sub	 eax, 1
  00037	89 44 24 50	 mov	 DWORD PTR len$[rsp], eax
  0003b	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  00040	7e 37		 jle	 SHORT $LN1@gzgets
  00042	41 b8 01 00 00
	00		 mov	 r8d, 1
  00048	48 8b 54 24 48	 mov	 rdx, QWORD PTR buf$[rsp]
  0004d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00052	e8 00 00 00 00	 call	 gzread
  00057	83 f8 01	 cmp	 eax, 1
  0005a	75 1d		 jne	 SHORT $LN1@gzgets
  0005c	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]
  00061	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00064	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]
  00069	48 83 c0 01	 add	 rax, 1
  0006d	48 89 44 24 48	 mov	 QWORD PTR buf$[rsp], rax
  00072	83 f9 0a	 cmp	 ecx, 10
  00075	74 02		 je	 SHORT $LN1@gzgets
  00077	eb b7		 jmp	 SHORT $LN2@gzgets
$LN1@gzgets:

; 549  :     *buf = '\0';

  00079	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]
  0007e	c6 00 00	 mov	 BYTE PTR [rax], 0

; 550  :     return b == buf && len > 0 ? Z_NULL : b;

  00081	48 8b 44 24 48	 mov	 rax, QWORD PTR buf$[rsp]
  00086	48 39 44 24 20	 cmp	 QWORD PTR b$[rsp], rax
  0008b	75 12		 jne	 SHORT $LN7@gzgets
  0008d	83 7c 24 50 00	 cmp	 DWORD PTR len$[rsp], 0
  00092	7e 0b		 jle	 SHORT $LN7@gzgets
  00094	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv78[rsp], 0
  0009d	eb 0a		 jmp	 SHORT $LN8@gzgets
$LN7@gzgets:
  0009f	48 8b 44 24 20	 mov	 rax, QWORD PTR b$[rsp]
  000a4	48 89 44 24 28	 mov	 QWORD PTR tv78[rsp], rax
$LN8@gzgets:
  000a9	48 8b 44 24 28	 mov	 rax, QWORD PTR tv78[rsp]
$LN5@gzgets:

; 551  : }

  000ae	48 83 c4 38	 add	 rsp, 56			; 00000038H
  000b2	c3		 ret	 0
gzgets	ENDP
_TEXT	ENDS
PUBLIC	gzgetc
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzgetc DD imagerel $LN5
	DD	imagerel $LN5+63
	DD	imagerel $unwind$gzgetc
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzgetc DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzgetc
_TEXT	SEGMENT
c$ = 32
tv70 = 36
file$ = 64
gzgetc	PROC						; COMDAT

; 505  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 506  :     unsigned char c;
; 507  : 
; 508  :     return gzread(file, &c, 1) == 1 ? c : -1;

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	48 8d 54 24 20	 lea	 rdx, QWORD PTR c$[rsp]
  00014	48 8b 4c 24 40	 mov	 rcx, QWORD PTR file$[rsp]
  00019	e8 00 00 00 00	 call	 gzread
  0001e	83 f8 01	 cmp	 eax, 1
  00021	75 0b		 jne	 SHORT $LN3@gzgetc
  00023	0f b6 44 24 20	 movzx	 eax, BYTE PTR c$[rsp]
  00028	89 44 24 24	 mov	 DWORD PTR tv70[rsp], eax
  0002c	eb 08		 jmp	 SHORT $LN4@gzgetc
$LN3@gzgetc:
  0002e	c7 44 24 24 ff
	ff ff ff	 mov	 DWORD PTR tv70[rsp], -1
$LN4@gzgetc:
  00036	8b 44 24 24	 mov	 eax, DWORD PTR tv70[rsp]

; 509  : }

  0003a	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003e	c3		 ret	 0
gzgetc	ENDP
_TEXT	ENDS
PUBLIC	gzdopen
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzdopen DD imagerel $LN4
	DD	imagerel $LN4+72
	DD	imagerel $unwind$gzdopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzdopen DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzdopen
_TEXT	SEGMENT
name$ = 32
fd$ = 96
mode$ = 104
gzdopen	PROC						; COMDAT

; 222  : {

$LN4:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 223  :     char name[46];      /* allow for up to 128-bit integers */
; 224  : 
; 225  :     if (fd < 0) return (gzFile)Z_NULL;

  0000d	83 7c 24 60 00	 cmp	 DWORD PTR fd$[rsp], 0
  00012	7d 04		 jge	 SHORT $LN1@gzdopen
  00014	33 c0		 xor	 eax, eax
  00016	eb 2b		 jmp	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 226  :     sprintf(name, "<fd:%d>", fd); /* for debugging */

  00018	44 8b 44 24 60	 mov	 r8d, DWORD PTR fd$[rsp]
  0001d	48 8d 15 00 00
	00 00		 lea	 rdx, OFFSET FLAT:??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00024	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  00029	ff 15 00 00 00
	00		 call	 QWORD PTR __imp_sprintf

; 227  : 
; 228  :     return gz_open (name, mode, fd);

  0002f	44 8b 44 24 60	 mov	 r8d, DWORD PTR fd$[rsp]
  00034	48 8b 54 24 68	 mov	 rdx, QWORD PTR mode$[rsp]
  00039	48 8d 4c 24 20	 lea	 rcx, QWORD PTR name$[rsp]
  0003e	e8 00 00 00 00	 call	 gz_open
$LN2@gzdopen:

; 229  : }

  00043	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00047	c3		 ret	 0
gzdopen	ENDP
_TEXT	ENDS
PUBLIC	gzopen
;	COMDAT pdata
pdata	SEGMENT
$pdata$gzopen DD imagerel $LN3
	DD	imagerel $LN3+40
	DD	imagerel $unwind$gzopen
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gzopen DD 010e01H
	DD	0420eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gzopen
_TEXT	SEGMENT
path$ = 48
mode$ = 56
gzopen	PROC						; COMDAT

; 211  : {

$LN3:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 212  :     return gz_open (path, mode, -1);

  0000e	41 b8 ff ff ff
	ff		 mov	 r8d, -1
  00014	48 8b 54 24 38	 mov	 rdx, QWORD PTR mode$[rsp]
  00019	48 8b 4c 24 30	 mov	 rcx, QWORD PTR path$[rsp]
  0001e	e8 00 00 00 00	 call	 gz_open

; 213  : }

  00023	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00027	c3		 ret	 0
gzopen	ENDP
PUBLIC	gztell
;	COMDAT pdata
pdata	SEGMENT
$pdata$gztell DD imagerel $LN3
	DD	imagerel $LN3+32
	DD	imagerel $unwind$gztell
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$gztell DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT gztell
_TEXT	SEGMENT
file$ = 48
gztell	PROC						; COMDAT

; 883  : {

$LN3:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 884  :     return gzseek(file, 0L, SEEK_CUR);

  00009	41 b8 01 00 00
	00		 mov	 r8d, 1
  0000f	33 d2		 xor	 edx, edx
  00011	48 8b 4c 24 30	 mov	 rcx, QWORD PTR file$[rsp]
  00016	e8 00 00 00 00	 call	 gzseek

; 885  : }

  0001b	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0001f	c3		 ret	 0
gztell	ENDP
END
