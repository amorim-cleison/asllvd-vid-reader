; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_05GDHACFMB@1?42?43?$AA@			; `string'
;	COMDAT ??_C@_05GDHACFMB@1?42?43?$AA@
CONST	SEGMENT
??_C@_05GDHACFMB@1?42?43?$AA@ DB '1.2.3', 00H		; `string'
PUBLIC	compressBound
; Function compile flags: /Odtp
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\compress.c
;	COMDAT compressBound
_TEXT	SEGMENT
sourceLen$ = 8
compressBound PROC					; COMDAT

; 77   : {

  00000	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx

; 78   :     return sourceLen + (sourceLen >> 12) + (sourceLen >> 14) + 11;

  00004	8b 44 24 08	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00008	c1 e8 0c	 shr	 eax, 12
  0000b	8b 4c 24 08	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  0000f	03 c8		 add	 ecx, eax
  00011	8b 44 24 08	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00015	c1 e8 0e	 shr	 eax, 14
  00018	8d 44 01 0b	 lea	 eax, DWORD PTR [rcx+rax+11]

; 79   : }

  0001c	c3		 ret	 0
compressBound ENDP
PUBLIC	compress2
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress2 DD imagerel $LN8
	DD	imagerel $LN8+321
	DD	imagerel $unwind$compress2
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress2 DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compress2
_TEXT	SEGMENT
stream$ = 32
err$ = 128
tv77 = 132
dest$ = 160
destLen$ = 168
source$ = 176
sourceLen$ = 184
level$ = 192
compress2 PROC						; COMDAT

; 28   : {

$LN8:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 29   :     z_stream stream;
; 30   :     int err;
; 31   : 
; 32   :     stream.next_in = (Bytef*)source;

  0001b	48 8b 84 24 b0
	00 00 00	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 89 44 24 20	 mov	 QWORD PTR stream$[rsp], rax

; 33   :     stream.avail_in = (uInt)sourceLen;

  00028	8b 84 24 b8 00
	00 00		 mov	 eax, DWORD PTR sourceLen$[rsp]
  0002f	89 44 24 28	 mov	 DWORD PTR stream$[rsp+8], eax

; 34   : #ifdef MAXSEG_64K
; 35   :     /* Check for source > 64K on 16-bit machine: */
; 36   :     if ((uLong)stream.avail_in != sourceLen) return Z_BUF_ERROR;
; 37   : #endif
; 38   :     stream.next_out = dest;

  00033	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR dest$[rsp]
  0003b	48 89 44 24 30	 mov	 QWORD PTR stream$[rsp+16], rax

; 39   :     stream.avail_out = (uInt)*destLen;

  00040	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR destLen$[rsp]
  00048	8b 00		 mov	 eax, DWORD PTR [rax]
  0004a	89 44 24 38	 mov	 DWORD PTR stream$[rsp+24], eax

; 40   :     if ((uLong)stream.avail_out != *destLen) return Z_BUF_ERROR;

  0004e	48 8b 84 24 a8
	00 00 00	 mov	 rax, QWORD PTR destLen$[rsp]
  00056	8b 00		 mov	 eax, DWORD PTR [rax]
  00058	39 44 24 38	 cmp	 DWORD PTR stream$[rsp+24], eax
  0005c	74 0a		 je	 SHORT $LN3@compress2
  0005e	b8 fb ff ff ff	 mov	 eax, -5
  00063	e9 d1 00 00 00	 jmp	 $LN4@compress2
$LN3@compress2:

; 41   : 
; 42   :     stream.zalloc = (alloc_func)0;

  00068	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR stream$[rsp+48], 0

; 43   :     stream.zfree = (free_func)0;

  00071	48 c7 44 24 58
	00 00 00 00	 mov	 QWORD PTR stream$[rsp+56], 0

; 44   :     stream.opaque = (voidpf)0;

  0007a	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR stream$[rsp+64], 0

; 45   : 
; 46   :     err = deflateInit(&stream, level);

  00083	41 b9 58 00 00
	00		 mov	 r9d, 88			; 00000058H
  00089	4c 8d 05 00 00
	00 00		 lea	 r8, OFFSET FLAT:??_C@_05GDHACFMB@1?42?43?$AA@
  00090	8b 94 24 c0 00
	00 00		 mov	 edx, DWORD PTR level$[rsp]
  00097	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  0009c	e8 00 00 00 00	 call	 deflateInit_
  000a1	89 84 24 80 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 47   :     if (err != Z_OK) return err;

  000a8	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR err$[rsp], 0
  000b0	74 09		 je	 SHORT $LN2@compress2
  000b2	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR err$[rsp]
  000b9	eb 7e		 jmp	 SHORT $LN4@compress2
$LN2@compress2:

; 48   : 
; 49   :     err = deflate(&stream, Z_FINISH);

  000bb	ba 04 00 00 00	 mov	 edx, 4
  000c0	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  000c5	e8 00 00 00 00	 call	 deflate
  000ca	89 84 24 80 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 50   :     if (err != Z_STREAM_END) {

  000d1	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR err$[rsp], 1
  000d9	74 38		 je	 SHORT $LN1@compress2

; 51   :         deflateEnd(&stream);

  000db	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  000e0	e8 00 00 00 00	 call	 deflateEnd

; 52   :         return err == Z_OK ? Z_BUF_ERROR : err;

  000e5	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR err$[rsp], 0
  000ed	75 0d		 jne	 SHORT $LN6@compress2
  000ef	c7 84 24 84 00
	00 00 fb ff ff
	ff		 mov	 DWORD PTR tv77[rsp], -5
  000fa	eb 0e		 jmp	 SHORT $LN7@compress2
$LN6@compress2:
  000fc	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR err$[rsp]
  00103	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv77[rsp], eax
$LN7@compress2:
  0010a	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv77[rsp]
  00111	eb 26		 jmp	 SHORT $LN4@compress2
$LN1@compress2:

; 53   :     }
; 54   :     *destLen = stream.total_out;

  00113	48 8b 8c 24 a8
	00 00 00	 mov	 rcx, QWORD PTR destLen$[rsp]
  0011b	8b 44 24 3c	 mov	 eax, DWORD PTR stream$[rsp+28]
  0011f	89 01		 mov	 DWORD PTR [rcx], eax

; 55   : 
; 56   :     err = deflateEnd(&stream);

  00121	48 8d 4c 24 20	 lea	 rcx, QWORD PTR stream$[rsp]
  00126	e8 00 00 00 00	 call	 deflateEnd
  0012b	89 84 24 80 00
	00 00		 mov	 DWORD PTR err$[rsp], eax

; 57   :     return err;

  00132	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR err$[rsp]
$LN4@compress2:

; 58   : }

  00139	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  00140	c3		 ret	 0
compress2 ENDP
PUBLIC	compress
;	COMDAT pdata
pdata	SEGMENT
$pdata$compress DD imagerel $LN3
	DD	imagerel $LN3+62
	DD	imagerel $unwind$compress
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$compress DD 011801H
	DD	06218H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT compress
_TEXT	SEGMENT
dest$ = 64
destLen$ = 72
source$ = 80
sourceLen$ = 88
compress PROC						; COMDAT

; 67   : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 68   :     return compress2(dest, destLen, source, sourceLen, Z_DEFAULT_COMPRESSION);

  00018	c7 44 24 20 ff
	ff ff ff	 mov	 DWORD PTR [rsp+32], -1
  00020	44 8b 4c 24 58	 mov	 r9d, DWORD PTR sourceLen$[rsp]
  00025	4c 8b 44 24 50	 mov	 r8, QWORD PTR source$[rsp]
  0002a	48 8b 54 24 48	 mov	 rdx, QWORD PTR destLen$[rsp]
  0002f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR dest$[rsp]
  00034	e8 00 00 00 00	 call	 compress2

; 69   : }

  00039	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0003d	c3		 ret	 0
compress ENDP
END
