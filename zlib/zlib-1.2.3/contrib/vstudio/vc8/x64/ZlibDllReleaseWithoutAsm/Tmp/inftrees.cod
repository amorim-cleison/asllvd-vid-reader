; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	inflate_copyright
inflate_copyright DB ' inflate 1.2.3 Copyright 1995-2005 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	0c9H
	DW	0c4H
	ORG $+10
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	inflate_table
;	COMDAT pdata
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\inftrees.c
pdata	SEGMENT
$pdata$inflate_table DD imagerel $LN67
	DD	imagerel $LN67+2303
	DD	imagerel $unwind$inflate_table
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate_table DD 021a01H
	DD	015011aH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflate_table
_TEXT	SEGMENT
count$ = 0
extra$ = 32
base$ = 40
huff$ = 48
min$ = 52
mask$ = 56
drop$ = 60
curr$ = 64
root$ = 68
next$ = 72
left$ = 80
len$ = 84
end$ = 88
incr$ = 92
offs$ = 96
fill$ = 128
sym$ = 132
this$ = 136
low$ = 140
used$ = 144
max$ = 148
tv201 = 152
type$ = 176
lens$ = 184
codes$ = 192
table$ = 200
bits$ = 208
work$ = 216
inflate_table PROC					; COMDAT

; 39   : {

$LN67:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  00013	48 81 ec a8 00
	00 00		 sub	 rsp, 168		; 000000a8H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code this;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  0001a	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
  00022	eb 0b		 jmp	 SHORT $LN64@inflate_ta
$LN63@inflate_ta:
  00024	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00028	83 c0 01	 add	 eax, 1
  0002b	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax
$LN64@inflate_ta:
  0002f	83 7c 24 54 0f	 cmp	 DWORD PTR len$[rsp], 15
  00034	77 0c		 ja	 SHORT $LN62@inflate_ta

; 108  :         count[len] = 0;

  00036	8b 4c 24 54	 mov	 ecx, DWORD PTR len$[rsp]
  0003a	33 c0		 xor	 eax, eax
  0003c	66 89 04 4c	 mov	 WORD PTR count$[rsp+rcx*2], ax
  00040	eb e2		 jmp	 SHORT $LN63@inflate_ta
$LN62@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  00042	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0
  0004d	eb 11		 jmp	 SHORT $LN61@inflate_ta
$LN60@inflate_ta:
  0004f	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  00056	83 c0 01	 add	 eax, 1
  00059	89 84 24 84 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax
$LN61@inflate_ta:
  00060	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  00067	39 84 24 84 00
	00 00		 cmp	 DWORD PTR sym$[rsp], eax
  0006e	73 34		 jae	 SHORT $LN59@inflate_ta

; 110  :         count[lens[sym]]++;

  00070	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00077	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0007f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00083	0f b7 14 44	 movzx	 edx, WORD PTR count$[rsp+rax*2]
  00087	66 83 c2 01	 add	 dx, 1
  0008b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00092	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0009a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0009e	66 89 14 44	 mov	 WORD PTR count$[rsp+rax*2], dx
  000a2	eb ab		 jmp	 SHORT $LN60@inflate_ta
$LN59@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  000a4	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  000ac	8b 00		 mov	 eax, DWORD PTR [rax]
  000ae	89 44 24 44	 mov	 DWORD PTR root$[rsp], eax

; 114  :     for (max = MAXBITS; max >= 1; max--)

  000b2	c7 84 24 94 00
	00 00 0f 00 00
	00		 mov	 DWORD PTR max$[rsp], 15
  000bd	eb 11		 jmp	 SHORT $LN58@inflate_ta
$LN57@inflate_ta:
  000bf	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000c6	83 e8 01	 sub	 eax, 1
  000c9	89 84 24 94 00
	00 00		 mov	 DWORD PTR max$[rsp], eax
$LN58@inflate_ta:
  000d0	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  000d8	72 13		 jb	 SHORT $LN56@inflate_ta

; 115  :         if (count[max] != 0) break;

  000da	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000e1	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  000e5	85 c0		 test	 eax, eax
  000e7	74 02		 je	 SHORT $LN55@inflate_ta
  000e9	eb 02		 jmp	 SHORT $LN56@inflate_ta
$LN55@inflate_ta:

; 116  :     if (root > max) root = max;

  000eb	eb d2		 jmp	 SHORT $LN57@inflate_ta
$LN56@inflate_ta:
  000ed	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  000f4	39 44 24 44	 cmp	 DWORD PTR root$[rsp], eax
  000f8	76 0b		 jbe	 SHORT $LN54@inflate_ta
  000fa	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  00101	89 44 24 44	 mov	 DWORD PTR root$[rsp], eax
$LN54@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  00105	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR max$[rsp], 0
  0010d	0f 85 8b 00 00
	00		 jne	 $LN53@inflate_ta

; 118  :         this.op = (unsigned char)64;    /* invalid code marker */

  00113	c6 84 24 88 00
	00 00 40	 mov	 BYTE PTR this$[rsp], 64	; 00000040H

; 119  :         this.bits = (unsigned char)1;

  0011b	c6 84 24 89 00
	00 00 01	 mov	 BYTE PTR this$[rsp+1], 1

; 120  :         this.val = (unsigned short)0;

  00123	33 c0		 xor	 eax, eax
  00125	66 89 84 24 8a
	00 00 00	 mov	 WORD PTR this$[rsp+2], ax

; 121  :         *(*table)++ = this;             /* make a table to force an error */

  0012d	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00135	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00138	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR this$[rsp]
  0013f	89 01		 mov	 DWORD PTR [rcx], eax
  00141	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00149	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0014c	48 83 c1 04	 add	 rcx, 4
  00150	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00158	48 89 08	 mov	 QWORD PTR [rax], rcx

; 122  :         *(*table)++ = this;

  0015b	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00163	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00166	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR this$[rsp]
  0016d	89 01		 mov	 DWORD PTR [rcx], eax
  0016f	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00177	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0017a	48 83 c1 04	 add	 rcx, 4
  0017e	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00186	48 89 08	 mov	 QWORD PTR [rax], rcx

; 123  :         *bits = 1;

  00189	48 8b 84 24 d0
	00 00 00	 mov	 rax, QWORD PTR bits$[rsp]
  00191	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  00197	33 c0		 xor	 eax, eax
  00199	e9 59 07 00 00	 jmp	 $LN65@inflate_ta
$LN53@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min <= MAXBITS; min++)

  0019e	c7 44 24 34 01
	00 00 00	 mov	 DWORD PTR min$[rsp], 1
  001a6	eb 0b		 jmp	 SHORT $LN52@inflate_ta
$LN51@inflate_ta:
  001a8	8b 44 24 34	 mov	 eax, DWORD PTR min$[rsp]
  001ac	83 c0 01	 add	 eax, 1
  001af	89 44 24 34	 mov	 DWORD PTR min$[rsp], eax
$LN52@inflate_ta:
  001b3	83 7c 24 34 0f	 cmp	 DWORD PTR min$[rsp], 15
  001b8	77 10		 ja	 SHORT $LN50@inflate_ta

; 127  :         if (count[min] != 0) break;

  001ba	8b 44 24 34	 mov	 eax, DWORD PTR min$[rsp]
  001be	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  001c2	85 c0		 test	 eax, eax
  001c4	74 02		 je	 SHORT $LN49@inflate_ta
  001c6	eb 02		 jmp	 SHORT $LN50@inflate_ta
$LN49@inflate_ta:

; 128  :     if (root < min) root = min;

  001c8	eb de		 jmp	 SHORT $LN51@inflate_ta
$LN50@inflate_ta:
  001ca	8b 44 24 34	 mov	 eax, DWORD PTR min$[rsp]
  001ce	39 44 24 44	 cmp	 DWORD PTR root$[rsp], eax
  001d2	73 08		 jae	 SHORT $LN48@inflate_ta
  001d4	8b 44 24 34	 mov	 eax, DWORD PTR min$[rsp]
  001d8	89 44 24 44	 mov	 DWORD PTR root$[rsp], eax
$LN48@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  001dc	c7 44 24 50 01
	00 00 00	 mov	 DWORD PTR left$[rsp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  001e4	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  001ec	eb 0b		 jmp	 SHORT $LN47@inflate_ta
$LN46@inflate_ta:
  001ee	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  001f2	83 c0 01	 add	 eax, 1
  001f5	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax
$LN47@inflate_ta:
  001f9	83 7c 24 54 0f	 cmp	 DWORD PTR len$[rsp], 15
  001fe	77 2f		 ja	 SHORT $LN45@inflate_ta

; 133  :         left <<= 1;

  00200	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  00204	d1 e0		 shl	 eax, 1
  00206	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 134  :         left -= count[len];

  0020a	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0020e	0f b7 0c 44	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  00212	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  00216	2b c1		 sub	 eax, ecx
  00218	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  0021c	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  00221	7d 0a		 jge	 SHORT $LN44@inflate_ta
  00223	b8 ff ff ff ff	 mov	 eax, -1
  00228	e9 ca 06 00 00	 jmp	 $LN65@inflate_ta
$LN44@inflate_ta:

; 136  :     }

  0022d	eb bf		 jmp	 SHORT $LN46@inflate_ta
$LN45@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  0022f	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  00234	7e 1e		 jle	 SHORT $LN43@inflate_ta
  00236	83 bc 24 b0 00
	00 00 00	 cmp	 DWORD PTR type$[rsp], 0
  0023e	74 0a		 je	 SHORT $LN42@inflate_ta
  00240	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR max$[rsp], 1
  00248	74 0a		 je	 SHORT $LN43@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  0024a	b8 ff ff ff ff	 mov	 eax, -1
  0024f	e9 a3 06 00 00	 jmp	 $LN65@inflate_ta
$LN43@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  00254	33 c0		 xor	 eax, eax
  00256	66 89 44 24 62	 mov	 WORD PTR offs$[rsp+2], ax

; 142  :     for (len = 1; len < MAXBITS; len++)

  0025b	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR len$[rsp], 1
  00263	eb 0b		 jmp	 SHORT $LN41@inflate_ta
$LN40@inflate_ta:
  00265	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00269	83 c0 01	 add	 eax, 1
  0026c	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax
$LN41@inflate_ta:
  00270	83 7c 24 54 0f	 cmp	 DWORD PTR len$[rsp], 15
  00275	73 23		 jae	 SHORT $LN39@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  00277	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0027b	0f b7 4c 44 60	 movzx	 ecx, WORD PTR offs$[rsp+rax*2]
  00280	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00284	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00288	03 c8		 add	 ecx, eax
  0028a	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0028e	83 c0 01	 add	 eax, 1
  00291	8b c0		 mov	 eax, eax
  00293	66 89 4c 44 60	 mov	 WORD PTR offs$[rsp+rax*2], cx
  00298	eb cb		 jmp	 SHORT $LN40@inflate_ta
$LN39@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  0029a	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0
  002a5	eb 11		 jmp	 SHORT $LN38@inflate_ta
$LN37@inflate_ta:
  002a7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  002ae	83 c0 01	 add	 eax, 1
  002b1	89 84 24 84 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax
$LN38@inflate_ta:
  002b8	8b 84 24 c0 00
	00 00		 mov	 eax, DWORD PTR codes$[rsp]
  002bf	39 84 24 84 00
	00 00		 cmp	 DWORD PTR sym$[rsp], eax
  002c6	73 7c		 jae	 SHORT $LN36@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  002c8	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  002cf	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  002d7	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  002db	85 c0		 test	 eax, eax
  002dd	74 60		 je	 SHORT $LN35@inflate_ta
  002df	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  002e6	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  002ee	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  002f2	0f b7 54 44 60	 movzx	 edx, WORD PTR offs$[rsp+rax*2]
  002f7	48 8b 8c 24 d8
	00 00 00	 mov	 rcx, QWORD PTR work$[rsp]
  002ff	0f b7 84 24 84
	00 00 00	 movzx	 eax, WORD PTR sym$[rsp]
  00307	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0030b	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00312	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  0031a	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0031e	0f b7 54 44 60	 movzx	 edx, WORD PTR offs$[rsp+rax*2]
  00323	66 83 c2 01	 add	 dx, 1
  00327	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  0032e	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  00336	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0033a	66 89 54 44 60	 mov	 WORD PTR offs$[rsp+rax*2], dx
$LN35@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked when a LENS table is being made
; 170  :        against the space in *table, ENOUGH, minus the maximum space needed by
; 171  :        the worst case distance code, MAXD.  This should never happen, but the
; 172  :        sufficiency of ENOUGH has not been proven exhaustively, hence the check.
; 173  :        This assumes that when type == LENS, bits == 9.
; 174  : 
; 175  :        sym increments through all symbols, and the loop terminates when
; 176  :        all codes of length max, i.e. all codes, have been processed.  This
; 177  :        routine permits incomplete codes, so another loop after this one fills
; 178  :        in the rest of the decoding tables with invalid code markers.
; 179  :      */
; 180  : 
; 181  :     /* set up for code type */
; 182  :     switch (type) {

  0033f	e9 63 ff ff ff	 jmp	 $LN37@inflate_ta
$LN36@inflate_ta:
  00344	8b 84 24 b0 00
	00 00		 mov	 eax, DWORD PTR type$[rsp]
  0034b	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv201[rsp], eax
  00352	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR tv201[rsp], 0
  0035a	74 0c		 je	 SHORT $LN32@inflate_ta
  0035c	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR tv201[rsp], 1
  00364	74 23		 je	 SHORT $LN31@inflate_ta
  00366	eb 63		 jmp	 SHORT $LN30@inflate_ta
$LN32@inflate_ta:

; 183  :     case CODES:
; 184  :         base = extra = work;    /* dummy value--not used */

  00368	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  00370	48 89 44 24 20	 mov	 QWORD PTR extra$[rsp], rax
  00375	48 8b 44 24 20	 mov	 rax, QWORD PTR extra$[rsp]
  0037a	48 89 44 24 28	 mov	 QWORD PTR base$[rsp], rax

; 185  :         end = 19;

  0037f	c7 44 24 58 13
	00 00 00	 mov	 DWORD PTR end$[rsp], 19

; 186  :         break;

  00387	eb 62		 jmp	 SHORT $LN33@inflate_ta
$LN31@inflate_ta:

; 187  :     case LENS:
; 188  :         base = lbase;

  00389	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lbase@?1??inflate_table@@9@9
  00390	48 89 44 24 28	 mov	 QWORD PTR base$[rsp], rax

; 189  :         base -= 257;

  00395	48 8b 44 24 28	 mov	 rax, QWORD PTR base$[rsp]
  0039a	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  003a0	48 89 44 24 28	 mov	 QWORD PTR base$[rsp], rax

; 190  :         extra = lext;

  003a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lext@?1??inflate_table@@9@9
  003ac	48 89 44 24 20	 mov	 QWORD PTR extra$[rsp], rax

; 191  :         extra -= 257;

  003b1	48 8b 44 24 20	 mov	 rax, QWORD PTR extra$[rsp]
  003b6	48 2d 02 02 00
	00		 sub	 rax, 514		; 00000202H
  003bc	48 89 44 24 20	 mov	 QWORD PTR extra$[rsp], rax

; 192  :         end = 256;

  003c1	c7 44 24 58 00
	01 00 00	 mov	 DWORD PTR end$[rsp], 256 ; 00000100H

; 193  :         break;

  003c9	eb 20		 jmp	 SHORT $LN33@inflate_ta
$LN30@inflate_ta:

; 194  :     default:            /* DISTS */
; 195  :         base = dbase;

  003cb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dbase@?1??inflate_table@@9@9
  003d2	48 89 44 24 28	 mov	 QWORD PTR base$[rsp], rax

; 196  :         extra = dext;

  003d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?dext@?1??inflate_table@@9@9
  003de	48 89 44 24 20	 mov	 QWORD PTR extra$[rsp], rax

; 197  :         end = -1;

  003e3	c7 44 24 58 ff
	ff ff ff	 mov	 DWORD PTR end$[rsp], -1
$LN33@inflate_ta:

; 198  :     }
; 199  : 
; 200  :     /* initialize state for loop */
; 201  :     huff = 0;                   /* starting code */

  003eb	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0

; 202  :     sym = 0;                    /* starting code symbol */

  003f3	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR sym$[rsp], 0

; 203  :     len = min;                  /* starting code length */

  003fe	8b 44 24 34	 mov	 eax, DWORD PTR min$[rsp]
  00402	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax

; 204  :     next = *table;              /* current table to fill in */

  00406	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  0040e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00411	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax

; 205  :     curr = root;                /* current table index bits */

  00416	8b 44 24 44	 mov	 eax, DWORD PTR root$[rsp]
  0041a	89 44 24 40	 mov	 DWORD PTR curr$[rsp], eax

; 206  :     drop = 0;                   /* current bits to drop from code for index */

  0041e	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 207  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  00426	c7 84 24 8c 00
	00 00 ff ff ff
	ff		 mov	 DWORD PTR low$[rsp], -1	; ffffffffH

; 208  :     used = 1U << root;          /* use root table entries */

  00431	8b 4c 24 44	 mov	 ecx, DWORD PTR root$[rsp]
  00435	b8 01 00 00 00	 mov	 eax, 1
  0043a	d3 e0		 shl	 eax, cl
  0043c	89 84 24 90 00
	00 00		 mov	 DWORD PTR used$[rsp], eax

; 209  :     mask = used - 1;            /* mask for comparing low */

  00443	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR used$[rsp]
  0044a	83 e8 01	 sub	 eax, 1
  0044d	89 44 24 38	 mov	 DWORD PTR mask$[rsp], eax

; 210  : 
; 211  :     /* check available table space */
; 212  :     if (type == LENS && used >= ENOUGH - MAXD)

  00451	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00459	75 17		 jne	 SHORT $LN29@inflate_ta
  0045b	81 bc 24 90 00
	00 00 b0 05 00
	00		 cmp	 DWORD PTR used$[rsp], 1456 ; 000005b0H
  00466	72 0a		 jb	 SHORT $LN29@inflate_ta

; 213  :         return 1;

  00468	b8 01 00 00 00	 mov	 eax, 1
  0046d	e9 85 04 00 00	 jmp	 $LN65@inflate_ta
$LN29@inflate_ta:
$LN28@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         this.bits = (unsigned char)(len - drop);

  00472	8b 4c 24 3c	 mov	 ecx, DWORD PTR drop$[rsp]
  00476	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0047a	2b c1		 sub	 eax, ecx
  0047c	88 84 24 89 00
	00 00		 mov	 BYTE PTR this$[rsp+1], al

; 219  :         if ((int)(work[sym]) < end) {

  00483	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  0048a	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  00492	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00496	3b 44 24 58	 cmp	 eax, DWORD PTR end$[rsp]
  0049a	7d 25		 jge	 SHORT $LN26@inflate_ta

; 220  :             this.op = (unsigned char)0;

  0049c	c6 84 24 88 00
	00 00 00	 mov	 BYTE PTR this$[rsp], 0

; 221  :             this.val = work[sym];

  004a4	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  004ab	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  004b3	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  004b7	66 89 84 24 8a
	00 00 00	 mov	 WORD PTR this$[rsp+2], ax
  004bf	eb 74		 jmp	 SHORT $LN25@inflate_ta
$LN26@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  004c1	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  004c8	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  004d0	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  004d4	3b 44 24 58	 cmp	 eax, DWORD PTR end$[rsp]
  004d8	7e 49		 jle	 SHORT $LN24@inflate_ta

; 224  :             this.op = (unsigned char)(extra[work[sym]]);

  004da	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  004e1	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  004e9	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  004ed	48 8b 44 24 20	 mov	 rax, QWORD PTR extra$[rsp]
  004f2	0f b6 04 48	 movzx	 eax, BYTE PTR [rax+rcx*2]
  004f6	88 84 24 88 00
	00 00		 mov	 BYTE PTR this$[rsp], al

; 225  :             this.val = base[work[sym]];

  004fd	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00504	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  0050c	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  00510	48 8b 44 24 28	 mov	 rax, QWORD PTR base$[rsp]
  00515	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00519	66 89 84 24 8a
	00 00 00	 mov	 WORD PTR this$[rsp+2], ax

; 226  :         }
; 227  :         else {

  00521	eb 12		 jmp	 SHORT $LN23@inflate_ta
$LN24@inflate_ta:

; 228  :             this.op = (unsigned char)(32 + 64);         /* end of block */

  00523	c6 84 24 88 00
	00 00 60	 mov	 BYTE PTR this$[rsp], 96	; 00000060H

; 229  :             this.val = 0;

  0052b	33 c0		 xor	 eax, eax
  0052d	66 89 84 24 8a
	00 00 00	 mov	 WORD PTR this$[rsp+2], ax
$LN23@inflate_ta:
$LN25@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00535	8b 44 24 3c	 mov	 eax, DWORD PTR drop$[rsp]
  00539	8b 4c 24 54	 mov	 ecx, DWORD PTR len$[rsp]
  0053d	2b c8		 sub	 ecx, eax
  0053f	b8 01 00 00 00	 mov	 eax, 1
  00544	d3 e0		 shl	 eax, cl
  00546	89 44 24 5c	 mov	 DWORD PTR incr$[rsp], eax

; 234  :         fill = 1U << curr;

  0054a	8b 4c 24 40	 mov	 ecx, DWORD PTR curr$[rsp]
  0054e	b8 01 00 00 00	 mov	 eax, 1
  00553	d3 e0		 shl	 eax, cl
  00555	89 84 24 80 00
	00 00		 mov	 DWORD PTR fill$[rsp], eax

; 235  :         min = fill;                 /* save offset to next table */

  0055c	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fill$[rsp]
  00563	89 44 24 34	 mov	 DWORD PTR min$[rsp], eax
$LN22@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  00567	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  0056b	8b 84 24 80 00
	00 00		 mov	 eax, DWORD PTR fill$[rsp]
  00572	2b c1		 sub	 eax, ecx
  00574	89 84 24 80 00
	00 00		 mov	 DWORD PTR fill$[rsp], eax

; 238  :             next[(huff >> drop) + fill] = this;

  0057b	8b 44 24 3c	 mov	 eax, DWORD PTR drop$[rsp]
  0057f	0f b6 c8	 movzx	 ecx, al
  00582	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  00586	d3 e8		 shr	 eax, cl
  00588	03 84 24 80 00
	00 00		 add	 eax, DWORD PTR fill$[rsp]
  0058f	8b d0		 mov	 edx, eax
  00591	48 8b 4c 24 48	 mov	 rcx, QWORD PTR next$[rsp]
  00596	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR this$[rsp]
  0059d	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 239  :         } while (fill != 0);

  005a0	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR fill$[rsp], 0
  005a8	75 bd		 jne	 SHORT $LN22@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  005aa	8b 4c 24 54	 mov	 ecx, DWORD PTR len$[rsp]
  005ae	83 e9 01	 sub	 ecx, 1
  005b1	b8 01 00 00 00	 mov	 eax, 1
  005b6	d3 e0		 shl	 eax, cl
  005b8	89 44 24 5c	 mov	 DWORD PTR incr$[rsp], eax
$LN19@inflate_ta:

; 243  :         while (huff & incr)

  005bc	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  005c0	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  005c4	23 c1		 and	 eax, ecx
  005c6	85 c0		 test	 eax, eax
  005c8	74 0c		 je	 SHORT $LN18@inflate_ta

; 244  :             incr >>= 1;

  005ca	8b 44 24 5c	 mov	 eax, DWORD PTR incr$[rsp]
  005ce	d1 e8		 shr	 eax, 1
  005d0	89 44 24 5c	 mov	 DWORD PTR incr$[rsp], eax
  005d4	eb e6		 jmp	 SHORT $LN19@inflate_ta
$LN18@inflate_ta:

; 245  :         if (incr != 0) {

  005d6	83 7c 24 5c 00	 cmp	 DWORD PTR incr$[rsp], 0
  005db	74 21		 je	 SHORT $LN17@inflate_ta

; 246  :             huff &= incr - 1;

  005dd	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  005e1	83 e9 01	 sub	 ecx, 1
  005e4	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  005e8	23 c1		 and	 eax, ecx
  005ea	89 44 24 30	 mov	 DWORD PTR huff$[rsp], eax

; 247  :             huff += incr;

  005ee	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  005f2	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  005f6	03 c1		 add	 eax, ecx
  005f8	89 44 24 30	 mov	 DWORD PTR huff$[rsp], eax

; 248  :         }
; 249  :         else

  005fc	eb 08		 jmp	 SHORT $LN16@inflate_ta
$LN17@inflate_ta:

; 250  :             huff = 0;

  005fe	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN16@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  00606	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR sym$[rsp]
  0060d	83 c0 01	 add	 eax, 1
  00610	89 84 24 84 00
	00 00		 mov	 DWORD PTR sym$[rsp], eax

; 254  :         if (--(count[len]) == 0) {

  00617	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0061b	0f b7 0c 44	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  0061f	66 83 e9 01	 sub	 cx, 1
  00623	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  00627	66 89 0c 44	 mov	 WORD PTR count$[rsp+rax*2], cx
  0062b	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  0062f	0f b7 04 44	 movzx	 eax, WORD PTR count$[rsp+rax*2]
  00633	85 c0		 test	 eax, eax
  00635	75 35		 jne	 SHORT $LN15@inflate_ta

; 255  :             if (len == max) break;

  00637	8b 84 24 94 00
	00 00		 mov	 eax, DWORD PTR max$[rsp]
  0063e	39 44 24 54	 cmp	 DWORD PTR len$[rsp], eax
  00642	75 05		 jne	 SHORT $LN14@inflate_ta
  00644	e9 8a 01 00 00	 jmp	 $LN27@inflate_ta
$LN14@inflate_ta:

; 256  :             len = lens[work[sym]];

  00649	8b 8c 24 84 00
	00 00		 mov	 ecx, DWORD PTR sym$[rsp]
  00650	48 8b 84 24 d8
	00 00 00	 mov	 rax, QWORD PTR work$[rsp]
  00658	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  0065c	48 8b 84 24 b8
	00 00 00	 mov	 rax, QWORD PTR lens$[rsp]
  00664	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00668	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax
$LN15@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  0066c	8b 44 24 44	 mov	 eax, DWORD PTR root$[rsp]
  00670	39 44 24 54	 cmp	 DWORD PTR len$[rsp], eax
  00674	0f 86 54 01 00
	00		 jbe	 $LN13@inflate_ta
  0067a	8b 4c 24 38	 mov	 ecx, DWORD PTR mask$[rsp]
  0067e	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  00682	23 c1		 and	 eax, ecx
  00684	3b 84 24 8c 00
	00 00		 cmp	 eax, DWORD PTR low$[rsp]
  0068b	0f 84 3d 01 00
	00		 je	 $LN13@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  00691	83 7c 24 3c 00	 cmp	 DWORD PTR drop$[rsp], 0
  00696	75 08		 jne	 SHORT $LN12@inflate_ta

; 263  :                 drop = root;

  00698	8b 44 24 44	 mov	 eax, DWORD PTR root$[rsp]
  0069c	89 44 24 3c	 mov	 DWORD PTR drop$[rsp], eax
$LN12@inflate_ta:

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  006a0	8b 4c 24 34	 mov	 ecx, DWORD PTR min$[rsp]
  006a4	48 8b 44 24 48	 mov	 rax, QWORD PTR next$[rsp]
  006a9	48 8d 04 88	 lea	 rax, QWORD PTR [rax+rcx*4]
  006ad	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  006b2	8b 4c 24 3c	 mov	 ecx, DWORD PTR drop$[rsp]
  006b6	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  006ba	2b c1		 sub	 eax, ecx
  006bc	89 44 24 40	 mov	 DWORD PTR curr$[rsp], eax

; 270  :             left = (int)(1 << curr);

  006c0	8b 4c 24 40	 mov	 ecx, DWORD PTR curr$[rsp]
  006c4	b8 01 00 00 00	 mov	 eax, 1
  006c9	d3 e0		 shl	 eax, cl
  006cb	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax
$LN11@inflate_ta:

; 271  :             while (curr + drop < max) {

  006cf	8b 4c 24 3c	 mov	 ecx, DWORD PTR drop$[rsp]
  006d3	8b 44 24 40	 mov	 eax, DWORD PTR curr$[rsp]
  006d7	03 c1		 add	 eax, ecx
  006d9	3b 84 24 94 00
	00 00		 cmp	 eax, DWORD PTR max$[rsp]
  006e0	73 3a		 jae	 SHORT $LN10@inflate_ta

; 272  :                 left -= count[curr + drop];

  006e2	8b 4c 24 3c	 mov	 ecx, DWORD PTR drop$[rsp]
  006e6	8b 44 24 40	 mov	 eax, DWORD PTR curr$[rsp]
  006ea	03 c1		 add	 eax, ecx
  006ec	8b c0		 mov	 eax, eax
  006ee	0f b7 0c 44	 movzx	 ecx, WORD PTR count$[rsp+rax*2]
  006f2	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  006f6	2b c1		 sub	 eax, ecx
  006f8	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 273  :                 if (left <= 0) break;

  006fc	83 7c 24 50 00	 cmp	 DWORD PTR left$[rsp], 0
  00701	7f 02		 jg	 SHORT $LN9@inflate_ta
  00703	eb 17		 jmp	 SHORT $LN10@inflate_ta
$LN9@inflate_ta:

; 274  :                 curr++;

  00705	8b 44 24 40	 mov	 eax, DWORD PTR curr$[rsp]
  00709	83 c0 01	 add	 eax, 1
  0070c	89 44 24 40	 mov	 DWORD PTR curr$[rsp], eax

; 275  :                 left <<= 1;

  00710	8b 44 24 50	 mov	 eax, DWORD PTR left$[rsp]
  00714	d1 e0		 shl	 eax, 1
  00716	89 44 24 50	 mov	 DWORD PTR left$[rsp], eax

; 276  :             }

  0071a	eb b3		 jmp	 SHORT $LN11@inflate_ta
$LN10@inflate_ta:

; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  0071c	8b 4c 24 40	 mov	 ecx, DWORD PTR curr$[rsp]
  00720	b8 01 00 00 00	 mov	 eax, 1
  00725	d3 e0		 shl	 eax, cl
  00727	8b c8		 mov	 ecx, eax
  00729	8b 84 24 90 00
	00 00		 mov	 eax, DWORD PTR used$[rsp]
  00730	03 c1		 add	 eax, ecx
  00732	89 84 24 90 00
	00 00		 mov	 DWORD PTR used$[rsp], eax

; 280  :             if (type == LENS && used >= ENOUGH - MAXD)

  00739	83 bc 24 b0 00
	00 00 01	 cmp	 DWORD PTR type$[rsp], 1
  00741	75 17		 jne	 SHORT $LN8@inflate_ta
  00743	81 bc 24 90 00
	00 00 b0 05 00
	00		 cmp	 DWORD PTR used$[rsp], 1456 ; 000005b0H
  0074e	72 0a		 jb	 SHORT $LN8@inflate_ta

; 281  :                 return 1;

  00750	b8 01 00 00 00	 mov	 eax, 1
  00755	e9 9d 01 00 00	 jmp	 $LN65@inflate_ta
$LN8@inflate_ta:

; 282  : 
; 283  :             /* point entry in root table to sub-table */
; 284  :             low = huff & mask;

  0075a	8b 4c 24 38	 mov	 ecx, DWORD PTR mask$[rsp]
  0075e	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  00762	23 c1		 and	 eax, ecx
  00764	89 84 24 8c 00
	00 00		 mov	 DWORD PTR low$[rsp], eax

; 285  :             (*table)[low].op = (unsigned char)curr;

  0076b	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR low$[rsp]
  00772	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  0077a	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0077d	0f b6 44 24 40	 movzx	 eax, BYTE PTR curr$[rsp]
  00782	88 04 91	 mov	 BYTE PTR [rcx+rdx*4], al

; 286  :             (*table)[low].bits = (unsigned char)root;

  00785	8b 94 24 8c 00
	00 00		 mov	 edx, DWORD PTR low$[rsp]
  0078c	48 8b 8c 24 c8
	00 00 00	 mov	 rcx, QWORD PTR table$[rsp]
  00794	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00797	0f b6 44 24 44	 movzx	 eax, BYTE PTR root$[rsp]
  0079c	88 44 91 01	 mov	 BYTE PTR [rcx+rdx*4+1], al

; 287  :             (*table)[low].val = (unsigned short)(next - *table);

  007a0	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  007a8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007ab	48 8b 54 24 48	 mov	 rdx, QWORD PTR next$[rsp]
  007b0	48 2b d0	 sub	 rdx, rax
  007b3	48 c1 fa 02	 sar	 rdx, 2
  007b7	8b 8c 24 8c 00
	00 00		 mov	 ecx, DWORD PTR low$[rsp]
  007be	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  007c6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007c9	66 89 54 88 02	 mov	 WORD PTR [rax+rcx*4+2], dx
$LN13@inflate_ta:

; 288  :         }
; 289  :     }

  007ce	e9 9f fc ff ff	 jmp	 $LN28@inflate_ta
$LN27@inflate_ta:

; 290  : 
; 291  :     /*
; 292  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 293  :        loop above in incrementing huff for table indices.  It is assumed that
; 294  :        len is equal to curr + drop, so there is no loop needed to increment
; 295  :        through high index bits.  When the current sub-table is filled, the loop
; 296  :        drops back to the root table to fill in any remaining entries there.
; 297  :      */
; 298  :     this.op = (unsigned char)64;                /* invalid code marker */

  007d3	c6 84 24 88 00
	00 00 40	 mov	 BYTE PTR this$[rsp], 64	; 00000040H

; 299  :     this.bits = (unsigned char)(len - drop);

  007db	8b 4c 24 3c	 mov	 ecx, DWORD PTR drop$[rsp]
  007df	8b 44 24 54	 mov	 eax, DWORD PTR len$[rsp]
  007e3	2b c1		 sub	 eax, ecx
  007e5	88 84 24 89 00
	00 00		 mov	 BYTE PTR this$[rsp+1], al

; 300  :     this.val = (unsigned short)0;

  007ec	33 c0		 xor	 eax, eax
  007ee	66 89 84 24 8a
	00 00 00	 mov	 WORD PTR this$[rsp+2], ax
$LN7@inflate_ta:

; 301  :     while (huff != 0) {

  007f6	83 7c 24 30 00	 cmp	 DWORD PTR huff$[rsp], 0
  007fb	0f 84 c5 00 00
	00		 je	 $LN6@inflate_ta

; 302  :         /* when done with sub-table, drop back to root table */
; 303  :         if (drop != 0 && (huff & mask) != low) {

  00801	83 7c 24 3c 00	 cmp	 DWORD PTR drop$[rsp], 0
  00806	74 3f		 je	 SHORT $LN5@inflate_ta
  00808	8b 4c 24 38	 mov	 ecx, DWORD PTR mask$[rsp]
  0080c	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  00810	23 c1		 and	 eax, ecx
  00812	3b 84 24 8c 00
	00 00		 cmp	 eax, DWORD PTR low$[rsp]
  00819	74 2c		 je	 SHORT $LN5@inflate_ta

; 304  :             drop = 0;

  0081b	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR drop$[rsp], 0

; 305  :             len = root;

  00823	8b 44 24 44	 mov	 eax, DWORD PTR root$[rsp]
  00827	89 44 24 54	 mov	 DWORD PTR len$[rsp], eax

; 306  :             next = *table;

  0082b	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  00833	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00836	48 89 44 24 48	 mov	 QWORD PTR next$[rsp], rax

; 307  :             this.bits = (unsigned char)len;

  0083b	0f b6 44 24 54	 movzx	 eax, BYTE PTR len$[rsp]
  00840	88 84 24 89 00
	00 00		 mov	 BYTE PTR this$[rsp+1], al
$LN5@inflate_ta:

; 308  :         }
; 309  : 
; 310  :         /* put invalid code marker in table */
; 311  :         next[huff >> drop] = this;

  00847	8b 44 24 3c	 mov	 eax, DWORD PTR drop$[rsp]
  0084b	0f b6 c8	 movzx	 ecx, al
  0084e	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  00852	d3 e8		 shr	 eax, cl
  00854	8b d0		 mov	 edx, eax
  00856	48 8b 4c 24 48	 mov	 rcx, QWORD PTR next$[rsp]
  0085b	8b 84 24 88 00
	00 00		 mov	 eax, DWORD PTR this$[rsp]
  00862	89 04 91	 mov	 DWORD PTR [rcx+rdx*4], eax

; 312  : 
; 313  :         /* backwards increment the len-bit code huff */
; 314  :         incr = 1U << (len - 1);

  00865	8b 4c 24 54	 mov	 ecx, DWORD PTR len$[rsp]
  00869	83 e9 01	 sub	 ecx, 1
  0086c	b8 01 00 00 00	 mov	 eax, 1
  00871	d3 e0		 shl	 eax, cl
  00873	89 44 24 5c	 mov	 DWORD PTR incr$[rsp], eax
$LN4@inflate_ta:

; 315  :         while (huff & incr)

  00877	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  0087b	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  0087f	23 c1		 and	 eax, ecx
  00881	85 c0		 test	 eax, eax
  00883	74 0c		 je	 SHORT $LN3@inflate_ta

; 316  :             incr >>= 1;

  00885	8b 44 24 5c	 mov	 eax, DWORD PTR incr$[rsp]
  00889	d1 e8		 shr	 eax, 1
  0088b	89 44 24 5c	 mov	 DWORD PTR incr$[rsp], eax
  0088f	eb e6		 jmp	 SHORT $LN4@inflate_ta
$LN3@inflate_ta:

; 317  :         if (incr != 0) {

  00891	83 7c 24 5c 00	 cmp	 DWORD PTR incr$[rsp], 0
  00896	74 21		 je	 SHORT $LN2@inflate_ta

; 318  :             huff &= incr - 1;

  00898	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  0089c	83 e9 01	 sub	 ecx, 1
  0089f	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  008a3	23 c1		 and	 eax, ecx
  008a5	89 44 24 30	 mov	 DWORD PTR huff$[rsp], eax

; 319  :             huff += incr;

  008a9	8b 4c 24 5c	 mov	 ecx, DWORD PTR incr$[rsp]
  008ad	8b 44 24 30	 mov	 eax, DWORD PTR huff$[rsp]
  008b1	03 c1		 add	 eax, ecx
  008b3	89 44 24 30	 mov	 DWORD PTR huff$[rsp], eax

; 320  :         }
; 321  :         else

  008b7	eb 08		 jmp	 SHORT $LN1@inflate_ta
$LN2@inflate_ta:

; 322  :             huff = 0;

  008b9	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR huff$[rsp], 0
$LN1@inflate_ta:

; 323  :     }

  008c1	e9 30 ff ff ff	 jmp	 $LN7@inflate_ta
$LN6@inflate_ta:

; 324  : 
; 325  :     /* set return parameters */
; 326  :     *table += used;

  008c6	8b 8c 24 90 00
	00 00		 mov	 ecx, DWORD PTR used$[rsp]
  008cd	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  008d5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  008d8	48 8d 0c 88	 lea	 rcx, QWORD PTR [rax+rcx*4]
  008dc	48 8b 84 24 c8
	00 00 00	 mov	 rax, QWORD PTR table$[rsp]
  008e4	48 89 08	 mov	 QWORD PTR [rax], rcx

; 327  :     *bits = root;

  008e7	48 8b 8c 24 d0
	00 00 00	 mov	 rcx, QWORD PTR bits$[rsp]
  008ef	8b 44 24 44	 mov	 eax, DWORD PTR root$[rsp]
  008f3	89 01		 mov	 DWORD PTR [rcx], eax

; 328  :     return 0;

  008f5	33 c0		 xor	 eax, eax
$LN65@inflate_ta:

; 329  : }

  008f7	48 81 c4 a8 00
	00 00		 add	 rsp, 168		; 000000a8H
  008fe	c3		 ret	 0
inflate_table ENDP
END
