; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	deflate_copyright
EXTRN	memset:PROC
EXTRN	memcpy:PROC
?my_version@?1??deflateInit2_@@9@9 DB '1.2.3', 00H	; `deflateInit2_'::`2'::my_version
deflate_copyright DB ' deflate 1.2.3 Copyright 1995-2005 Jean-loup Gailly'
	DB	' ', 00H
	ORG $+11
configuration_table DW 00H
	DW	00H
	DW	00H
	DW	00H
	DQ	FLAT:deflate_stored
	DW	04H
	DW	04H
	DW	08H
	DW	04H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	05H
	DW	010H
	DW	08H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	06H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_fast
	DW	04H
	DW	04H
	DW	010H
	DW	010H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	020H
	DW	020H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	010H
	DW	080H
	DW	080H
	DQ	FLAT:deflate_slow
	DW	08H
	DW	020H
	DW	080H
	DW	0100H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	080H
	DW	0102H
	DW	0400H
	DQ	FLAT:deflate_slow
	DW	020H
	DW	0102H
	DW	0102H
	DW	01000H
	DQ	FLAT:deflate_slow
;	COMDAT pdata
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\deflate.c
pdata	SEGMENT
$pdata$longest_match_fast DD imagerel longest_match_fast
	DD	imagerel longest_match_fast+689
	DD	imagerel $unwind$longest_match_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match_fast DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT longest_match_fast
_TEXT	SEGMENT
len$ = 0
scan$ = 8
strend$ = 16
match$ = 24
tv167 = 32
s$ = 64
cur_match$ = 72
longest_match_fast PROC					; COMDAT

; 1178 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1179 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00012	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00018	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  0001d	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00021	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax

; 1180 :     register Bytef *match;                       /* matched string */
; 1181 :     register int len;                           /* length of current match */
; 1182 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;

  00026	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0002b	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00036	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0003a	48 8d 84 08 02
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+258]
  00042	48 89 44 24 10	 mov	 QWORD PTR strend$[rsp], rax

; 1183 : 
; 1184 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1185 :      * It is easy to get rid of this optimization if necessary.
; 1186 :      */
; 1187 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1188 : 
; 1189 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1190 : 
; 1191 :     Assert(cur_match < s->strstart, "no future");
; 1192 : 
; 1193 :     match = s->window + cur_match;

  00047	8b 44 24 48	 mov	 eax, DWORD PTR cur_match$[rsp]
  0004b	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00050	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00054	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax

; 1194 : 
; 1195 :     /* Return failure if the match length is less than 2:
; 1196 :      */
; 1197 :     if (match[0] != scan[0] || match[1] != scan[1]) return MIN_MATCH-1;

  00059	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  0005e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00061	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00066	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00069	3b c8		 cmp	 ecx, eax
  0006b	75 16		 jne	 SHORT $LN6@longest_ma
  0006d	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  00072	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00076	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  0007b	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0007f	3b c8		 cmp	 ecx, eax
  00081	74 0a		 je	 SHORT $LN7@longest_ma
$LN6@longest_ma:
  00083	b8 02 00 00 00	 mov	 eax, 2
  00088	e9 1f 02 00 00	 jmp	 $LN8@longest_ma
$LN7@longest_ma:

; 1198 : 
; 1199 :     /* The check at best_len-1 can be removed because it will be made
; 1200 :      * again later. (This heuristic is not always a win.)
; 1201 :      * It is not necessary to compare scan[2] and match[2] since they
; 1202 :      * are always equal when the other bytes match, given that
; 1203 :      * the hash keys are equal and that HASH_BITS >= 8.
; 1204 :      */
; 1205 :     scan += 2, match += 2;

  0008d	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00092	48 83 c0 02	 add	 rax, 2
  00096	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  0009b	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  000a0	48 83 c0 02	 add	 rax, 2
  000a4	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
$LN5@longest_ma:

; 1206 :     Assert(*scan == *match, "match[2]?");
; 1207 : 
; 1208 :     /* We check for insufficient lookahead only every 8th comparison;
; 1209 :      * the 256th check will be made at strstart+258.
; 1210 :      */
; 1211 :     do {
; 1212 :     } while (*++scan == *++match && *++scan == *++match &&
; 1213 :              *++scan == *++match && *++scan == *++match &&
; 1214 :              *++scan == *++match && *++scan == *++match &&
; 1215 :              *++scan == *++match && *++scan == *++match &&
; 1216 :              scan < strend);

  000a9	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  000ae	48 83 c0 01	 add	 rax, 1
  000b2	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  000b7	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  000bc	48 83 c0 01	 add	 rax, 1
  000c0	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  000c5	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  000ca	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000cd	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  000d2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  000d5	3b c1		 cmp	 eax, ecx
  000d7	0f 85 70 01 00
	00		 jne	 $LN2@longest_ma
  000dd	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  000e2	48 83 c0 01	 add	 rax, 1
  000e6	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  000eb	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  000f0	48 83 c0 01	 add	 rax, 1
  000f4	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  000f9	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  000fe	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00101	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00106	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00109	3b c1		 cmp	 eax, ecx
  0010b	0f 85 3c 01 00
	00		 jne	 $LN2@longest_ma
  00111	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00116	48 83 c0 01	 add	 rax, 1
  0011a	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  0011f	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  00124	48 83 c0 01	 add	 rax, 1
  00128	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  0012d	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  00132	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00135	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  0013a	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0013d	3b c1		 cmp	 eax, ecx
  0013f	0f 85 08 01 00
	00		 jne	 $LN2@longest_ma
  00145	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  0014a	48 83 c0 01	 add	 rax, 1
  0014e	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  00153	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  00158	48 83 c0 01	 add	 rax, 1
  0015c	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  00161	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  00166	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00169	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  0016e	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00171	3b c1		 cmp	 eax, ecx
  00173	0f 85 d4 00 00
	00		 jne	 $LN2@longest_ma
  00179	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  0017e	48 83 c0 01	 add	 rax, 1
  00182	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  00187	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  0018c	48 83 c0 01	 add	 rax, 1
  00190	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  00195	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  0019a	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0019d	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  001a2	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001a5	3b c1		 cmp	 eax, ecx
  001a7	0f 85 a0 00 00
	00		 jne	 $LN2@longest_ma
  001ad	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  001b2	48 83 c0 01	 add	 rax, 1
  001b6	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  001bb	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  001c0	48 83 c0 01	 add	 rax, 1
  001c4	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  001c9	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  001ce	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001d1	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  001d6	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  001d9	3b c1		 cmp	 eax, ecx
  001db	75 70		 jne	 SHORT $LN2@longest_ma
  001dd	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  001e2	48 83 c0 01	 add	 rax, 1
  001e6	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  001eb	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  001f0	48 83 c0 01	 add	 rax, 1
  001f4	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  001f9	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  001fe	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00201	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00206	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00209	3b c1		 cmp	 eax, ecx
  0020b	75 40		 jne	 SHORT $LN2@longest_ma
  0020d	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00212	48 83 c0 01	 add	 rax, 1
  00216	48 89 44 24 08	 mov	 QWORD PTR scan$[rsp], rax
  0021b	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  00220	48 83 c0 01	 add	 rax, 1
  00224	48 89 44 24 18	 mov	 QWORD PTR match$[rsp], rax
  00229	48 8b 44 24 18	 mov	 rax, QWORD PTR match$[rsp]
  0022e	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00231	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00236	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00239	3b c1		 cmp	 eax, ecx
  0023b	75 10		 jne	 SHORT $LN2@longest_ma
  0023d	48 8b 44 24 10	 mov	 rax, QWORD PTR strend$[rsp]
  00242	48 39 44 24 08	 cmp	 QWORD PTR scan$[rsp], rax
  00247	0f 82 5c fe ff
	ff		 jb	 $LN5@longest_ma
$LN2@longest_ma:

; 1217 : 
; 1218 :     Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1219 : 
; 1220 :     len = MAX_MATCH - (int)(strend - scan);

  0024d	48 8b 44 24 08	 mov	 rax, QWORD PTR scan$[rsp]
  00252	48 8b 4c 24 10	 mov	 rcx, QWORD PTR strend$[rsp]
  00257	48 2b c8	 sub	 rcx, rax
  0025a	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  0025f	2b c1		 sub	 eax, ecx
  00261	89 04 24	 mov	 DWORD PTR len$[rsp], eax

; 1221 : 
; 1222 :     if (len < MIN_MATCH) return MIN_MATCH - 1;

  00264	83 3c 24 03	 cmp	 DWORD PTR len$[rsp], 3
  00268	7d 07		 jge	 SHORT $LN1@longest_ma
  0026a	b8 02 00 00 00	 mov	 eax, 2
  0026f	eb 3b		 jmp	 SHORT $LN8@longest_ma
$LN1@longest_ma:

; 1223 : 
; 1224 :     s->match_start = cur_match;

  00271	48 8b 4c 24 40	 mov	 rcx, QWORD PTR s$[rsp]
  00276	8b 44 24 48	 mov	 eax, DWORD PTR cur_match$[rsp]
  0027a	89 81 98 00 00
	00		 mov	 DWORD PTR [rcx+152], eax

; 1225 :     return (uInt)len <= s->lookahead ? (uInt)len : s->lookahead;

  00280	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  00285	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0028b	39 04 24	 cmp	 DWORD PTR len$[rsp], eax
  0028e	77 09		 ja	 SHORT $LN10@longest_ma
  00290	8b 04 24	 mov	 eax, DWORD PTR len$[rsp]
  00293	89 44 24 20	 mov	 DWORD PTR tv167[rsp], eax
  00297	eb 0f		 jmp	 SHORT $LN11@longest_ma
$LN10@longest_ma:
  00299	48 8b 44 24 40	 mov	 rax, QWORD PTR s$[rsp]
  0029e	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  002a4	89 44 24 20	 mov	 DWORD PTR tv167[rsp], eax
$LN11@longest_ma:
  002a8	8b 44 24 20	 mov	 eax, DWORD PTR tv167[rsp]
$LN8@longest_ma:

; 1226 : }

  002ac	48 83 c4 38	 add	 rsp, 56			; 00000038H
  002b0	c3		 ret	 0
longest_match_fast ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$longest_match DD imagerel longest_match
	DD	imagerel longest_match+1114
	DD	imagerel $unwind$longest_match
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$longest_match DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT longest_match
_TEXT	SEGMENT
best_len$ = 0
chain_length$ = 4
scan_end1$ = 8
prev$ = 16
scan_end$ = 24
len$ = 28
scan$ = 32
strend$ = 40
match$ = 48
limit$ = 56
nice_match$ = 60
wmask$ = 64
tv79 = 68
s$ = 96
cur_match$ = 104
longest_match PROC					; COMDAT

; 1030 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1031 :     unsigned chain_length = s->max_chain_length;/* max hash chain length */

  0000d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00012	8b 80 a4 00 00
	00		 mov	 eax, DWORD PTR [rax+164]
  00018	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax

; 1032 :     register Bytef *scan = s->window + s->strstart; /* current string */

  0001c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00021	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00027	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0002c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00030	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax

; 1033 :     register Bytef *match;                       /* matched string */
; 1034 :     register int len;                           /* length of current match */
; 1035 :     int best_len = s->prev_length;              /* best match length so far */

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003a	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00040	89 04 24	 mov	 DWORD PTR best_len$[rsp], eax

; 1036 :     int nice_match = s->nice_match;             /* stop if match long enough */

  00043	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00048	8b 80 b8 00 00
	00		 mov	 eax, DWORD PTR [rax+184]
  0004e	89 44 24 3c	 mov	 DWORD PTR nice_match$[rsp], eax

; 1037 :     IPos limit = s->strstart > (IPos)MAX_DIST(s) ?
; 1038 :         s->strstart - (IPos)MAX_DIST(s) : NIL;

  00052	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00057	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  0005a	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  00060	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00065	39 88 94 00 00
	00		 cmp	 DWORD PTR [rax+148], ecx
  0006b	76 21		 jbe	 SHORT $LN18@longest_ma@2
  0006d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00072	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00075	81 e9 06 01 00
	00		 sub	 ecx, 262		; 00000106H
  0007b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00080	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00086	2b c1		 sub	 eax, ecx
  00088	89 44 24 44	 mov	 DWORD PTR tv79[rsp], eax
  0008c	eb 08		 jmp	 SHORT $LN19@longest_ma@2
$LN18@longest_ma@2:
  0008e	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR tv79[rsp], 0
$LN19@longest_ma@2:
  00096	8b 44 24 44	 mov	 eax, DWORD PTR tv79[rsp]
  0009a	89 44 24 38	 mov	 DWORD PTR limit$[rsp], eax

; 1039 :     /* Stop when cur_match becomes <= limit. To simplify the code,
; 1040 :      * we prevent matches with the string of window index 0.
; 1041 :      */
; 1042 :     Posf *prev = s->prev;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a3	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  000a7	48 89 44 24 10	 mov	 QWORD PTR prev$[rsp], rax

; 1043 :     uInt wmask = s->w_mask;

  000ac	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b1	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  000b4	89 44 24 40	 mov	 DWORD PTR wmask$[rsp], eax

; 1044 : 
; 1045 : #ifdef UNALIGNED_OK
; 1046 :     /* Compare two bytes at a time. Note: this is not always beneficial.
; 1047 :      * Try with and without -DUNALIGNED_OK to check.
; 1048 :      */
; 1049 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH - 1;
; 1050 :     register ush scan_start = *(ushf*)scan;
; 1051 :     register ush scan_end   = *(ushf*)(scan+best_len-1);
; 1052 : #else
; 1053 :     register Bytef *strend = s->window + s->strstart + MAX_MATCH;

  000b8	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000bd	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  000c3	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000c8	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000cc	48 8d 84 08 02
	01 00 00	 lea	 rax, QWORD PTR [rax+rcx+258]
  000d4	48 89 44 24 28	 mov	 QWORD PTR strend$[rsp], rax

; 1054 :     register Byte scan_end1  = scan[best_len-1];

  000d9	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  000dc	83 e8 01	 sub	 eax, 1
  000df	48 63 c8	 movsxd	 rcx, eax
  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  000e7	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000eb	88 44 24 08	 mov	 BYTE PTR scan_end1$[rsp], al

; 1055 :     register Byte scan_end   = scan[best_len];

  000ef	48 63 0c 24	 movsxd	 rcx, DWORD PTR best_len$[rsp]
  000f3	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  000f8	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000fc	88 44 24 18	 mov	 BYTE PTR scan_end$[rsp], al

; 1056 : #endif
; 1057 : 
; 1058 :     /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.
; 1059 :      * It is easy to get rid of this optimization if necessary.
; 1060 :      */
; 1061 :     Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");
; 1062 : 
; 1063 :     /* Do not waste too much time if we already have a good match: */
; 1064 :     if (s->prev_length >= s->good_match) {

  00100	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00105	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0010a	8b 80 b4 00 00
	00		 mov	 eax, DWORD PTR [rax+180]
  00110	39 81 a0 00 00
	00		 cmp	 DWORD PTR [rcx+160], eax
  00116	72 0b		 jb	 SHORT $LN15@longest_ma@2

; 1065 :         chain_length >>= 2;

  00118	8b 44 24 04	 mov	 eax, DWORD PTR chain_length$[rsp]
  0011c	c1 e8 02	 shr	 eax, 2
  0011f	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax
$LN15@longest_ma@2:

; 1066 :     }
; 1067 :     /* Do not look for matches beyond the end of the input. This is necessary
; 1068 :      * to make deflate deterministic.
; 1069 :      */
; 1070 :     if ((uInt)nice_match > s->lookahead) nice_match = s->lookahead;

  00123	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00128	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0012e	39 44 24 3c	 cmp	 DWORD PTR nice_match$[rsp], eax
  00132	76 0f		 jbe	 SHORT $LN14@longest_ma@2
  00134	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00139	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  0013f	89 44 24 3c	 mov	 DWORD PTR nice_match$[rsp], eax
$LN14@longest_ma@2:
$LN13@longest_ma@2:

; 1071 : 
; 1072 :     Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");
; 1073 : 
; 1074 :     do {
; 1075 :         Assert(cur_match < s->strstart, "no future");
; 1076 :         match = s->window + cur_match;

  00143	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  00147	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0014c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00150	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax

; 1077 : 
; 1078 :         /* Skip to next match if the match length cannot increase
; 1079 :          * or if the match length is less than 2.  Note that the checks below
; 1080 :          * for insufficient lookahead only occur occasionally for performance
; 1081 :          * reasons.  Therefore uninitialized memory will be accessed, and
; 1082 :          * conditional jumps will be made that depend on those values.
; 1083 :          * However the length of the match is limited to the lookahead, so
; 1084 :          * the output of deflate is not affected by the uninitialized values.
; 1085 :          */
; 1086 : #if (defined(UNALIGNED_OK) && MAX_MATCH == 258)
; 1087 :         /* This code assumes sizeof(unsigned short) == 2. Do not use
; 1088 :          * UNALIGNED_OK if your compiler uses a different size.
; 1089 :          */
; 1090 :         if (*(ushf*)(match+best_len-1) != scan_end ||
; 1091 :             *(ushf*)match != scan_start) continue;
; 1092 : 
; 1093 :         /* It is not necessary to compare scan[2] and match[2] since they are
; 1094 :          * always equal when the other bytes match, given that the hash keys
; 1095 :          * are equal and that HASH_BITS >= 8. Compare 2 bytes at a time at
; 1096 :          * strstart+3, +5, ... up to strstart+257. We check for insufficient
; 1097 :          * lookahead only every 4th comparison; the 128th check will be made
; 1098 :          * at strstart+257. If MAX_MATCH-2 is not a multiple of 8, it is
; 1099 :          * necessary to put more guard bytes at the end of the window, or
; 1100 :          * to check more often for insufficient lookahead.
; 1101 :          */
; 1102 :         Assert(scan[2] == match[2], "scan[2]?");
; 1103 :         scan++, match++;
; 1104 :         do {
; 1105 :         } while (*(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1106 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1107 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1108 :                  *(ushf*)(scan+=2) == *(ushf*)(match+=2) &&
; 1109 :                  scan < strend);
; 1110 :         /* The funny "do {}" generates better code on most compilers */
; 1111 : 
; 1112 :         /* Here, scan <= window+strstart+257 */
; 1113 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1114 :         if (*scan == *match) scan++;
; 1115 : 
; 1116 :         len = (MAX_MATCH - 1) - (int)(strend-scan);
; 1117 :         scan = strend - (MAX_MATCH-1);
; 1118 : 
; 1119 : #else /* UNALIGNED_OK */
; 1120 : 
; 1121 :         if (match[best_len]   != scan_end  ||
; 1122 :             match[best_len-1] != scan_end1 ||
; 1123 :             *match            != *scan     ||
; 1124 :             *++match          != scan[1])      continue;

  00155	48 63 0c 24	 movsxd	 rcx, DWORD PTR best_len$[rsp]
  00159	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0015e	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00162	0f b6 44 24 18	 movzx	 eax, BYTE PTR scan_end$[rsp]
  00167	3b c8		 cmp	 ecx, eax
  00169	75 52		 jne	 SHORT $LN9@longest_ma@2
  0016b	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  0016e	83 e8 01	 sub	 eax, 1
  00171	48 63 c8	 movsxd	 rcx, eax
  00174	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00179	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  0017d	0f b6 44 24 08	 movzx	 eax, BYTE PTR scan_end1$[rsp]
  00182	3b c8		 cmp	 ecx, eax
  00184	75 37		 jne	 SHORT $LN9@longest_ma@2
  00186	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0018b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0018e	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00193	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00196	3b c8		 cmp	 ecx, eax
  00198	75 23		 jne	 SHORT $LN9@longest_ma@2
  0019a	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0019f	48 83 c0 01	 add	 rax, 1
  001a3	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  001a8	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001ad	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  001b0	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001b5	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  001b9	3b c8		 cmp	 ecx, eax
  001bb	74 05		 je	 SHORT $LN10@longest_ma@2
$LN9@longest_ma@2:
  001bd	e9 3a 02 00 00	 jmp	 $LN12@longest_ma@2
$LN10@longest_ma@2:

; 1125 : 
; 1126 :         /* The check at best_len-1 can be removed because it will be made
; 1127 :          * again later. (This heuristic is not always a win.)
; 1128 :          * It is not necessary to compare scan[2] and match[2] since they
; 1129 :          * are always equal when the other bytes match, given that
; 1130 :          * the hash keys are equal and that HASH_BITS >= 8.
; 1131 :          */
; 1132 :         scan += 2, match++;

  001c2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001c7	48 83 c0 02	 add	 rax, 2
  001cb	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  001d0	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001d5	48 83 c0 01	 add	 rax, 1
  001d9	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
$LN8@longest_ma@2:

; 1133 :         Assert(*scan == *match, "match[2]?");
; 1134 : 
; 1135 :         /* We check for insufficient lookahead only every 8th comparison;
; 1136 :          * the 256th check will be made at strstart+258.
; 1137 :          */
; 1138 :         do {
; 1139 :         } while (*++scan == *++match && *++scan == *++match &&
; 1140 :                  *++scan == *++match && *++scan == *++match &&
; 1141 :                  *++scan == *++match && *++scan == *++match &&
; 1142 :                  *++scan == *++match && *++scan == *++match &&
; 1143 :                  scan < strend);

  001de	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  001e3	48 83 c0 01	 add	 rax, 1
  001e7	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  001ec	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001f1	48 83 c0 01	 add	 rax, 1
  001f5	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  001fa	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  001ff	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00202	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00207	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0020a	3b c1		 cmp	 eax, ecx
  0020c	0f 85 70 01 00
	00		 jne	 $LN5@longest_ma@2
  00212	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00217	48 83 c0 01	 add	 rax, 1
  0021b	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00220	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00225	48 83 c0 01	 add	 rax, 1
  00229	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0022e	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00233	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00236	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0023b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0023e	3b c1		 cmp	 eax, ecx
  00240	0f 85 3c 01 00
	00		 jne	 $LN5@longest_ma@2
  00246	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0024b	48 83 c0 01	 add	 rax, 1
  0024f	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00254	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00259	48 83 c0 01	 add	 rax, 1
  0025d	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00262	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00267	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0026a	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0026f	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  00272	3b c1		 cmp	 eax, ecx
  00274	0f 85 08 01 00
	00		 jne	 $LN5@longest_ma@2
  0027a	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0027f	48 83 c0 01	 add	 rax, 1
  00283	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00288	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0028d	48 83 c0 01	 add	 rax, 1
  00291	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  00296	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  0029b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0029e	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002a3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002a6	3b c1		 cmp	 eax, ecx
  002a8	0f 85 d4 00 00
	00		 jne	 $LN5@longest_ma@2
  002ae	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002b3	48 83 c0 01	 add	 rax, 1
  002b7	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  002bc	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002c1	48 83 c0 01	 add	 rax, 1
  002c5	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  002ca	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002cf	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  002d2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002d7	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  002da	3b c1		 cmp	 eax, ecx
  002dc	0f 85 a0 00 00
	00		 jne	 $LN5@longest_ma@2
  002e2	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  002e7	48 83 c0 01	 add	 rax, 1
  002eb	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  002f0	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  002f5	48 83 c0 01	 add	 rax, 1
  002f9	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  002fe	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00303	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00306	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0030b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0030e	3b c1		 cmp	 eax, ecx
  00310	75 70		 jne	 SHORT $LN5@longest_ma@2
  00312	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00317	48 83 c0 01	 add	 rax, 1
  0031b	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00320	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00325	48 83 c0 01	 add	 rax, 1
  00329	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0032e	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00333	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00336	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0033b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0033e	3b c1		 cmp	 eax, ecx
  00340	75 40		 jne	 SHORT $LN5@longest_ma@2
  00342	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00347	48 83 c0 01	 add	 rax, 1
  0034b	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax
  00350	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00355	48 83 c0 01	 add	 rax, 1
  00359	48 89 44 24 30	 mov	 QWORD PTR match$[rsp], rax
  0035e	48 8b 44 24 30	 mov	 rax, QWORD PTR match$[rsp]
  00363	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00366	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  0036b	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  0036e	3b c1		 cmp	 eax, ecx
  00370	75 10		 jne	 SHORT $LN5@longest_ma@2
  00372	48 8b 44 24 28	 mov	 rax, QWORD PTR strend$[rsp]
  00377	48 39 44 24 20	 cmp	 QWORD PTR scan$[rsp], rax
  0037c	0f 82 5c fe ff
	ff		 jb	 $LN8@longest_ma@2
$LN5@longest_ma@2:

; 1144 : 
; 1145 :         Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");
; 1146 : 
; 1147 :         len = MAX_MATCH - (int)(strend - scan);

  00382	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  00387	48 8b 4c 24 28	 mov	 rcx, QWORD PTR strend$[rsp]
  0038c	48 2b c8	 sub	 rcx, rax
  0038f	b8 02 01 00 00	 mov	 eax, 258		; 00000102H
  00394	2b c1		 sub	 eax, ecx
  00396	89 44 24 1c	 mov	 DWORD PTR len$[rsp], eax

; 1148 :         scan = strend - MAX_MATCH;

  0039a	48 8b 44 24 28	 mov	 rax, QWORD PTR strend$[rsp]
  0039f	48 2d 02 01 00
	00		 sub	 rax, 258		; 00000102H
  003a5	48 89 44 24 20	 mov	 QWORD PTR scan$[rsp], rax

; 1149 : 
; 1150 : #endif /* UNALIGNED_OK */
; 1151 : 
; 1152 :         if (len > best_len) {

  003aa	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  003ad	39 44 24 1c	 cmp	 DWORD PTR len$[rsp], eax
  003b1	7e 49		 jle	 SHORT $LN4@longest_ma@2

; 1153 :             s->match_start = cur_match;

  003b3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  003b8	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  003bc	89 81 98 00 00
	00		 mov	 DWORD PTR [rcx+152], eax

; 1154 :             best_len = len;

  003c2	8b 44 24 1c	 mov	 eax, DWORD PTR len$[rsp]
  003c6	89 04 24	 mov	 DWORD PTR best_len$[rsp], eax

; 1155 :             if (len >= nice_match) break;

  003c9	8b 44 24 3c	 mov	 eax, DWORD PTR nice_match$[rsp]
  003cd	39 44 24 1c	 cmp	 DWORD PTR len$[rsp], eax
  003d1	7c 02		 jl	 SHORT $LN3@longest_ma@2
  003d3	eb 60		 jmp	 SHORT $LN11@longest_ma@2
$LN3@longest_ma@2:

; 1156 : #ifdef UNALIGNED_OK
; 1157 :             scan_end = *(ushf*)(scan+best_len-1);
; 1158 : #else
; 1159 :             scan_end1  = scan[best_len-1];

  003d5	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  003d8	83 e8 01	 sub	 eax, 1
  003db	48 63 c8	 movsxd	 rcx, eax
  003de	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  003e3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003e7	88 44 24 08	 mov	 BYTE PTR scan_end1$[rsp], al

; 1160 :             scan_end   = scan[best_len];

  003eb	48 63 0c 24	 movsxd	 rcx, DWORD PTR best_len$[rsp]
  003ef	48 8b 44 24 20	 mov	 rax, QWORD PTR scan$[rsp]
  003f4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  003f8	88 44 24 18	 mov	 BYTE PTR scan_end$[rsp], al
$LN4@longest_ma@2:
$LN12@longest_ma@2:

; 1161 : #endif
; 1162 :         }
; 1163 :     } while ((cur_match = prev[cur_match & wmask]) > limit
; 1164 :              && --chain_length != 0);

  003fc	8b 4c 24 40	 mov	 ecx, DWORD PTR wmask$[rsp]
  00400	8b 44 24 68	 mov	 eax, DWORD PTR cur_match$[rsp]
  00404	23 c1		 and	 eax, ecx
  00406	8b c8		 mov	 ecx, eax
  00408	48 8b 44 24 10	 mov	 rax, QWORD PTR prev$[rsp]
  0040d	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00411	89 44 24 68	 mov	 DWORD PTR cur_match$[rsp], eax
  00415	8b 44 24 38	 mov	 eax, DWORD PTR limit$[rsp]
  00419	39 44 24 68	 cmp	 DWORD PTR cur_match$[rsp], eax
  0041d	76 16		 jbe	 SHORT $LN2@longest_ma@2
  0041f	8b 44 24 04	 mov	 eax, DWORD PTR chain_length$[rsp]
  00423	83 e8 01	 sub	 eax, 1
  00426	89 44 24 04	 mov	 DWORD PTR chain_length$[rsp], eax
  0042a	83 7c 24 04 00	 cmp	 DWORD PTR chain_length$[rsp], 0
  0042f	0f 85 0e fd ff
	ff		 jne	 $LN13@longest_ma@2
$LN2@longest_ma@2:
$LN11@longest_ma@2:

; 1165 : 
; 1166 :     if ((uInt)best_len <= s->lookahead) return (uInt)best_len;

  00435	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0043a	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00440	39 04 24	 cmp	 DWORD PTR best_len$[rsp], eax
  00443	77 05		 ja	 SHORT $LN1@longest_ma@2
  00445	8b 04 24	 mov	 eax, DWORD PTR best_len$[rsp]
  00448	eb 0b		 jmp	 SHORT $LN16@longest_ma@2
$LN1@longest_ma@2:

; 1167 :     return s->lookahead;

  0044a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0044f	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
$LN16@longest_ma@2:

; 1168 : }

  00455	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00459	c3		 ret	 0
longest_match ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$lm_init DD imagerel lm_init
	DD	imagerel lm_init+350
	DD	imagerel $unwind$lm_init
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$lm_init DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT lm_init
_TEXT	SEGMENT
s$ = 48
lm_init	PROC						; COMDAT

; 988  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 989  :     s->window_size = (ulg)2L*s->w_size;

  00009	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00011	d1 e1		 shl	 ecx, 1
  00013	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00018	89 48 58	 mov	 DWORD PTR [rax+88], ecx

; 990  : 
; 991  :     CLEAR_HASH(s);

  0001b	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00020	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00023	83 e8 01	 sub	 eax, 1
  00026	8b d0		 mov	 edx, eax
  00028	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0002d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00031	33 c0		 xor	 eax, eax
  00033	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00037	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0003c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0003f	83 e8 01	 sub	 eax, 1
  00042	44 8b c0	 mov	 r8d, eax
  00045	49 d1 e0	 shl	 r8, 1
  00048	33 d2		 xor	 edx, edx
  0004a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR s$[rsp]
  0004f	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00053	e8 00 00 00 00	 call	 memset

; 992  : 
; 993  :     /* Set the default configuration parameters:
; 994  :      */
; 995  :     s->max_lazy_match   = configuration_table[s->level].max_lazy;

  00058	4c 8b 5c 24 30	 mov	 r11, QWORD PTR s$[rsp]
  0005d	49 63 8b ac 00
	00 00		 movsxd	 rcx, DWORD PTR [r11+172]
  00064	48 6b c9 10	 imul	 rcx, 16
  00068	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0006f	0f b7 4c 08 02	 movzx	 ecx, WORD PTR [rax+rcx+2]
  00074	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00079	89 88 a8 00 00
	00		 mov	 DWORD PTR [rax+168], ecx

; 996  :     s->good_match       = configuration_table[s->level].good_length;

  0007f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00084	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  0008b	48 6b c9 10	 imul	 rcx, 16
  0008f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00096	0f b7 0c 08	 movzx	 ecx, WORD PTR [rax+rcx]
  0009a	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  0009f	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 997  :     s->nice_match       = configuration_table[s->level].nice_length;

  000a5	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000aa	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  000b1	48 6b c9 10	 imul	 rcx, 16
  000b5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  000bc	0f b7 4c 08 04	 movzx	 ecx, WORD PTR [rax+rcx+4]
  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000c6	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 998  :     s->max_chain_length = configuration_table[s->level].max_chain;

  000cc	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000d1	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  000d8	48 6b c9 10	 imul	 rcx, 16
  000dc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  000e3	0f b7 4c 08 06	 movzx	 ecx, WORD PTR [rax+rcx+6]
  000e8	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000ed	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx

; 999  : 
; 1000 :     s->strstart = 0;

  000f3	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  000f8	c7 80 94 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+148], 0

; 1001 :     s->block_start = 0L;

  00102	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00107	c7 80 84 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+132], 0

; 1002 :     s->lookahead = 0;

  00111	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00116	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1003 :     s->match_length = s->prev_length = MIN_MATCH-1;

  00120	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00125	c7 80 a0 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+160], 2
  0012f	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00134	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1004 :     s->match_available = 0;

  0013e	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00143	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1005 :     s->ins_h = 0;

  0014d	48 8b 44 24 30	 mov	 rax, QWORD PTR s$[rsp]
  00152	c7 40 70 00 00
	00 00		 mov	 DWORD PTR [rax+112], 0

; 1006 : #ifndef FASTEST
; 1007 : #ifdef ASMV
; 1008 :     match_init(); /* initialize the asm code */
; 1009 : #endif
; 1010 : #endif
; 1011 : }

  00159	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0015d	c3		 ret	 0
lm_init	ENDP
_TEXT	ENDS
PUBLIC	deflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateEnd DD imagerel $LN12
	DD	imagerel $LN12+374
	DD	imagerel $unwind$deflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateEnd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateEnd
_TEXT	SEGMENT
status$ = 32
tv151 = 36
strm$ = 64
deflateEnd PROC						; COMDAT

; 861  : {

$LN12:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 862  :     int status;
; 863  : 
; 864  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN6@deflateEnd
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN7@deflateEnd
$LN6@deflateEnd:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 4a 01 00 00	 jmp	 $LN8@deflateEnd
$LN7@deflateEnd:

; 865  : 
; 866  :     status = strm->state->status;

  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  00033	89 44 24 20	 mov	 DWORD PTR status$[rsp], eax

; 867  :     if (status != INIT_STATE &&
; 868  :         status != EXTRA_STATE &&
; 869  :         status != NAME_STATE &&
; 870  :         status != COMMENT_STATE &&
; 871  :         status != HCRC_STATE &&
; 872  :         status != BUSY_STATE &&
; 873  :         status != FINISH_STATE) {

  00037	83 7c 24 20 2a	 cmp	 DWORD PTR status$[rsp], 42 ; 0000002aH
  0003c	74 37		 je	 SHORT $LN5@deflateEnd
  0003e	83 7c 24 20 45	 cmp	 DWORD PTR status$[rsp], 69 ; 00000045H
  00043	74 30		 je	 SHORT $LN5@deflateEnd
  00045	83 7c 24 20 49	 cmp	 DWORD PTR status$[rsp], 73 ; 00000049H
  0004a	74 29		 je	 SHORT $LN5@deflateEnd
  0004c	83 7c 24 20 5b	 cmp	 DWORD PTR status$[rsp], 91 ; 0000005bH
  00051	74 22		 je	 SHORT $LN5@deflateEnd
  00053	83 7c 24 20 67	 cmp	 DWORD PTR status$[rsp], 103 ; 00000067H
  00058	74 1b		 je	 SHORT $LN5@deflateEnd
  0005a	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  0005f	74 14		 je	 SHORT $LN5@deflateEnd
  00061	81 7c 24 20 9a
	02 00 00	 cmp	 DWORD PTR status$[rsp], 666 ; 0000029aH
  00069	74 0a		 je	 SHORT $LN5@deflateEnd

; 874  :       return Z_STREAM_ERROR;

  0006b	b8 fe ff ff ff	 mov	 eax, -2
  00070	e9 fc 00 00 00	 jmp	 $LN8@deflateEnd
$LN5@deflateEnd:

; 875  :     }
; 876  : 
; 877  :     /* Deallocate in reverse order of allocations: */
; 878  :     TRY_FREE(strm, strm->state->pending_buf);

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00083	74 1e		 je	 SHORT $LN4@deflateEnd
  00085	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  0008a	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  0008e	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00092	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00097	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0009b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a0	ff 50 38	 call	 QWORD PTR [rax+56]
$LN4@deflateEnd:

; 879  :     TRY_FREE(strm, strm->state->head);

  000a3	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a8	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000ac	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  000b1	74 1e		 je	 SHORT $LN3@deflateEnd
  000b3	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000b8	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  000bc	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  000c0	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000c5	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000c9	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ce	ff 50 38	 call	 QWORD PTR [rax+56]
$LN3@deflateEnd:

; 880  :     TRY_FREE(strm, strm->state->prev);

  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000da	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  000df	74 1e		 je	 SHORT $LN2@deflateEnd
  000e1	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000e6	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  000ea	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  000ee	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f3	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000f7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000fc	ff 50 38	 call	 QWORD PTR [rax+56]
$LN2@deflateEnd:

; 881  :     TRY_FREE(strm, strm->state->window);

  000ff	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00104	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00108	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0010d	74 1e		 je	 SHORT $LN1@deflateEnd
  0010f	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00114	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00118	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  0011c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00121	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00125	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0012a	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@deflateEnd:

; 882  : 
; 883  :     ZFREE(strm, strm->state);

  0012d	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00132	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00136	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0013b	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0013f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00144	ff 50 38	 call	 QWORD PTR [rax+56]

; 884  :     strm->state = Z_NULL;

  00147	4c 8b 5c 24 40	 mov	 r11, QWORD PTR strm$[rsp]
  0014c	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 885  : 
; 886  :     return status == BUSY_STATE ? Z_DATA_ERROR : Z_OK;

  00154	83 7c 24 20 71	 cmp	 DWORD PTR status$[rsp], 113 ; 00000071H
  00159	75 0a		 jne	 SHORT $LN10@deflateEnd
  0015b	c7 44 24 24 fd
	ff ff ff	 mov	 DWORD PTR tv151[rsp], -3
  00163	eb 08		 jmp	 SHORT $LN11@deflateEnd
$LN10@deflateEnd:
  00165	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR tv151[rsp], 0
$LN11@deflateEnd:
  0016d	8b 44 24 24	 mov	 eax, DWORD PTR tv151[rsp]
$LN8@deflateEnd:

; 887  : }

  00171	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00175	c3		 ret	 0
deflateEnd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$flush_pending DD imagerel flush_pending
	DD	imagerel flush_pending+265
	DD	imagerel $unwind$flush_pending
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$flush_pending DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT flush_pending
_TEXT	SEGMENT
len$ = 32
strm$ = 64
flush_pending PROC					; COMDAT

; 534  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 535  :     unsigned len = strm->state->pending;

  00009	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0000e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00012	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00015	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 536  : 
; 537  :     if (len > strm->avail_out) len = strm->avail_out;

  00019	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0001e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00021	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00025	76 0c		 jbe	 SHORT $LN3@flush_pend
  00027	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002f	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN3@flush_pend:

; 538  :     if (len == 0) return;

  00033	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00038	75 05		 jne	 SHORT $LN2@flush_pend
  0003a	e9 c5 00 00 00	 jmp	 $LN4@flush_pend
$LN2@flush_pend:

; 539  : 
; 540  :     zmemcpy(strm->next_out, strm->state->pending_out, len);

  0003f	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00044	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00049	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  0004d	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  00051	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00056	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0005a	e8 00 00 00 00	 call	 memcpy

; 541  :     strm->next_out  += len;

  0005f	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00063	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00068	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  0006c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00071	48 89 48 10	 mov	 QWORD PTR [rax+16], rcx

; 542  :     strm->state->pending_out  += len;

  00075	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007e	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  00082	48 03 48 20	 add	 rcx, QWORD PTR [rax+32]
  00086	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0008f	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 543  :     strm->total_out += len;

  00093	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00098	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0009b	03 4c 24 20	 add	 ecx, DWORD PTR len$[rsp]
  0009f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a4	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 544  :     strm->avail_out  -= len;

  000a7	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000ac	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000b0	8b 49 18	 mov	 ecx, DWORD PTR [rcx+24]
  000b3	2b c8		 sub	 ecx, eax
  000b5	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ba	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 545  :     strm->state->pending -= len;

  000bd	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000c2	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000c6	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  000ca	8b 49 28	 mov	 ecx, DWORD PTR [rcx+40]
  000cd	2b c8		 sub	 ecx, eax
  000cf	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d4	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000d8	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 546  :     if (strm->state->pending == 0) {

  000db	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e0	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000e4	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  000e8	75 1a		 jne	 SHORT $LN1@flush_pend

; 547  :         strm->state->pending_out = strm->state->pending_buf;

  000ea	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ef	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  000f3	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f8	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  000fc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00100	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
$LN1@flush_pend:
$LN4@flush_pend:

; 548  :     }
; 549  : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
flush_pending ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT putShortMSB
_TEXT	SEGMENT
s$ = 8
b$ = 16
putShortMSB PROC					; COMDAT

; 521  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 522  :     put_byte(s, (Byte)(b >> 8));

  00009	8b 54 24 10	 mov	 edx, DWORD PTR b$[rsp]
  0000d	c1 ea 08	 shr	 edx, 8
  00010	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00015	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00018	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0001d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00021	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00024	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00029	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0002c	83 c1 01	 add	 ecx, 1
  0002f	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00034	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 523  :     put_byte(s, (Byte)(b & 0xff));

  00037	8b 54 24 10	 mov	 edx, DWORD PTR b$[rsp]
  0003b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00041	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00046	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00049	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0004e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00052	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00055	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  0005a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0005d	83 c1 01	 add	 ecx, 1
  00060	48 8b 44 24 08	 mov	 rax, QWORD PTR s$[rsp]
  00065	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 524  : }

  00068	c3		 ret	 0
putShortMSB ENDP
_TEXT	ENDS
PUBLIC	deflatePrime
; Function compile flags: /Odtp
;	COMDAT deflatePrime
_TEXT	SEGMENT
strm$ = 8
bits$ = 16
value$ = 24
deflatePrime PROC					; COMDAT

; 408  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 409  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0000e	48 83 7c 24 08
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00014	74 0c		 je	 SHORT $LN1@deflatePri
  00016	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  0001b	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00020	75 07		 jne	 SHORT $LN2@deflatePri
$LN1@deflatePri:
  00022	b8 fe ff ff ff	 mov	 eax, -2
  00027	eb 39		 jmp	 SHORT $LN3@deflatePri
$LN2@deflatePri:

; 410  :     strm->state->bi_valid = bits;

  00029	48 8b 4c 24 08	 mov	 rcx, QWORD PTR strm$[rsp]
  0002e	48 8b 49 28	 mov	 rcx, QWORD PTR [rcx+40]
  00032	8b 44 24 10	 mov	 eax, DWORD PTR bits$[rsp]
  00036	89 81 14 17 00
	00		 mov	 DWORD PTR [rcx+5908], eax

; 411  :     strm->state->bi_buf = (ush)(value & ((1 << bits) - 1));

  0003c	8b 4c 24 10	 mov	 ecx, DWORD PTR bits$[rsp]
  00040	b8 01 00 00 00	 mov	 eax, 1
  00045	d3 e0		 shl	 eax, cl
  00047	83 e8 01	 sub	 eax, 1
  0004a	8b 4c 24 18	 mov	 ecx, DWORD PTR value$[rsp]
  0004e	23 c8		 and	 ecx, eax
  00050	48 8b 44 24 08	 mov	 rax, QWORD PTR strm$[rsp]
  00055	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00059	66 89 88 10 17
	00 00		 mov	 WORD PTR [rax+5904], cx

; 412  :     return Z_OK;

  00060	33 c0		 xor	 eax, eax
$LN3@deflatePri:

; 413  : }

  00062	f3 c3		 fatret	 0
deflatePrime ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$read_buf DD imagerel read_buf
	DD	imagerel read_buf+265
	DD	imagerel $unwind$read_buf
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$read_buf DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT read_buf
_TEXT	SEGMENT
len$ = 32
strm$ = 64
buf$ = 72
size$ = 80
read_buf PROC						; COMDAT

; 960  : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 961  :     unsigned len = strm->avail_in;

  00013	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00018	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  0001b	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax

; 962  : 
; 963  :     if (len > size) len = size;

  0001f	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  00023	39 44 24 20	 cmp	 DWORD PTR len$[rsp], eax
  00027	76 08		 jbe	 SHORT $LN5@read_buf
  00029	8b 44 24 50	 mov	 eax, DWORD PTR size$[rsp]
  0002d	89 44 24 20	 mov	 DWORD PTR len$[rsp], eax
$LN5@read_buf:

; 964  :     if (len == 0) return 0;

  00031	83 7c 24 20 00	 cmp	 DWORD PTR len$[rsp], 0
  00036	75 07		 jne	 SHORT $LN4@read_buf
  00038	33 c0		 xor	 eax, eax
  0003a	e9 c5 00 00 00	 jmp	 $LN6@read_buf
$LN4@read_buf:

; 965  : 
; 966  :     strm->avail_in  -= len;

  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00044	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
  00048	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  0004b	2b c8		 sub	 ecx, eax
  0004d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00052	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 967  : 
; 968  :     if (strm->state->wrap == 1) {

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0005e	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  00062	75 28		 jne	 SHORT $LN3@read_buf

; 969  :         strm->adler = adler32(strm->adler, strm->next_in, len);

  00064	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  00069	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  0006e	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  00071	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00076	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00079	e8 00 00 00 00	 call	 adler32
  0007e	44 8b d8	 mov	 r11d, eax
  00081	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00086	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
  0008a	eb 35		 jmp	 SHORT $LN2@read_buf
$LN3@read_buf:

; 970  :     }
; 971  : #ifdef GZIP
; 972  :     else if (strm->state->wrap == 2) {

  0008c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00091	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00095	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00099	75 26		 jne	 SHORT $LN1@read_buf

; 973  :         strm->adler = crc32(strm->adler, strm->next_in, len);

  0009b	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000a0	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000a5	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000a8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ad	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000b0	e8 00 00 00 00	 call	 crc32
  000b5	44 8b d8	 mov	 r11d, eax
  000b8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000bd	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN1@read_buf:
$LN2@read_buf:

; 974  :     }
; 975  : #endif
; 976  :     zmemcpy(buf, strm->next_in, len);

  000c1	44 8b 44 24 20	 mov	 r8d, DWORD PTR len$[rsp]
  000c6	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000cb	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  000ce	48 8b 4c 24 48	 mov	 rcx, QWORD PTR buf$[rsp]
  000d3	e8 00 00 00 00	 call	 memcpy

; 977  :     strm->next_in  += len;

  000d8	8b 4c 24 20	 mov	 ecx, DWORD PTR len$[rsp]
  000dc	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e1	48 03 08	 add	 rcx, QWORD PTR [rax]
  000e4	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000e9	48 89 08	 mov	 QWORD PTR [rax], rcx

; 978  :     strm->total_in += len;

  000ec	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000f1	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  000f4	03 4c 24 20	 add	 ecx, DWORD PTR len$[rsp]
  000f8	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000fd	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 979  : 
; 980  :     return (int)len;

  00100	8b 44 24 20	 mov	 eax, DWORD PTR len$[rsp]
$LN6@read_buf:

; 981  : }

  00104	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00108	c3		 ret	 0
read_buf ENDP
_TEXT	ENDS
PUBLIC	deflateCopy
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateCopy DD imagerel $LN8
	DD	imagerel $LN8+773
	DD	imagerel $unwind$deflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateCopy DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateCopy
_TEXT	SEGMENT
overlay$ = 32
ds$ = 40
ss$ = 48
dest$ = 80
source$ = 88
deflateCopy PROC					; COMDAT

; 897  : {

$LN8:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 898  : #ifdef MAXSEG_64K
; 899  :     return Z_STREAM_ERROR;
; 900  : #else
; 901  :     deflate_state *ds;
; 902  :     deflate_state *ss;
; 903  :     ushf *overlay;
; 904  : 
; 905  : 
; 906  :     if (source == Z_NULL || dest == Z_NULL || source->state == Z_NULL) {

  0000e	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  00014	74 14		 je	 SHORT $LN4@deflateCop
  00016	48 83 7c 24 50
	00		 cmp	 QWORD PTR dest$[rsp], 0
  0001c	74 0c		 je	 SHORT $LN4@deflateCop
  0001e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	75 0a		 jne	 SHORT $LN5@deflateCop
$LN4@deflateCop:

; 907  :         return Z_STREAM_ERROR;

  0002a	b8 fe ff ff ff	 mov	 eax, -2
  0002f	e9 cc 02 00 00	 jmp	 $LN6@deflateCop
$LN5@deflateCop:

; 908  :     }
; 909  : 
; 910  :     ss = source->state;

  00034	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00039	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003d	48 89 44 24 30	 mov	 QWORD PTR ss$[rsp], rax

; 911  : 
; 912  :     zmemcpy(dest, source, sizeof(z_stream));

  00042	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  00048	48 8b 54 24 58	 mov	 rdx, QWORD PTR source$[rsp]
  0004d	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00052	e8 00 00 00 00	 call	 memcpy

; 913  : 
; 914  :     ds = (deflate_state *) ZALLOC(dest, 1, sizeof(deflate_state));

  00057	41 b8 18 17 00
	00		 mov	 r8d, 5912		; 00001718H
  0005d	ba 01 00 00 00	 mov	 edx, 1
  00062	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00067	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0006b	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00070	ff 50 30	 call	 QWORD PTR [rax+48]
  00073	48 89 44 24 28	 mov	 QWORD PTR ds$[rsp], rax

; 915  :     if (ds == Z_NULL) return Z_MEM_ERROR;

  00078	48 83 7c 24 28
	00		 cmp	 QWORD PTR ds$[rsp], 0
  0007e	75 0a		 jne	 SHORT $LN3@deflateCop
  00080	b8 fc ff ff ff	 mov	 eax, -4
  00085	e9 76 02 00 00	 jmp	 $LN6@deflateCop
$LN3@deflateCop:

; 916  :     dest->state = (struct internal_state FAR *) ds;

  0008a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00094	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 917  :     zmemcpy(ds, ss, sizeof(deflate_state));

  00098	41 b8 18 17 00
	00		 mov	 r8d, 5912		; 00001718H
  0009e	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  000a3	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  000a8	e8 00 00 00 00	 call	 memcpy

; 918  :     ds->strm = dest;

  000ad	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  000b2	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000b7	49 89 03	 mov	 QWORD PTR [r11], rax

; 919  : 
; 920  :     ds->window = (Bytef *) ZALLOC(dest, ds->w_size, 2*sizeof(Byte));

  000ba	41 b8 02 00 00
	00		 mov	 r8d, 2
  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000c5	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  000cd	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000d1	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	4c 8b d8	 mov	 r11, rax
  000dc	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000e1	4c 89 58 50	 mov	 QWORD PTR [rax+80], r11

; 921  :     ds->prev   = (Posf *)  ZALLOC(dest, ds->w_size, sizeof(Pos));

  000e5	41 b8 02 00 00
	00		 mov	 r8d, 2
  000eb	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  000f0	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  000f3	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  000f8	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000fc	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  00101	ff 50 30	 call	 QWORD PTR [rax+48]
  00104	4c 8b d8	 mov	 r11, rax
  00107	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0010c	4c 89 58 60	 mov	 QWORD PTR [rax+96], r11

; 922  :     ds->head   = (Posf *)  ZALLOC(dest, ds->hash_size, sizeof(Pos));

  00110	41 b8 02 00 00
	00		 mov	 r8d, 2
  00116	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0011b	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  0011e	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00123	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0012c	ff 50 30	 call	 QWORD PTR [rax+48]
  0012f	4c 8b d8	 mov	 r11, rax
  00132	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00137	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11

; 923  :     overlay = (ushf *) ZALLOC(dest, ds->lit_bufsize, sizeof(ush)+2);

  0013b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00141	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00146	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  0014c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00151	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00155	48 8b 44 24 50	 mov	 rax, QWORD PTR dest$[rsp]
  0015a	ff 50 30	 call	 QWORD PTR [rax+48]
  0015d	48 89 44 24 20	 mov	 QWORD PTR overlay$[rsp], rax

; 924  :     ds->pending_buf = (uchf *) overlay;

  00162	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00167	48 8b 44 24 20	 mov	 rax, QWORD PTR overlay$[rsp]
  0016c	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 925  : 
; 926  :     if (ds->window == Z_NULL || ds->prev == Z_NULL || ds->head == Z_NULL ||
; 927  :         ds->pending_buf == Z_NULL) {

  00170	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00175	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  0017a	74 24		 je	 SHORT $LN1@deflateCop
  0017c	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00181	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00186	74 18		 je	 SHORT $LN1@deflateCop
  00188	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0018d	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  00192	74 0c		 je	 SHORT $LN1@deflateCop
  00194	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00199	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0019e	75 14		 jne	 SHORT $LN2@deflateCop
$LN1@deflateCop:

; 928  :         deflateEnd (dest);

  001a0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  001a5	e8 00 00 00 00	 call	 deflateEnd

; 929  :         return Z_MEM_ERROR;

  001aa	b8 fc ff ff ff	 mov	 eax, -4
  001af	e9 4c 01 00 00	 jmp	 $LN6@deflateCop
$LN2@deflateCop:

; 930  :     }
; 931  :     /* following zmemcpy do not work for 16-bit MSDOS */
; 932  :     zmemcpy(ds->window, ss->window, ds->w_size * 2 * sizeof(Byte));

  001b4	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  001b9	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001bc	d1 e0		 shl	 eax, 1
  001be	44 8b c0	 mov	 r8d, eax
  001c1	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  001c6	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  001ca	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  001cf	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  001d3	e8 00 00 00 00	 call	 memcpy

; 933  :     zmemcpy(ds->prev, ss->prev, ds->w_size * sizeof(Pos));

  001d8	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  001dd	45 8b 43 44	 mov	 r8d, DWORD PTR [r11+68]
  001e1	49 d1 e0	 shl	 r8, 1
  001e4	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  001e9	48 8b 52 60	 mov	 rdx, QWORD PTR [rdx+96]
  001ed	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  001f2	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  001f6	e8 00 00 00 00	 call	 memcpy

; 934  :     zmemcpy(ds->head, ss->head, ds->hash_size * sizeof(Pos));

  001fb	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  00200	45 8b 43 74	 mov	 r8d, DWORD PTR [r11+116]
  00204	49 d1 e0	 shl	 r8, 1
  00207	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  0020c	48 8b 52 68	 mov	 rdx, QWORD PTR [rdx+104]
  00210	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00215	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00219	e8 00 00 00 00	 call	 memcpy

; 935  :     zmemcpy(ds->pending_buf, ss->pending_buf, (uInt)ds->pending_buf_size);

  0021e	4c 8b 5c 24 28	 mov	 r11, QWORD PTR ds$[rsp]
  00223	45 8b 43 18	 mov	 r8d, DWORD PTR [r11+24]
  00227	48 8b 54 24 30	 mov	 rdx, QWORD PTR ss$[rsp]
  0022c	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00230	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  00235	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00239	e8 00 00 00 00	 call	 memcpy

; 936  : 
; 937  :     ds->pending_out = ds->pending_buf + (ss->pending_out - ss->pending_buf);

  0023e	48 8b 4c 24 30	 mov	 rcx, QWORD PTR ss$[rsp]
  00243	48 8b 44 24 30	 mov	 rax, QWORD PTR ss$[rsp]
  00248	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0024c	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00250	48 2b c8	 sub	 rcx, rax
  00253	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00258	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  0025c	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00261	48 89 48 20	 mov	 QWORD PTR [rax+32], rcx

; 938  :     ds->d_buf = overlay + ds->lit_bufsize/sizeof(ush);

  00265	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0026a	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  00270	33 d2		 xor	 edx, edx
  00272	b9 02 00 00 00	 mov	 ecx, 2
  00277	48 f7 f1	 div	 rcx
  0027a	48 8b c8	 mov	 rcx, rax
  0027d	48 8b 44 24 20	 mov	 rax, QWORD PTR overlay$[rsp]
  00282	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  00286	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  0028b	48 89 88 f8 16
	00 00		 mov	 QWORD PTR [rax+5880], rcx

; 939  :     ds->l_buf = ds->pending_buf + (1+sizeof(ush))*ds->lit_bufsize;

  00292	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  00297	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  0029d	48 6b c9 03	 imul	 rcx, 3
  002a1	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002a6	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  002aa	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002af	48 89 88 e8 16
	00 00		 mov	 QWORD PTR [rax+5864], rcx

; 940  : 
; 941  :     ds->l_desc.dyn_tree = ds->dyn_ltree;

  002b6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002bb	48 81 c1 bc 00
	00 00		 add	 rcx, 188		; 000000bcH
  002c2	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002c7	48 89 88 40 0b
	00 00		 mov	 QWORD PTR [rax+2880], rcx

; 942  :     ds->d_desc.dyn_tree = ds->dyn_dtree;

  002ce	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002d3	48 81 c1 b0 09
	00 00		 add	 rcx, 2480		; 000009b0H
  002da	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002df	48 89 88 58 0b
	00 00		 mov	 QWORD PTR [rax+2904], rcx

; 943  :     ds->bl_desc.dyn_tree = ds->bl_tree;

  002e6	48 8b 4c 24 28	 mov	 rcx, QWORD PTR ds$[rsp]
  002eb	48 81 c1 a4 0a
	00 00		 add	 rcx, 2724		; 00000aa4H
  002f2	48 8b 44 24 28	 mov	 rax, QWORD PTR ds$[rsp]
  002f7	48 89 88 70 0b
	00 00		 mov	 QWORD PTR [rax+2928], rcx

; 944  : 
; 945  :     return Z_OK;

  002fe	33 c0		 xor	 eax, eax
$LN6@deflateCop:

; 946  : #endif /* MAXSEG_64K */
; 947  : }

  00300	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00304	c3		 ret	 0
deflateCopy ENDP
_TEXT	ENDS
PUBLIC	deflate
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate DD imagerel $LN104
	DD	imagerel $LN104+4831
	DD	imagerel $unwind$deflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate DD 021001H
	DD	0110110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate
_TEXT	SEGMENT
s$ = 32
old_flush$ = 40
level_flags$78370 = 44
header$78369 = 48
beg$78385 = 52
beg$78398 = 56
val$78399 = 60
beg$78412 = 64
val$78413 = 68
bstate$78439 = 72
tv199 = 76
tv198 = 80
tv219 = 84
tv223 = 88
tv228 = 92
tv233 = 96
tv238 = 100
tv302 = 104
tv301 = 108
tv816 = 112
strm$ = 144
flush$ = 152
deflate	PROC						; COMDAT

; 555  : {

$LN104:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec 88 00
	00 00		 sub	 rsp, 136		; 00000088H

; 556  :     int old_flush; /* value of flush param for previous deflate call */
; 557  :     deflate_state *s;
; 558  : 
; 559  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 560  :         flush > Z_FINISH || flush < 0) {

  00010	48 83 bc 24 90
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 23		 je	 SHORT $LN80@deflate
  0001b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 14		 je	 SHORT $LN80@deflate
  0002a	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00032	7f 0a		 jg	 SHORT $LN80@deflate
  00034	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  0003c	7d 0a		 jge	 SHORT $LN81@deflate
$LN80@deflate:

; 561  :         return Z_STREAM_ERROR;

  0003e	b8 fe ff ff ff	 mov	 eax, -2
  00043	e9 8f 12 00 00	 jmp	 $LN82@deflate
$LN81@deflate:

; 562  :     }
; 563  :     s = strm->state;

  00048	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00050	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00054	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 564  : 
; 565  :     if (strm->next_out == Z_NULL ||
; 566  :         (strm->next_in == Z_NULL && strm->avail_in != 0) ||
; 567  :         (s->status == FINISH_STATE && flush != Z_FINISH)) {

  00059	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00061	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00066	74 34		 je	 SHORT $LN78@deflate
  00068	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00074	75 0e		 jne	 SHORT $LN77@deflate
  00076	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0007e	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00082	75 18		 jne	 SHORT $LN78@deflate
$LN77@deflate:
  00084	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00089	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00090	75 27		 jne	 SHORT $LN79@deflate
  00092	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  0009a	74 1d		 je	 SHORT $LN79@deflate
$LN78@deflate:

; 568  :         ERR_RETURN(strm, Z_STREAM_ERROR);

  0009c	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  000a4	48 8b 05 20 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+32
  000ab	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  000af	b8 fe ff ff ff	 mov	 eax, -2
  000b4	e9 1e 12 00 00	 jmp	 $LN82@deflate
$LN79@deflate:

; 569  :     }
; 570  :     if (strm->avail_out == 0) ERR_RETURN(strm, Z_BUF_ERROR);

  000b9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c1	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  000c5	75 1d		 jne	 SHORT $LN76@deflate
  000c7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  000cf	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  000d6	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  000da	b8 fb ff ff ff	 mov	 eax, -5
  000df	e9 f3 11 00 00	 jmp	 $LN82@deflate
$LN76@deflate:

; 571  : 
; 572  :     s->strm = strm; /* just in case */

  000e4	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000f1	48 89 01	 mov	 QWORD PTR [rcx], rax

; 573  :     old_flush = s->last_flush;

  000f4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000f9	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000fc	89 44 24 28	 mov	 DWORD PTR old_flush$[rsp], eax

; 574  :     s->last_flush = flush;

  00100	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00105	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR flush$[rsp]
  0010c	89 41 40	 mov	 DWORD PTR [rcx+64], eax

; 575  : 
; 576  :     /* Write the header */
; 577  :     if (s->status == INIT_STATE) {

  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00114	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  00118	0f 85 c9 06 00
	00		 jne	 $LN75@deflate

; 578  : #ifdef GZIP
; 579  :         if (s->wrap == 2) {

  0011e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00123	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  00127	0f 85 84 05 00
	00		 jne	 $LN74@deflate

; 580  :             strm->adler = crc32(0L, Z_NULL, 0);

  0012d	45 33 c0	 xor	 r8d, r8d
  00130	33 d2		 xor	 edx, edx
  00132	33 c9		 xor	 ecx, ecx
  00134	e8 00 00 00 00	 call	 crc32
  00139	44 8b d8	 mov	 r11d, eax
  0013c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00144	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d

; 581  :             put_byte(s, 31);

  00148	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0014d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00150	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00155	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00159	c6 04 01 1f	 mov	 BYTE PTR [rcx+rax], 31
  0015d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00162	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00165	83 c1 01	 add	 ecx, 1
  00168	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0016d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 582  :             put_byte(s, 139);

  00170	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00175	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00178	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0017d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00181	c6 04 01 8b	 mov	 BYTE PTR [rcx+rax], 139	; 0000008bH
  00185	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0018a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0018d	83 c1 01	 add	 ecx, 1
  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00195	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 583  :             put_byte(s, 8);

  00198	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0019d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001a5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001a9	c6 04 01 08	 mov	 BYTE PTR [rcx+rax], 8
  001ad	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001b2	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001b5	83 c1 01	 add	 ecx, 1
  001b8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001bd	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 584  :             if (s->gzhead == NULL) {

  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001c5	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  001ca	0f 85 7b 01 00
	00		 jne	 $LN73@deflate

; 585  :                 put_byte(s, 0);

  001d0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d5	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001d8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001dd	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  001e1	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  001e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001ea	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001ed	83 c1 01	 add	 ecx, 1
  001f0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f5	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 586  :                 put_byte(s, 0);

  001f8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001fd	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00200	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00205	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00209	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0020d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00212	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00215	83 c1 01	 add	 ecx, 1
  00218	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0021d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 587  :                 put_byte(s, 0);

  00220	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00225	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00228	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0022d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00231	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00235	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0023a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0023d	83 c1 01	 add	 ecx, 1
  00240	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00245	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 588  :                 put_byte(s, 0);

  00248	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0024d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00250	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00255	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00259	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  0025d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00262	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00265	83 c1 01	 add	 ecx, 1
  00268	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0026d	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 589  :                 put_byte(s, 0);

  00270	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00275	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00278	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0027d	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00281	c6 04 01 00	 mov	 BYTE PTR [rcx+rax], 0
  00285	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0028a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0028d	83 c1 01	 add	 ecx, 1
  00290	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00295	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 590  :                 put_byte(s, s->level == 9 ? 2 :
; 591  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 592  :                              4 : 0));

  00298	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0029d	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  002a4	75 0a		 jne	 SHORT $LN86@deflate
  002a6	c7 44 24 4c 02
	00 00 00	 mov	 DWORD PTR tv199[rsp], 2
  002ae	eb 36		 jmp	 SHORT $LN87@deflate
$LN86@deflate:
  002b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b5	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  002bc	7d 18		 jge	 SHORT $LN84@deflate
  002be	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002c3	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  002ca	7c 0a		 jl	 SHORT $LN84@deflate
  002cc	c7 44 24 50 00
	00 00 00	 mov	 DWORD PTR tv198[rsp], 0
  002d4	eb 08		 jmp	 SHORT $LN85@deflate
$LN84@deflate:
  002d6	c7 44 24 50 04
	00 00 00	 mov	 DWORD PTR tv198[rsp], 4
$LN85@deflate:
  002de	8b 44 24 50	 mov	 eax, DWORD PTR tv198[rsp]
  002e2	89 44 24 4c	 mov	 DWORD PTR tv199[rsp], eax
$LN87@deflate:
  002e6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002eb	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  002ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  002f3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  002f7	0f b6 44 24 4c	 movzx	 eax, BYTE PTR tv199[rsp]
  002fc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  002ff	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00304	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00307	83 c1 01	 add	 ecx, 1
  0030a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0030f	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 593  :                 put_byte(s, OS_CODE);

  00312	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00317	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0031a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0031f	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00323	c6 04 01 0b	 mov	 BYTE PTR [rcx+rax], 11
  00327	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0032c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0032f	83 c1 01	 add	 ecx, 1
  00332	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00337	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 594  :                 s->status = BUSY_STATE;

  0033a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0033f	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 595  :             }
; 596  :             else {

  00346	e9 61 03 00 00	 jmp	 $LN72@deflate
$LN73@deflate:

; 597  :                 put_byte(s, (s->gzhead->text ? 1 : 0) +
; 598  :                             (s->gzhead->hcrc ? 2 : 0) +
; 599  :                             (s->gzhead->extra == Z_NULL ? 0 : 4) +
; 600  :                             (s->gzhead->name == Z_NULL ? 0 : 8) +
; 601  :                             (s->gzhead->comment == Z_NULL ? 0 : 16)
; 602  :                         );

  0034b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00350	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00354	83 38 00	 cmp	 DWORD PTR [rax], 0
  00357	74 0a		 je	 SHORT $LN88@deflate
  00359	c7 44 24 54 01
	00 00 00	 mov	 DWORD PTR tv219[rsp], 1
  00361	eb 08		 jmp	 SHORT $LN89@deflate
$LN88@deflate:
  00363	c7 44 24 54 00
	00 00 00	 mov	 DWORD PTR tv219[rsp], 0
$LN89@deflate:
  0036b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00370	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00374	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00378	74 0a		 je	 SHORT $LN90@deflate
  0037a	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv223[rsp], 2
  00382	eb 08		 jmp	 SHORT $LN91@deflate
$LN90@deflate:
  00384	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv223[rsp], 0
$LN91@deflate:
  0038c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00391	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00395	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  0039a	75 0a		 jne	 SHORT $LN92@deflate
  0039c	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv228[rsp], 0
  003a4	eb 08		 jmp	 SHORT $LN93@deflate
$LN92@deflate:
  003a6	c7 44 24 5c 04
	00 00 00	 mov	 DWORD PTR tv228[rsp], 4
$LN93@deflate:
  003ae	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003b3	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  003b7	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  003bc	75 0a		 jne	 SHORT $LN94@deflate
  003be	c7 44 24 60 00
	00 00 00	 mov	 DWORD PTR tv233[rsp], 0
  003c6	eb 08		 jmp	 SHORT $LN95@deflate
$LN94@deflate:
  003c8	c7 44 24 60 08
	00 00 00	 mov	 DWORD PTR tv233[rsp], 8
$LN95@deflate:
  003d0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003d5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  003d9	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  003de	75 0a		 jne	 SHORT $LN96@deflate
  003e0	c7 44 24 64 00
	00 00 00	 mov	 DWORD PTR tv238[rsp], 0
  003e8	eb 08		 jmp	 SHORT $LN97@deflate
$LN96@deflate:
  003ea	c7 44 24 64 10
	00 00 00	 mov	 DWORD PTR tv238[rsp], 16
$LN97@deflate:
  003f2	8b 44 24 58	 mov	 eax, DWORD PTR tv223[rsp]
  003f6	8b 54 24 54	 mov	 edx, DWORD PTR tv219[rsp]
  003fa	03 d0		 add	 edx, eax
  003fc	03 54 24 5c	 add	 edx, DWORD PTR tv228[rsp]
  00400	03 54 24 60	 add	 edx, DWORD PTR tv233[rsp]
  00404	03 54 24 64	 add	 edx, DWORD PTR tv238[rsp]
  00408	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0040d	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00410	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00415	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00419	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0041c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00421	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00424	83 c1 01	 add	 ecx, 1
  00427	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0042c	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 603  :                 put_byte(s, (Byte)(s->gzhead->time & 0xff));

  0042f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00434	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00438	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  0043b	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00441	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00446	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00449	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0044e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00452	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00455	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0045a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0045d	83 c1 01	 add	 ecx, 1
  00460	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00465	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 604  :                 put_byte(s, (Byte)((s->gzhead->time >> 8) & 0xff));

  00468	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0046d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00471	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  00474	c1 ea 08	 shr	 edx, 8
  00477	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0047d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00482	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00485	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0048a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0048e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00491	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00496	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00499	83 c1 01	 add	 ecx, 1
  0049c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004a1	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 605  :                 put_byte(s, (Byte)((s->gzhead->time >> 16) & 0xff));

  004a4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004a9	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  004ad	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  004b0	c1 ea 10	 shr	 edx, 16
  004b3	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004be	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  004c1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004c6	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  004ca	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  004cd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004d2	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  004d5	83 c1 01	 add	 ecx, 1
  004d8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004dd	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 606  :                 put_byte(s, (Byte)((s->gzhead->time >> 24) & 0xff));

  004e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004e5	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  004e9	8b 50 04	 mov	 edx, DWORD PTR [rax+4]
  004ec	c1 ea 18	 shr	 edx, 24
  004ef	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004f5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  004fa	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  004fd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00502	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00506	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00509	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0050e	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00511	83 c1 01	 add	 ecx, 1
  00514	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00519	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 607  :                 put_byte(s, s->level == 9 ? 2 :
; 608  :                             (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2 ?
; 609  :                              4 : 0));

  0051c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00521	83 b8 ac 00 00
	00 09		 cmp	 DWORD PTR [rax+172], 9
  00528	75 0a		 jne	 SHORT $LN100@deflate
  0052a	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv302[rsp], 2
  00532	eb 36		 jmp	 SHORT $LN101@deflate
$LN100@deflate:
  00534	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00539	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00540	7d 18		 jge	 SHORT $LN98@deflate
  00542	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00547	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  0054e	7c 0a		 jl	 SHORT $LN98@deflate
  00550	c7 44 24 6c 00
	00 00 00	 mov	 DWORD PTR tv301[rsp], 0
  00558	eb 08		 jmp	 SHORT $LN99@deflate
$LN98@deflate:
  0055a	c7 44 24 6c 04
	00 00 00	 mov	 DWORD PTR tv301[rsp], 4
$LN99@deflate:
  00562	8b 44 24 6c	 mov	 eax, DWORD PTR tv301[rsp]
  00566	89 44 24 68	 mov	 DWORD PTR tv302[rsp], eax
$LN101@deflate:
  0056a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0056f	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00572	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00577	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  0057b	0f b6 44 24 68	 movzx	 eax, BYTE PTR tv302[rsp]
  00580	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00583	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00588	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0058b	83 c1 01	 add	 ecx, 1
  0058e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00593	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 610  :                 put_byte(s, s->gzhead->os & 0xff);

  00596	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0059b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0059f	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  005a2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005ad	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005b0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005b5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  005b9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  005bc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005c1	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005c4	83 c1 01	 add	 ecx, 1
  005c7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005cc	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 611  :                 if (s->gzhead->extra != NULL) {

  005cf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005d4	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  005d8	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  005dd	74 75		 je	 SHORT $LN71@deflate

; 612  :                     put_byte(s, s->gzhead->extra_len & 0xff);

  005df	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005e4	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  005e8	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  005eb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  005f1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005f6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  005f9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  005fe	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00602	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00605	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0060a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0060d	83 c1 01	 add	 ecx, 1
  00610	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00615	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 613  :                     put_byte(s, (s->gzhead->extra_len >> 8) & 0xff);

  00618	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0061d	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00621	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  00624	c1 ea 08	 shr	 edx, 8
  00627	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0062d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00632	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00635	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0063a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0063e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00641	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00646	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00649	83 c1 01	 add	 ecx, 1
  0064c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00651	89 48 28	 mov	 DWORD PTR [rax+40], ecx
$LN71@deflate:

; 614  :                 }
; 615  :                 if (s->gzhead->hcrc)

  00654	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00659	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0065d	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00661	74 31		 je	 SHORT $LN70@deflate

; 616  :                     strm->adler = crc32(strm->adler, s->pending_buf,
; 617  :                                         s->pending);

  00663	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00668	44 8b 40 28	 mov	 r8d, DWORD PTR [rax+40]
  0066c	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00671	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00675	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0067d	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00680	e8 00 00 00 00	 call	 crc32
  00685	44 8b d8	 mov	 r11d, eax
  00688	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00690	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN70@deflate:

; 618  :                 s->gzindex = 0;

  00694	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00699	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 619  :                 s->status = EXTRA_STATE;

  006a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006a5	c7 40 08 45 00
	00 00		 mov	 DWORD PTR [rax+8], 69	; 00000045H
$LN72@deflate:

; 620  :             }
; 621  :         }
; 622  :         else

  006ac	e9 36 01 00 00	 jmp	 $LN69@deflate
$LN74@deflate:

; 623  : #endif
; 624  :         {
; 625  :             uInt header = (Z_DEFLATED + ((s->w_bits-8)<<4)) << 8;

  006b1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006b6	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  006b9	83 e8 08	 sub	 eax, 8
  006bc	c1 e0 04	 shl	 eax, 4
  006bf	83 c0 08	 add	 eax, 8
  006c2	c1 e0 08	 shl	 eax, 8
  006c5	89 44 24 30	 mov	 DWORD PTR header$78369[rsp], eax

; 626  :             uInt level_flags;
; 627  : 
; 628  :             if (s->strategy >= Z_HUFFMAN_ONLY || s->level < 2)

  006c9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006ce	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  006d5	7d 0e		 jge	 SHORT $LN67@deflate
  006d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006dc	83 b8 ac 00 00
	00 02		 cmp	 DWORD PTR [rax+172], 2
  006e3	7d 0a		 jge	 SHORT $LN68@deflate
$LN67@deflate:

; 629  :                 level_flags = 0;

  006e5	c7 44 24 2c 00
	00 00 00	 mov	 DWORD PTR level_flags$78370[rsp], 0
  006ed	eb 38		 jmp	 SHORT $LN66@deflate
$LN68@deflate:

; 630  :             else if (s->level < 6)

  006ef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  006f4	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  006fb	7d 0a		 jge	 SHORT $LN65@deflate

; 631  :                 level_flags = 1;

  006fd	c7 44 24 2c 01
	00 00 00	 mov	 DWORD PTR level_flags$78370[rsp], 1
  00705	eb 20		 jmp	 SHORT $LN64@deflate
$LN65@deflate:

; 632  :             else if (s->level == 6)

  00707	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0070c	83 b8 ac 00 00
	00 06		 cmp	 DWORD PTR [rax+172], 6
  00713	75 0a		 jne	 SHORT $LN63@deflate

; 633  :                 level_flags = 2;

  00715	c7 44 24 2c 02
	00 00 00	 mov	 DWORD PTR level_flags$78370[rsp], 2

; 634  :             else

  0071d	eb 08		 jmp	 SHORT $LN62@deflate
$LN63@deflate:

; 635  :                 level_flags = 3;

  0071f	c7 44 24 2c 03
	00 00 00	 mov	 DWORD PTR level_flags$78370[rsp], 3
$LN62@deflate:
$LN64@deflate:
$LN66@deflate:

; 636  :             header |= (level_flags << 6);

  00727	8b 4c 24 2c	 mov	 ecx, DWORD PTR level_flags$78370[rsp]
  0072b	c1 e1 06	 shl	 ecx, 6
  0072e	8b 44 24 30	 mov	 eax, DWORD PTR header$78369[rsp]
  00732	0b c1		 or	 eax, ecx
  00734	89 44 24 30	 mov	 DWORD PTR header$78369[rsp], eax

; 637  :             if (s->strstart != 0) header |= PRESET_DICT;

  00738	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0073d	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00744	74 0b		 je	 SHORT $LN61@deflate
  00746	8b 44 24 30	 mov	 eax, DWORD PTR header$78369[rsp]
  0074a	83 c8 20	 or	 eax, 32			; 00000020H
  0074d	89 44 24 30	 mov	 DWORD PTR header$78369[rsp], eax
$LN61@deflate:

; 638  :             header += 31 - (header % 31);

  00751	33 d2		 xor	 edx, edx
  00753	8b 44 24 30	 mov	 eax, DWORD PTR header$78369[rsp]
  00757	b9 1f 00 00 00	 mov	 ecx, 31
  0075c	f7 f1		 div	 ecx
  0075e	b9 1f 00 00 00	 mov	 ecx, 31
  00763	2b ca		 sub	 ecx, edx
  00765	8b 44 24 30	 mov	 eax, DWORD PTR header$78369[rsp]
  00769	03 c1		 add	 eax, ecx
  0076b	89 44 24 30	 mov	 DWORD PTR header$78369[rsp], eax

; 639  : 
; 640  :             s->status = BUSY_STATE;

  0076f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00774	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H

; 641  :             putShortMSB(s, header);

  0077b	8b 54 24 30	 mov	 edx, DWORD PTR header$78369[rsp]
  0077f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00784	e8 00 00 00 00	 call	 putShortMSB

; 642  : 
; 643  :             /* Save the adler32 of the preset dictionary: */
; 644  :             if (s->strstart != 0) {

  00789	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  0078e	41 83 bb 94 00
	00 00 00	 cmp	 DWORD PTR [r11+148], 0
  00796	74 34		 je	 SHORT $LN60@deflate

; 645  :                 putShortMSB(s, (uInt)(strm->adler >> 16));

  00798	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  007a0	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  007a3	c1 ea 10	 shr	 edx, 16
  007a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  007ab	e8 00 00 00 00	 call	 putShortMSB

; 646  :                 putShortMSB(s, (uInt)(strm->adler & 0xffff));

  007b0	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  007b8	41 8b 53 4c	 mov	 edx, DWORD PTR [r11+76]
  007bc	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  007c2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  007c7	e8 00 00 00 00	 call	 putShortMSB
$LN60@deflate:

; 647  :             }
; 648  :             strm->adler = adler32(0L, Z_NULL, 0);

  007cc	45 33 c0	 xor	 r8d, r8d
  007cf	33 d2		 xor	 edx, edx
  007d1	33 c9		 xor	 ecx, ecx
  007d3	e8 00 00 00 00	 call	 adler32
  007d8	44 8b d8	 mov	 r11d, eax
  007db	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  007e3	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN69@deflate:
$LN75@deflate:

; 649  :         }
; 650  :     }
; 651  : #ifdef GZIP
; 652  :     if (s->status == EXTRA_STATE) {

  007e7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007ec	83 78 08 45	 cmp	 DWORD PTR [rax+8], 69	; 00000045H
  007f0	0f 85 cc 01 00
	00		 jne	 $LN59@deflate

; 653  :         if (s->gzhead->extra != NULL) {

  007f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  007fb	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  007ff	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00804	0f 84 ac 01 00
	00		 je	 $LN58@deflate

; 654  :             uInt beg = s->pending;  /* start of bytes to update crc */

  0080a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0080f	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00812	89 44 24 34	 mov	 DWORD PTR beg$78385[rsp], eax
$LN57@deflate:

; 655  : 
; 656  :             while (s->gzindex < (s->gzhead->extra_len & 0xffff)) {

  00816	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0081b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0081f	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00822	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  00828	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0082d	39 48 38	 cmp	 DWORD PTR [rax+56], ecx
  00830	0f 83 f7 00 00
	00		 jae	 $LN56@deflate

; 657  :                 if (s->pending == s->pending_buf_size) {

  00836	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0083b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00840	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00843	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00846	0f 85 87 00 00
	00		 jne	 $LN55@deflate

; 658  :                     if (s->gzhead->hcrc && s->pending > beg)

  0084c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00851	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00855	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00859	74 4a		 je	 SHORT $LN54@deflate
  0085b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00860	8b 44 24 34	 mov	 eax, DWORD PTR beg$78385[rsp]
  00864	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00867	76 3c		 jbe	 SHORT $LN54@deflate

; 659  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 660  :                                             s->pending - beg);

  00869	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0086e	8b 44 24 34	 mov	 eax, DWORD PTR beg$78385[rsp]
  00872	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00876	44 2b c0	 sub	 r8d, eax
  00879	8b 54 24 34	 mov	 edx, DWORD PTR beg$78385[rsp]
  0087d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00882	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00886	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0088e	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00891	e8 00 00 00 00	 call	 crc32
  00896	44 8b d8	 mov	 r11d, eax
  00899	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  008a1	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN54@deflate:

; 661  :                     flush_pending(strm);

  008a5	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  008ad	e8 00 00 00 00	 call	 flush_pending

; 662  :                     beg = s->pending;

  008b2	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  008b7	41 8b 43 28	 mov	 eax, DWORD PTR [r11+40]
  008bb	89 44 24 34	 mov	 DWORD PTR beg$78385[rsp], eax

; 663  :                     if (s->pending == s->pending_buf_size)

  008bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008c4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008c9	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  008cc	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  008cf	75 02		 jne	 SHORT $LN53@deflate

; 664  :                         break;

  008d1	eb 5a		 jmp	 SHORT $LN56@deflate
$LN53@deflate:
$LN55@deflate:

; 665  :                 }
; 666  :                 put_byte(s, s->gzhead->extra[s->gzindex]);

  008d3	4c 8b 44 24 20	 mov	 r8, QWORD PTR s$[rsp]
  008d8	4d 8b 40 30	 mov	 r8, QWORD PTR [r8+48]
  008dc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008e1	44 8b 48 38	 mov	 r9d, DWORD PTR [rax+56]
  008e5	4d 8b 40 10	 mov	 r8, QWORD PTR [r8+16]
  008e9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  008ee	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  008f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  008f6	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  008fa	43 0f b6 04 01	 movzx	 eax, BYTE PTR [r9+r8]
  008ff	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00902	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00907	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0090a	83 c1 01	 add	 ecx, 1
  0090d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00912	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 667  :                 s->gzindex++;

  00915	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0091a	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  0091d	83 c1 01	 add	 ecx, 1
  00920	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00925	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 668  :             }

  00928	e9 e9 fe ff ff	 jmp	 $LN57@deflate
$LN56@deflate:

; 669  :             if (s->gzhead->hcrc && s->pending > beg)

  0092d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00932	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00936	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  0093a	74 4a		 je	 SHORT $LN52@deflate
  0093c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00941	8b 44 24 34	 mov	 eax, DWORD PTR beg$78385[rsp]
  00945	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00948	76 3c		 jbe	 SHORT $LN52@deflate

; 670  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 671  :                                     s->pending - beg);

  0094a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0094f	8b 44 24 34	 mov	 eax, DWORD PTR beg$78385[rsp]
  00953	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00957	44 2b c0	 sub	 r8d, eax
  0095a	8b 54 24 34	 mov	 edx, DWORD PTR beg$78385[rsp]
  0095e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00963	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00967	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0096f	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00972	e8 00 00 00 00	 call	 crc32
  00977	44 8b d8	 mov	 r11d, eax
  0097a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00982	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN52@deflate:

; 672  :             if (s->gzindex == s->gzhead->extra_len) {

  00986	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0098b	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  0098f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00994	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00997	39 41 38	 cmp	 DWORD PTR [rcx+56], eax
  0099a	75 18		 jne	 SHORT $LN51@deflate

; 673  :                 s->gzindex = 0;

  0099c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009a1	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 674  :                 s->status = NAME_STATE;

  009a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009ad	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN51@deflate:

; 675  :             }
; 676  :         }
; 677  :         else

  009b4	eb 0c		 jmp	 SHORT $LN50@deflate
$LN58@deflate:

; 678  :             s->status = NAME_STATE;

  009b6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009bb	c7 40 08 49 00
	00 00		 mov	 DWORD PTR [rax+8], 73	; 00000049H
$LN50@deflate:
$LN59@deflate:

; 679  :     }
; 680  :     if (s->status == NAME_STATE) {

  009c2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009c7	83 78 08 49	 cmp	 DWORD PTR [rax+8], 73	; 00000049H
  009cb	0f 85 b2 01 00
	00		 jne	 $LN49@deflate

; 681  :         if (s->gzhead->name != NULL) {

  009d1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009d6	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  009da	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  009df	0f 84 92 01 00
	00		 je	 $LN48@deflate

; 682  :             uInt beg = s->pending;  /* start of bytes to update crc */

  009e5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009ea	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  009ed	89 44 24 38	 mov	 DWORD PTR beg$78398[rsp], eax
$LN47@deflate:

; 683  :             int val;
; 684  : 
; 685  :             do {
; 686  :                 if (s->pending == s->pending_buf_size) {

  009f1	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  009f6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  009fb	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  009fe	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00a01	0f 85 8f 00 00
	00		 jne	 $LN44@deflate

; 687  :                     if (s->gzhead->hcrc && s->pending > beg)

  00a07	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a0c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00a10	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00a14	74 4a		 je	 SHORT $LN43@deflate
  00a16	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a1b	8b 44 24 38	 mov	 eax, DWORD PTR beg$78398[rsp]
  00a1f	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00a22	76 3c		 jbe	 SHORT $LN43@deflate

; 688  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 689  :                                             s->pending - beg);

  00a24	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a29	8b 44 24 38	 mov	 eax, DWORD PTR beg$78398[rsp]
  00a2d	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00a31	44 2b c0	 sub	 r8d, eax
  00a34	8b 54 24 38	 mov	 edx, DWORD PTR beg$78398[rsp]
  00a38	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a3d	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00a41	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00a49	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00a4c	e8 00 00 00 00	 call	 crc32
  00a51	44 8b d8	 mov	 r11d, eax
  00a54	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00a5c	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN43@deflate:

; 690  :                     flush_pending(strm);

  00a60	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00a68	e8 00 00 00 00	 call	 flush_pending

; 691  :                     beg = s->pending;

  00a6d	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  00a72	41 8b 43 28	 mov	 eax, DWORD PTR [r11+40]
  00a76	89 44 24 38	 mov	 DWORD PTR beg$78398[rsp], eax

; 692  :                     if (s->pending == s->pending_buf_size) {

  00a7a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00a7f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00a84	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00a87	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00a8a	75 0a		 jne	 SHORT $LN42@deflate

; 693  :                         val = 1;

  00a8c	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR val$78399[rsp], 1

; 694  :                         break;

  00a94	eb 67		 jmp	 SHORT $LN45@deflate
$LN42@deflate:
$LN44@deflate:

; 695  :                     }
; 696  :                 }
; 697  :                 val = s->gzhead->name[s->gzindex++];

  00a96	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00a9b	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00a9f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00aa4	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00aa7	48 8b 42 20	 mov	 rax, QWORD PTR [rdx+32]
  00aab	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00aaf	89 44 24 3c	 mov	 DWORD PTR val$78399[rsp], eax
  00ab3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ab8	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00abb	83 c1 01	 add	 ecx, 1
  00abe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ac3	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 698  :                 put_byte(s, val);

  00ac6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00acb	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00ace	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ad3	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00ad7	0f b6 44 24 3c	 movzx	 eax, BYTE PTR val$78399[rsp]
  00adc	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00adf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ae4	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00ae7	83 c1 01	 add	 ecx, 1
  00aea	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00aef	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 699  :             } while (val != 0);

  00af2	83 7c 24 3c 00	 cmp	 DWORD PTR val$78399[rsp], 0
  00af7	0f 85 f4 fe ff
	ff		 jne	 $LN47@deflate
$LN45@deflate:

; 700  :             if (s->gzhead->hcrc && s->pending > beg)

  00afd	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b02	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00b06	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00b0a	74 4a		 je	 SHORT $LN41@deflate
  00b0c	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00b11	8b 44 24 38	 mov	 eax, DWORD PTR beg$78398[rsp]
  00b15	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00b18	76 3c		 jbe	 SHORT $LN41@deflate

; 701  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 702  :                                     s->pending - beg);

  00b1a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00b1f	8b 44 24 38	 mov	 eax, DWORD PTR beg$78398[rsp]
  00b23	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00b27	44 2b c0	 sub	 r8d, eax
  00b2a	8b 54 24 38	 mov	 edx, DWORD PTR beg$78398[rsp]
  00b2e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b33	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00b37	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00b3f	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00b42	e8 00 00 00 00	 call	 crc32
  00b47	44 8b d8	 mov	 r11d, eax
  00b4a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00b52	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN41@deflate:

; 703  :             if (val == 0) {

  00b56	83 7c 24 3c 00	 cmp	 DWORD PTR val$78399[rsp], 0
  00b5b	75 18		 jne	 SHORT $LN40@deflate

; 704  :                 s->gzindex = 0;

  00b5d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b62	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [rax+56], 0

; 705  :                 s->status = COMMENT_STATE;

  00b69	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b6e	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN40@deflate:

; 706  :             }
; 707  :         }
; 708  :         else

  00b75	eb 0c		 jmp	 SHORT $LN39@deflate
$LN48@deflate:

; 709  :             s->status = COMMENT_STATE;

  00b77	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b7c	c7 40 08 5b 00
	00 00		 mov	 DWORD PTR [rax+8], 91	; 0000005bH
$LN39@deflate:
$LN49@deflate:

; 710  :     }
; 711  :     if (s->status == COMMENT_STATE) {

  00b83	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b88	83 78 08 5b	 cmp	 DWORD PTR [rax+8], 91	; 0000005bH
  00b8c	0f 85 a6 01 00
	00		 jne	 $LN38@deflate

; 712  :         if (s->gzhead->comment != NULL) {

  00b92	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00b97	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00b9b	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00ba0	0f 84 86 01 00
	00		 je	 $LN37@deflate

; 713  :             uInt beg = s->pending;  /* start of bytes to update crc */

  00ba6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bab	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00bae	89 44 24 40	 mov	 DWORD PTR beg$78412[rsp], eax
$LN36@deflate:

; 714  :             int val;
; 715  : 
; 716  :             do {
; 717  :                 if (s->pending == s->pending_buf_size) {

  00bb2	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00bb7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bbc	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00bbf	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00bc2	0f 85 8f 00 00
	00		 jne	 $LN33@deflate

; 718  :                     if (s->gzhead->hcrc && s->pending > beg)

  00bc8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bcd	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00bd1	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00bd5	74 4a		 je	 SHORT $LN32@deflate
  00bd7	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00bdc	8b 44 24 40	 mov	 eax, DWORD PTR beg$78412[rsp]
  00be0	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00be3	76 3c		 jbe	 SHORT $LN32@deflate

; 719  :                         strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 720  :                                             s->pending - beg);

  00be5	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00bea	8b 44 24 40	 mov	 eax, DWORD PTR beg$78412[rsp]
  00bee	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00bf2	44 2b c0	 sub	 r8d, eax
  00bf5	8b 54 24 40	 mov	 edx, DWORD PTR beg$78412[rsp]
  00bf9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00bfe	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00c02	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00c0a	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00c0d	e8 00 00 00 00	 call	 crc32
  00c12	44 8b d8	 mov	 r11d, eax
  00c15	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00c1d	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN32@deflate:

; 721  :                     flush_pending(strm);

  00c21	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c29	e8 00 00 00 00	 call	 flush_pending

; 722  :                     beg = s->pending;

  00c2e	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  00c33	41 8b 43 28	 mov	 eax, DWORD PTR [r11+40]
  00c37	89 44 24 40	 mov	 DWORD PTR beg$78412[rsp], eax

; 723  :                     if (s->pending == s->pending_buf_size) {

  00c3b	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c40	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c45	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00c48	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00c4b	75 0a		 jne	 SHORT $LN31@deflate

; 724  :                         val = 1;

  00c4d	c7 44 24 44 01
	00 00 00	 mov	 DWORD PTR val$78413[rsp], 1

; 725  :                         break;

  00c55	eb 67		 jmp	 SHORT $LN34@deflate
$LN31@deflate:
$LN33@deflate:

; 726  :                     }
; 727  :                 }
; 728  :                 val = s->gzhead->comment[s->gzindex++];

  00c57	48 8b 54 24 20	 mov	 rdx, QWORD PTR s$[rsp]
  00c5c	48 8b 52 30	 mov	 rdx, QWORD PTR [rdx+48]
  00c60	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c65	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00c68	48 8b 42 30	 mov	 rax, QWORD PTR [rdx+48]
  00c6c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c70	89 44 24 44	 mov	 DWORD PTR val$78413[rsp], eax
  00c74	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c79	8b 48 38	 mov	 ecx, DWORD PTR [rax+56]
  00c7c	83 c1 01	 add	 ecx, 1
  00c7f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c84	89 48 38	 mov	 DWORD PTR [rax+56], ecx

; 729  :                 put_byte(s, val);

  00c87	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00c8c	8b 50 28	 mov	 edx, DWORD PTR [rax+40]
  00c8f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00c94	48 8b 49 10	 mov	 rcx, QWORD PTR [rcx+16]
  00c98	0f b6 44 24 44	 movzx	 eax, BYTE PTR val$78413[rsp]
  00c9d	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ca0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ca5	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00ca8	83 c1 01	 add	 ecx, 1
  00cab	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cb0	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 730  :             } while (val != 0);

  00cb3	83 7c 24 44 00	 cmp	 DWORD PTR val$78413[rsp], 0
  00cb8	0f 85 f4 fe ff
	ff		 jne	 $LN36@deflate
$LN34@deflate:

; 731  :             if (s->gzhead->hcrc && s->pending > beg)

  00cbe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cc3	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00cc7	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00ccb	74 4a		 je	 SHORT $LN30@deflate
  00ccd	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00cd2	8b 44 24 40	 mov	 eax, DWORD PTR beg$78412[rsp]
  00cd6	39 41 28	 cmp	 DWORD PTR [rcx+40], eax
  00cd9	76 3c		 jbe	 SHORT $LN30@deflate

; 732  :                 strm->adler = crc32(strm->adler, s->pending_buf + beg,
; 733  :                                     s->pending - beg);

  00cdb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ce0	8b 44 24 40	 mov	 eax, DWORD PTR beg$78412[rsp]
  00ce4	44 8b 41 28	 mov	 r8d, DWORD PTR [rcx+40]
  00ce8	44 2b c0	 sub	 r8d, eax
  00ceb	8b 54 24 40	 mov	 edx, DWORD PTR beg$78412[rsp]
  00cef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00cf4	48 03 50 10	 add	 rdx, QWORD PTR [rax+16]
  00cf8	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d00	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00d03	e8 00 00 00 00	 call	 crc32
  00d08	44 8b d8	 mov	 r11d, eax
  00d0b	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d13	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN30@deflate:

; 734  :             if (val == 0)

  00d17	83 7c 24 44 00	 cmp	 DWORD PTR val$78413[rsp], 0
  00d1c	75 0c		 jne	 SHORT $LN29@deflate

; 735  :                 s->status = HCRC_STATE;

  00d1e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d23	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN29@deflate:

; 736  :         }
; 737  :         else

  00d2a	eb 0c		 jmp	 SHORT $LN28@deflate
$LN37@deflate:

; 738  :             s->status = HCRC_STATE;

  00d2c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d31	c7 40 08 67 00
	00 00		 mov	 DWORD PTR [rax+8], 103	; 00000067H
$LN28@deflate:
$LN38@deflate:

; 739  :     }
; 740  :     if (s->status == HCRC_STATE) {

  00d38	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d3d	83 78 08 67	 cmp	 DWORD PTR [rax+8], 103	; 00000067H
  00d41	0f 85 f6 00 00
	00		 jne	 $LN27@deflate

; 741  :         if (s->gzhead->hcrc) {

  00d47	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d4c	48 8b 40 30	 mov	 rax, QWORD PTR [rax+48]
  00d50	83 78 3c 00	 cmp	 DWORD PTR [rax+60], 0
  00d54	0f 84 d7 00 00
	00		 je	 $LN26@deflate

; 742  :             if (s->pending + 2 > s->pending_buf_size)

  00d5a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d5f	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00d62	83 c1 02	 add	 ecx, 2
  00d65	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d6a	3b 48 18	 cmp	 ecx, DWORD PTR [rax+24]
  00d6d	76 0d		 jbe	 SHORT $LN25@deflate

; 743  :                 flush_pending(strm);

  00d6f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00d77	e8 00 00 00 00	 call	 flush_pending
$LN25@deflate:

; 744  :             if (s->pending + 2 <= s->pending_buf_size) {

  00d7c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d81	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00d84	83 c1 02	 add	 ecx, 2
  00d87	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00d8c	3b 48 18	 cmp	 ecx, DWORD PTR [rax+24]
  00d8f	0f 87 9a 00 00
	00		 ja	 $LN24@deflate

; 745  :                 put_byte(s, (Byte)(strm->adler & 0xff));

  00d95	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00d9d	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  00da0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00da6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dab	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00dae	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00db3	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00db7	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00dba	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dbf	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00dc2	83 c1 01	 add	 ecx, 1
  00dc5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dca	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 746  :                 put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  00dcd	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00dd5	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  00dd8	c1 ea 08	 shr	 edx, 8
  00ddb	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00de1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00de6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00de9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dee	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00df2	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  00df5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00dfa	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00dfd	83 c1 01	 add	 ecx, 1
  00e00	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e05	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 747  :                 strm->adler = crc32(0L, Z_NULL, 0);

  00e08	45 33 c0	 xor	 r8d, r8d
  00e0b	33 d2		 xor	 edx, edx
  00e0d	33 c9		 xor	 ecx, ecx
  00e0f	e8 00 00 00 00	 call	 crc32
  00e14	44 8b d8	 mov	 r11d, eax
  00e17	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e1f	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d

; 748  :                 s->status = BUSY_STATE;

  00e23	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e28	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H
$LN24@deflate:

; 749  :             }
; 750  :         }
; 751  :         else

  00e2f	eb 0c		 jmp	 SHORT $LN23@deflate
$LN26@deflate:

; 752  :             s->status = BUSY_STATE;

  00e31	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e36	c7 40 08 71 00
	00 00		 mov	 DWORD PTR [rax+8], 113	; 00000071H
$LN23@deflate:
$LN27@deflate:

; 753  :     }
; 754  : #endif
; 755  : 
; 756  :     /* Flush as much pending output as possible */
; 757  :     if (s->pending != 0) {

  00e3d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e42	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  00e46	74 31		 je	 SHORT $LN22@deflate

; 758  :         flush_pending(strm);

  00e48	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e50	e8 00 00 00 00	 call	 flush_pending

; 759  :         if (strm->avail_out == 0) {

  00e55	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  00e5d	41 83 7b 18 00	 cmp	 DWORD PTR [r11+24], 0
  00e62	75 13		 jne	 SHORT $LN21@deflate

; 760  :             /* Since avail_out is 0, deflate will be called again with
; 761  :              * more output space, but possibly with both pending and
; 762  :              * avail_in equal to zero. There won't be anything to do,
; 763  :              * but this is not an error situation so make sure we
; 764  :              * return OK instead of BUF_ERROR at next call of deflate:
; 765  :              */
; 766  :             s->last_flush = -1;

  00e64	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00e69	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 767  :             return Z_OK;

  00e70	33 c0		 xor	 eax, eax
  00e72	e9 60 04 00 00	 jmp	 $LN82@deflate
$LN21@deflate:

; 768  :         }
; 769  : 
; 770  :     /* Make sure there is something to do and avoid duplicate consecutive
; 771  :      * flushes. For repeated and useless calls with Z_FINISH, we keep
; 772  :      * returning Z_STREAM_END instead of Z_BUF_ERROR.
; 773  :      */
; 774  :     } else if (strm->avail_in == 0 && flush <= old_flush &&

  00e77	eb 42		 jmp	 SHORT $LN20@deflate
$LN22@deflate:

; 775  :                flush != Z_FINISH) {

  00e79	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00e81	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00e85	75 34		 jne	 SHORT $LN19@deflate
  00e87	8b 44 24 28	 mov	 eax, DWORD PTR old_flush$[rsp]
  00e8b	39 84 24 98 00
	00 00		 cmp	 DWORD PTR flush$[rsp], eax
  00e92	7f 27		 jg	 SHORT $LN19@deflate
  00e94	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00e9c	74 1d		 je	 SHORT $LN19@deflate

; 776  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00e9e	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00ea6	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00ead	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00eb1	b8 fb ff ff ff	 mov	 eax, -5
  00eb6	e9 1c 04 00 00	 jmp	 $LN82@deflate
$LN19@deflate:
$LN20@deflate:

; 777  :     }
; 778  : 
; 779  :     /* User must not provide more input after the first FINISH: */
; 780  :     if (s->status == FINISH_STATE && strm->avail_in != 0) {

  00ebb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00ec0	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00ec7	75 2b		 jne	 SHORT $LN18@deflate
  00ec9	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00ed1	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00ed5	74 1d		 je	 SHORT $LN18@deflate

; 781  :         ERR_RETURN(strm, Z_BUF_ERROR);

  00ed7	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00edf	48 8b 05 38 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+56
  00ee6	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax
  00eea	b8 fb ff ff ff	 mov	 eax, -5
  00eef	e9 e3 03 00 00	 jmp	 $LN82@deflate
$LN18@deflate:

; 782  :     }
; 783  : 
; 784  :     /* Start a new block or continue the current one.
; 785  :      */
; 786  :     if (strm->avail_in != 0 || s->lookahead != 0 ||
; 787  :         (flush != Z_NO_FLUSH && s->status != FINISH_STATE)) {

  00ef4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00efc	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00f00	75 2e		 jne	 SHORT $LN16@deflate
  00f02	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f07	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00f0e	75 20		 jne	 SHORT $LN16@deflate
  00f10	83 bc 24 98 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00f18	0f 84 30 01 00
	00		 je	 $LN17@deflate
  00f1e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f23	81 78 08 9a 02
	00 00		 cmp	 DWORD PTR [rax+8], 666	; 0000029aH
  00f2a	0f 84 1e 01 00
	00		 je	 $LN17@deflate
$LN16@deflate:

; 788  :         block_state bstate;
; 789  : 
; 790  :         bstate = (*(configuration_table[s->level].func))(s, flush);

  00f30	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f35	4c 63 80 ac 00
	00 00		 movsxd	 r8, DWORD PTR [rax+172]
  00f3c	4d 6b c0 10	 imul	 r8, 16
  00f40	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00f47	8b 94 24 98 00
	00 00		 mov	 edx, DWORD PTR flush$[rsp]
  00f4e	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00f53	42 ff 54 00 08	 call	 QWORD PTR [rax+r8+8]
  00f58	89 44 24 48	 mov	 DWORD PTR bstate$78439[rsp], eax

; 791  : 
; 792  :         if (bstate == finish_started || bstate == finish_done) {

  00f5c	83 7c 24 48 02	 cmp	 DWORD PTR bstate$78439[rsp], 2
  00f61	74 07		 je	 SHORT $LN14@deflate
  00f63	83 7c 24 48 03	 cmp	 DWORD PTR bstate$78439[rsp], 3
  00f68	75 0c		 jne	 SHORT $LN15@deflate
$LN14@deflate:

; 793  :             s->status = FINISH_STATE;

  00f6a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f6f	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH
$LN15@deflate:

; 794  :         }
; 795  :         if (bstate == need_more || bstate == finish_started) {

  00f76	83 7c 24 48 00	 cmp	 DWORD PTR bstate$78439[rsp], 0
  00f7b	74 07		 je	 SHORT $LN12@deflate
  00f7d	83 7c 24 48 02	 cmp	 DWORD PTR bstate$78439[rsp], 2
  00f82	75 21		 jne	 SHORT $LN13@deflate
$LN12@deflate:

; 796  :             if (strm->avail_out == 0) {

  00f84	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00f8c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00f90	75 0c		 jne	 SHORT $LN11@deflate

; 797  :                 s->last_flush = -1; /* avoid BUF_ERROR next call, see above */

  00f92	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00f97	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN11@deflate:

; 798  :             }
; 799  :             return Z_OK;

  00f9e	33 c0		 xor	 eax, eax
  00fa0	e9 32 03 00 00	 jmp	 $LN82@deflate
$LN13@deflate:

; 800  :             /* If flush != Z_NO_FLUSH && avail_out == 0, the next call
; 801  :              * of deflate should use the same flush parameter to make sure
; 802  :              * that the flush is complete. So we don't have to output an
; 803  :              * empty block here, this will be done at next call. This also
; 804  :              * ensures that for a very small output buffer, we emit at most
; 805  :              * one empty block.
; 806  :              */
; 807  :         }
; 808  :         if (bstate == block_done) {

  00fa5	83 7c 24 48 01	 cmp	 DWORD PTR bstate$78439[rsp], 1
  00faa	0f 85 9e 00 00
	00		 jne	 $LN10@deflate

; 809  :             if (flush == Z_PARTIAL_FLUSH) {

  00fb0	83 bc 24 98 00
	00 00 01	 cmp	 DWORD PTR flush$[rsp], 1
  00fb8	75 0c		 jne	 SHORT $LN9@deflate

; 810  :                 _tr_align(s);

  00fba	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00fbf	e8 00 00 00 00	 call	 _tr_align

; 811  :             } else { /* FULL_FLUSH or SYNC_FLUSH */

  00fc4	eb 59		 jmp	 SHORT $LN8@deflate
$LN9@deflate:

; 812  :                 _tr_stored_block(s, (char*)0, 0L, 0);

  00fc6	45 33 c9	 xor	 r9d, r9d
  00fc9	45 33 c0	 xor	 r8d, r8d
  00fcc	33 d2		 xor	 edx, edx
  00fce	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00fd3	e8 00 00 00 00	 call	 _tr_stored_block

; 813  :                 /* For a full flush, this empty block will be recognized
; 814  :                  * as a special marker by inflate_sync().
; 815  :                  */
; 816  :                 if (flush == Z_FULL_FLUSH) {

  00fd8	83 bc 24 98 00
	00 00 03	 cmp	 DWORD PTR flush$[rsp], 3
  00fe0	75 3d		 jne	 SHORT $LN7@deflate

; 817  :                     CLEAR_HASH(s);             /* forget history */

  00fe2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00fe7	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00fea	83 e8 01	 sub	 eax, 1
  00fed	8b d0		 mov	 edx, eax
  00fef	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00ff4	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00ff8	33 c0		 xor	 eax, eax
  00ffa	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00ffe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01003	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01006	83 e8 01	 sub	 eax, 1
  01009	44 8b c0	 mov	 r8d, eax
  0100c	49 d1 e0	 shl	 r8, 1
  0100f	33 d2		 xor	 edx, edx
  01011	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01016	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0101a	e8 00 00 00 00	 call	 memset
$LN7@deflate:
$LN8@deflate:

; 818  :                 }
; 819  :             }
; 820  :             flush_pending(strm);

  0101f	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01027	e8 00 00 00 00	 call	 flush_pending

; 821  :             if (strm->avail_out == 0) {

  0102c	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  01034	41 83 7b 18 00	 cmp	 DWORD PTR [r11+24], 0
  01039	75 13		 jne	 SHORT $LN6@deflate

; 822  :               s->last_flush = -1; /* avoid BUF_ERROR at next call, see above */

  0103b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01040	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1

; 823  :               return Z_OK;

  01047	33 c0		 xor	 eax, eax
  01049	e9 89 02 00 00	 jmp	 $LN82@deflate
$LN6@deflate:
$LN10@deflate:
$LN17@deflate:

; 824  :             }
; 825  :         }
; 826  :     }
; 827  :     Assert(strm->avail_out > 0, "bug2");
; 828  : 
; 829  :     if (flush != Z_FINISH) return Z_OK;

  0104e	83 bc 24 98 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  01056	74 07		 je	 SHORT $LN5@deflate
  01058	33 c0		 xor	 eax, eax
  0105a	e9 78 02 00 00	 jmp	 $LN82@deflate
$LN5@deflate:

; 830  :     if (s->wrap <= 0) return Z_STREAM_END;

  0105f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01064	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  01068	7f 0a		 jg	 SHORT $LN4@deflate
  0106a	b8 01 00 00 00	 mov	 eax, 1
  0106f	e9 63 02 00 00	 jmp	 $LN82@deflate
$LN4@deflate:

; 831  : 
; 832  :     /* Write the trailer */
; 833  : #ifdef GZIP
; 834  :     if (s->wrap == 2) {

  01074	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01079	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0107d	0f 85 d4 01 00
	00		 jne	 $LN3@deflate

; 835  :         put_byte(s, (Byte)(strm->adler & 0xff));

  01083	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0108b	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  0108e	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01094	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01099	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0109c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010a1	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  010a5	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  010a8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010ad	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  010b0	83 c1 01	 add	 ecx, 1
  010b3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010b8	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 836  :         put_byte(s, (Byte)((strm->adler >> 8) & 0xff));

  010bb	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010c3	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  010c6	c1 ea 08	 shr	 edx, 8
  010c9	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  010cf	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010d4	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  010d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010dc	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  010e0	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  010e3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010e8	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  010eb	83 c1 01	 add	 ecx, 1
  010ee	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  010f3	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 837  :         put_byte(s, (Byte)((strm->adler >> 16) & 0xff));

  010f6	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  010fe	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  01101	c1 ea 10	 shr	 edx, 16
  01104	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0110a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0110f	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01112	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01117	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0111b	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  0111e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01123	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01126	83 c1 01	 add	 ecx, 1
  01129	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0112e	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 838  :         put_byte(s, (Byte)((strm->adler >> 24) & 0xff));

  01131	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01139	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  0113c	c1 ea 18	 shr	 edx, 24
  0113f	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  01145	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0114a	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0114d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01152	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01156	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01159	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0115e	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01161	83 c1 01	 add	 ecx, 1
  01164	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01169	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 839  :         put_byte(s, (Byte)(strm->total_in & 0xff));

  0116c	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01174	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  01177	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0117d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01182	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01185	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0118a	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0118e	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01191	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01196	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01199	83 c1 01	 add	 ecx, 1
  0119c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011a1	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 840  :         put_byte(s, (Byte)((strm->total_in >> 8) & 0xff));

  011a4	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011ac	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  011af	c1 ea 08	 shr	 edx, 8
  011b2	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  011b8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011bd	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011c0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011c5	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  011c9	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  011cc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011d1	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011d4	83 c1 01	 add	 ecx, 1
  011d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011dc	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 841  :         put_byte(s, (Byte)((strm->total_in >> 16) & 0xff));

  011df	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  011e7	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  011ea	c1 ea 10	 shr	 edx, 16
  011ed	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  011f3	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  011f8	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  011fb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01200	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01204	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01207	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0120c	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0120f	83 c1 01	 add	 ecx, 1
  01212	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01217	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 842  :         put_byte(s, (Byte)((strm->total_in >> 24) & 0xff));

  0121a	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01222	8b 50 0c	 mov	 edx, DWORD PTR [rax+12]
  01225	c1 ea 18	 shr	 edx, 24
  01228	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  0122e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01233	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  01236	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0123b	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0123f	88 14 01	 mov	 BYTE PTR [rcx+rax], dl
  01242	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01247	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  0124a	83 c1 01	 add	 ecx, 1
  0124d	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  01252	89 48 28	 mov	 DWORD PTR [rax+40], ecx

; 843  :     }
; 844  :     else

  01255	eb 34		 jmp	 SHORT $LN2@deflate
$LN3@deflate:

; 845  : #endif
; 846  :     {
; 847  :         putShortMSB(s, (uInt)(strm->adler >> 16));

  01257	48 8b 84 24 90
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0125f	8b 50 4c	 mov	 edx, DWORD PTR [rax+76]
  01262	c1 ea 10	 shr	 edx, 16
  01265	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0126a	e8 00 00 00 00	 call	 putShortMSB

; 848  :         putShortMSB(s, (uInt)(strm->adler & 0xffff));

  0126f	4c 8b 9c 24 90
	00 00 00	 mov	 r11, QWORD PTR strm$[rsp]
  01277	41 8b 53 4c	 mov	 edx, DWORD PTR [r11+76]
  0127b	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  01281	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  01286	e8 00 00 00 00	 call	 putShortMSB
$LN2@deflate:

; 849  :     }
; 850  :     flush_pending(strm);

  0128b	48 8b 8c 24 90
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01293	e8 00 00 00 00	 call	 flush_pending

; 851  :     /* If avail_out is zero, the application will call deflate again
; 852  :      * to flush the rest.
; 853  :      */
; 854  :     if (s->wrap > 0) s->wrap = -s->wrap; /* write the trailer only once! */

  01298	4c 8b 5c 24 20	 mov	 r11, QWORD PTR s$[rsp]
  0129d	41 83 7b 2c 00	 cmp	 DWORD PTR [r11+44], 0
  012a2	7e 12		 jle	 SHORT $LN1@deflate
  012a4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012a9	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  012ac	f7 d9		 neg	 ecx
  012ae	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012b3	89 48 2c	 mov	 DWORD PTR [rax+44], ecx
$LN1@deflate:

; 855  :     return s->pending != 0 ? Z_OK : Z_STREAM_END;

  012b6	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  012bb	83 78 28 00	 cmp	 DWORD PTR [rax+40], 0
  012bf	74 0a		 je	 SHORT $LN102@deflate
  012c1	c7 44 24 70 00
	00 00 00	 mov	 DWORD PTR tv816[rsp], 0
  012c9	eb 08		 jmp	 SHORT $LN103@deflate
$LN102@deflate:
  012cb	c7 44 24 70 01
	00 00 00	 mov	 DWORD PTR tv816[rsp], 1
$LN103@deflate:
  012d3	8b 44 24 70	 mov	 eax, DWORD PTR tv816[rsp]
$LN82@deflate:

; 856  : }

  012d7	48 81 c4 88 00
	00 00		 add	 rsp, 136		; 00000088H
  012de	c3		 ret	 0
deflate	ENDP
_TEXT	ENDS
PUBLIC	deflateBound
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateBound DD imagerel $LN7
	DD	imagerel $LN7+129
	DD	imagerel $unwind$deflateBound
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateBound DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateBound
_TEXT	SEGMENT
destLen$ = 32
s$ = 40
strm$ = 64
sourceLen$ = 72
deflateBound PROC					; COMDAT

; 492  : {

$LN7:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 493  :     deflate_state *s;
; 494  :     uLong destLen;
; 495  : 
; 496  :     /* conservative upper bound */
; 497  :     destLen = sourceLen +
; 498  :               ((sourceLen + 7) >> 3) + ((sourceLen + 63) >> 6) + 11;

  0000d	8b 44 24 48	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00011	83 c0 07	 add	 eax, 7
  00014	c1 e8 03	 shr	 eax, 3
  00017	8b 4c 24 48	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  0001b	03 c8		 add	 ecx, eax
  0001d	8b 44 24 48	 mov	 eax, DWORD PTR sourceLen$[rsp]
  00021	83 c0 3f	 add	 eax, 63			; 0000003fH
  00024	c1 e8 06	 shr	 eax, 6
  00027	8d 44 01 0b	 lea	 eax, DWORD PTR [rcx+rax+11]
  0002b	89 44 24 20	 mov	 DWORD PTR destLen$[rsp], eax

; 499  : 
; 500  :     /* if can't get parameters, return conservative bound */
; 501  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0002f	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00035	74 0c		 je	 SHORT $LN3@deflateBou
  00037	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0003c	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00041	75 06		 jne	 SHORT $LN4@deflateBou
$LN3@deflateBou:

; 502  :         return destLen;

  00043	8b 44 24 20	 mov	 eax, DWORD PTR destLen$[rsp]
  00047	eb 33		 jmp	 SHORT $LN5@deflateBou
$LN4@deflateBou:

; 503  : 
; 504  :     /* if not default parameters, return conservative bound */
; 505  :     s = strm->state;

  00049	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0004e	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00052	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 506  :     if (s->w_bits != 15 || s->hash_bits != 8 + 7)

  00057	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0005c	83 78 48 0f	 cmp	 DWORD PTR [rax+72], 15
  00060	75 0b		 jne	 SHORT $LN1@deflateBou
  00062	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00067	83 78 78 0f	 cmp	 DWORD PTR [rax+120], 15
  0006b	74 06		 je	 SHORT $LN2@deflateBou
$LN1@deflateBou:

; 507  :         return destLen;

  0006d	8b 44 24 20	 mov	 eax, DWORD PTR destLen$[rsp]
  00071	eb 09		 jmp	 SHORT $LN5@deflateBou
$LN2@deflateBou:

; 508  : 
; 509  :     /* default settings: return tight bound for that case */
; 510  :     return compressBound(sourceLen);

  00073	8b 4c 24 48	 mov	 ecx, DWORD PTR sourceLen$[rsp]
  00077	e8 00 00 00 00	 call	 compressBound
$LN5@deflateBou:

; 511  : }

  0007c	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00080	c3		 ret	 0
deflateBound ENDP
_TEXT	ENDS
PUBLIC	deflateParams
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateParams DD imagerel $LN10
	DD	imagerel $LN10+401
	DD	imagerel $unwind$deflateParams
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateParams DD 011201H
	DD	08212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateParams
_TEXT	SEGMENT
s$ = 32
err$ = 40
func$ = 48
strm$ = 80
level$ = 88
strategy$ = 96
deflateParams PROC					; COMDAT

; 420  : {

$LN10:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00009	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000e	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 421  :     deflate_state *s;
; 422  :     compress_func func;
; 423  :     int err = Z_OK;

  00012	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR err$[rsp], 0

; 424  : 
; 425  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  0001a	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00020	74 0c		 je	 SHORT $LN6@deflatePar
  00022	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00027	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0002c	75 0a		 jne	 SHORT $LN7@deflatePar
$LN6@deflatePar:
  0002e	b8 fe ff ff ff	 mov	 eax, -2
  00033	e9 54 01 00 00	 jmp	 $LN8@deflatePar
$LN7@deflatePar:

; 426  :     s = strm->state;

  00038	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0003d	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00041	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 427  : 
; 428  : #ifdef FASTEST
; 429  :     if (level != 0) level = 1;
; 430  : #else
; 431  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  00046	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  0004b	75 08		 jne	 SHORT $LN5@deflatePar
  0004d	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN5@deflatePar:

; 432  : #endif
; 433  :     if (level < 0 || level > 9 || strategy < 0 || strategy > Z_FIXED) {

  00055	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  0005a	7c 15		 jl	 SHORT $LN3@deflatePar
  0005c	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  00061	7f 0e		 jg	 SHORT $LN3@deflatePar
  00063	83 7c 24 60 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00068	7c 07		 jl	 SHORT $LN3@deflatePar
  0006a	83 7c 24 60 04	 cmp	 DWORD PTR strategy$[rsp], 4
  0006f	7e 0a		 jle	 SHORT $LN4@deflatePar
$LN3@deflatePar:

; 434  :         return Z_STREAM_ERROR;

  00071	b8 fe ff ff ff	 mov	 eax, -2
  00076	e9 11 01 00 00	 jmp	 $LN8@deflatePar
$LN4@deflatePar:

; 435  :     }
; 436  :     func = configuration_table[s->level].func;

  0007b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00080	48 63 88 ac 00
	00 00		 movsxd	 rcx, DWORD PTR [rax+172]
  00087	48 6b c9 10	 imul	 rcx, 16
  0008b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00092	48 8b 44 08 08	 mov	 rax, QWORD PTR [rax+rcx+8]
  00097	48 89 44 24 30	 mov	 QWORD PTR func$[rsp], rax

; 437  : 
; 438  :     if (func != configuration_table[level].func && strm->total_in != 0) {

  0009c	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  000a1	48 6b c9 10	 imul	 rcx, 16
  000a5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  000ac	48 8b 44 08 08	 mov	 rax, QWORD PTR [rax+rcx+8]
  000b1	48 39 44 24 30	 cmp	 QWORD PTR func$[rsp], rax
  000b6	74 1e		 je	 SHORT $LN2@deflatePar
  000b8	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000bd	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  000c1	74 13		 je	 SHORT $LN2@deflatePar

; 439  :         /* Flush the last buffer: */
; 440  :         err = deflate(strm, Z_PARTIAL_FLUSH);

  000c3	ba 01 00 00 00	 mov	 edx, 1
  000c8	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000cd	e8 00 00 00 00	 call	 deflate
  000d2	89 44 24 28	 mov	 DWORD PTR err$[rsp], eax
$LN2@deflatePar:

; 441  :     }
; 442  :     if (s->level != level) {

  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000db	8b 44 24 58	 mov	 eax, DWORD PTR level$[rsp]
  000df	39 81 ac 00 00
	00		 cmp	 DWORD PTR [rcx+172], eax
  000e5	0f 84 8e 00 00
	00		 je	 $LN1@deflatePar

; 443  :         s->level = level;

  000eb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000f0	8b 44 24 58	 mov	 eax, DWORD PTR level$[rsp]
  000f4	89 81 ac 00 00
	00		 mov	 DWORD PTR [rcx+172], eax

; 444  :         s->max_lazy_match   = configuration_table[level].max_lazy;

  000fa	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  000ff	48 6b c9 10	 imul	 rcx, 16
  00103	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0010a	0f b7 4c 08 02	 movzx	 ecx, WORD PTR [rax+rcx+2]
  0010f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00114	89 88 a8 00 00
	00		 mov	 DWORD PTR [rax+168], ecx

; 445  :         s->good_match       = configuration_table[level].good_length;

  0011a	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  0011f	48 6b c9 10	 imul	 rcx, 16
  00123	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  0012a	0f b7 0c 08	 movzx	 ecx, WORD PTR [rax+rcx]
  0012e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00133	89 88 b4 00 00
	00		 mov	 DWORD PTR [rax+180], ecx

; 446  :         s->nice_match       = configuration_table[level].nice_length;

  00139	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  0013e	48 6b c9 10	 imul	 rcx, 16
  00142	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00149	0f b7 4c 08 04	 movzx	 ecx, WORD PTR [rax+rcx+4]
  0014e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00153	89 88 b8 00 00
	00		 mov	 DWORD PTR [rax+184], ecx

; 447  :         s->max_chain_length = configuration_table[level].max_chain;

  00159	48 63 4c 24 58	 movsxd	 rcx, DWORD PTR level$[rsp]
  0015e	48 6b c9 10	 imul	 rcx, 16
  00162	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:configuration_table
  00169	0f b7 4c 08 06	 movzx	 ecx, WORD PTR [rax+rcx+6]
  0016e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00173	89 88 a4 00 00
	00		 mov	 DWORD PTR [rax+164], ecx
$LN1@deflatePar:

; 448  :     }
; 449  :     s->strategy = strategy;

  00179	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0017e	8b 44 24 60	 mov	 eax, DWORD PTR strategy$[rsp]
  00182	89 81 b0 00 00
	00		 mov	 DWORD PTR [rcx+176], eax

; 450  :     return err;

  00188	8b 44 24 28	 mov	 eax, DWORD PTR err$[rsp]
$LN8@deflatePar:

; 451  : }

  0018c	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00190	c3		 ret	 0
deflateParams ENDP
_TEXT	ENDS
PUBLIC	deflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateReset DD imagerel $LN10
	DD	imagerel $LN10+322
	DD	imagerel $unwind$deflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateReset DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateReset
_TEXT	SEGMENT
s$ = 32
tv87 = 40
tv131 = 44
strm$ = 64
deflateReset PROC					; COMDAT

; 359  : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 360  :     deflate_state *s;
; 361  : 
; 362  :     if (strm == Z_NULL || strm->state == Z_NULL ||
; 363  :         strm->zalloc == (alloc_func)0 || strm->zfree == (free_func)0) {

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 24		 je	 SHORT $LN2@deflateRes
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 18		 je	 SHORT $LN2@deflateRes
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00027	74 0c		 je	 SHORT $LN2@deflateRes
  00029	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00033	75 0a		 jne	 SHORT $LN3@deflateRes
$LN2@deflateRes:

; 364  :         return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	e9 fe 00 00 00	 jmp	 $LN4@deflateRes
$LN3@deflateRes:

; 365  :     }
; 366  : 
; 367  :     strm->total_in = strm->total_out = 0;

  0003f	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00044	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 368  :     strm->msg = Z_NULL; /* use zfree if we ever allocate msg dynamically */

  00057	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 369  :     strm->data_type = Z_UNKNOWN;

  00064	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00069	c7 40 48 02 00
	00 00		 mov	 DWORD PTR [rax+72], 2

; 370  : 
; 371  :     s = (deflate_state *)strm->state;

  00070	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00075	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00079	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 372  :     s->pending = 0;

  0007e	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00083	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [rax+40], 0

; 373  :     s->pending_out = s->pending_buf;

  0008a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0008f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00094	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  00098	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 374  : 
; 375  :     if (s->wrap < 0) {

  0009c	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000a1	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000a5	7d 12		 jge	 SHORT $LN1@deflateRes

; 376  :         s->wrap = -s->wrap; /* was made negative by deflate(..., Z_FINISH); */

  000a7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000ac	8b 48 2c	 mov	 ecx, DWORD PTR [rax+44]
  000af	f7 d9		 neg	 ecx
  000b1	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000b6	89 48 2c	 mov	 DWORD PTR [rax+44], ecx
$LN1@deflateRes:

; 377  :     }
; 378  :     s->status = s->wrap ? INIT_STATE : BUSY_STATE;

  000b9	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000be	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  000c2	74 0a		 je	 SHORT $LN6@deflateRes
  000c4	c7 44 24 28 2a
	00 00 00	 mov	 DWORD PTR tv87[rsp], 42	; 0000002aH
  000cc	eb 08		 jmp	 SHORT $LN7@deflateRes
$LN6@deflateRes:
  000ce	c7 44 24 28 71
	00 00 00	 mov	 DWORD PTR tv87[rsp], 113 ; 00000071H
$LN7@deflateRes:
  000d6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  000db	8b 44 24 28	 mov	 eax, DWORD PTR tv87[rsp]
  000df	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 379  :     strm->adler =
; 380  : #ifdef GZIP
; 381  :         s->wrap == 2 ? crc32(0L, Z_NULL, 0) :
; 382  : #endif
; 383  :         adler32(0L, Z_NULL, 0);

  000e2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  000e7	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  000eb	75 12		 jne	 SHORT $LN8@deflateRes
  000ed	45 33 c0	 xor	 r8d, r8d
  000f0	33 d2		 xor	 edx, edx
  000f2	33 c9		 xor	 ecx, ecx
  000f4	e8 00 00 00 00	 call	 crc32
  000f9	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
  000fd	eb 10		 jmp	 SHORT $LN9@deflateRes
$LN8@deflateRes:
  000ff	45 33 c0	 xor	 r8d, r8d
  00102	33 d2		 xor	 edx, edx
  00104	33 c9		 xor	 ecx, ecx
  00106	e8 00 00 00 00	 call	 adler32
  0010b	89 44 24 2c	 mov	 DWORD PTR tv131[rsp], eax
$LN9@deflateRes:
  0010f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00114	8b 44 24 2c	 mov	 eax, DWORD PTR tv131[rsp]
  00118	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 384  :     s->last_flush = Z_NO_FLUSH;

  0011b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00120	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 385  : 
; 386  :     _tr_init(s);

  00127	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	e8 00 00 00 00	 call	 _tr_init

; 387  :     lm_init(s);

  00131	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00136	e8 00 00 00 00	 call	 lm_init

; 388  : 
; 389  :     return Z_OK;

  0013b	33 c0		 xor	 eax, eax
$LN4@deflateRes:

; 390  : }

  0013d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00141	c3		 ret	 0
deflateReset ENDP
_TEXT	ENDS
PUBLIC	deflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateSetDictionary DD imagerel $LN12
	DD	imagerel $LN12+621
	DD	imagerel $unwind$deflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateSetDictionary DD 011301H
	DD	08213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateSetDictionary
_TEXT	SEGMENT
length$ = 32
n$ = 36
s$ = 40
hash_head$ = 48
strm$ = 80
dictionary$ = 88
dictLength$ = 96
deflateSetDictionary PROC				; COMDAT

; 319  : {

$LN12:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 320  :     deflate_state *s;
; 321  :     uInt length = dictLength;

  00013	8b 44 24 60	 mov	 eax, DWORD PTR dictLength$[rsp]
  00017	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 322  :     uInt n;
; 323  :     IPos hash_head = 0;

  0001b	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0

; 324  : 
; 325  :     if (strm == Z_NULL || strm->state == Z_NULL || dictionary == Z_NULL ||
; 326  :         strm->state->wrap == 2 ||
; 327  :         (strm->state->wrap == 1 && strm->state->status != INIT_STATE))

  00023	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00029	74 41		 je	 SHORT $LN8@deflateSet
  0002b	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00030	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00035	74 35		 je	 SHORT $LN8@deflateSet
  00037	48 83 7c 24 58
	00		 cmp	 QWORD PTR dictionary$[rsp], 0
  0003d	74 2d		 je	 SHORT $LN8@deflateSet
  0003f	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00044	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00048	83 78 2c 02	 cmp	 DWORD PTR [rax+44], 2
  0004c	74 1e		 je	 SHORT $LN8@deflateSet
  0004e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00053	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00057	83 78 2c 01	 cmp	 DWORD PTR [rax+44], 1
  0005b	75 19		 jne	 SHORT $LN9@deflateSet
  0005d	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00062	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00066	83 78 08 2a	 cmp	 DWORD PTR [rax+8], 42	; 0000002aH
  0006a	74 0a		 je	 SHORT $LN9@deflateSet
$LN8@deflateSet:

; 328  :         return Z_STREAM_ERROR;

  0006c	b8 fe ff ff ff	 mov	 eax, -2
  00071	e9 f2 01 00 00	 jmp	 $LN10@deflateSet
$LN9@deflateSet:

; 329  : 
; 330  :     s = strm->state;

  00076	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0007f	48 89 44 24 28	 mov	 QWORD PTR s$[rsp], rax

; 331  :     if (s->wrap)

  00084	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00089	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0008d	74 23		 je	 SHORT $LN7@deflateSet

; 332  :         strm->adler = adler32(strm->adler, dictionary, dictLength);

  0008f	44 8b 44 24 60	 mov	 r8d, DWORD PTR dictLength$[rsp]
  00094	48 8b 54 24 58	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00099	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0009e	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000a1	e8 00 00 00 00	 call	 adler32
  000a6	44 8b d8	 mov	 r11d, eax
  000a9	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000ae	44 89 58 4c	 mov	 DWORD PTR [rax+76], r11d
$LN7@deflateSet:

; 333  : 
; 334  :     if (length < MIN_MATCH) return Z_OK;

  000b2	83 7c 24 20 03	 cmp	 DWORD PTR length$[rsp], 3
  000b7	73 07		 jae	 SHORT $LN6@deflateSet
  000b9	33 c0		 xor	 eax, eax
  000bb	e9 a8 01 00 00	 jmp	 $LN10@deflateSet
$LN6@deflateSet:

; 335  :     if (length > MAX_DIST(s)) {

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000c5	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000c8	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000cd	39 44 24 20	 cmp	 DWORD PTR length$[rsp], eax
  000d1	76 2a		 jbe	 SHORT $LN5@deflateSet

; 336  :         length = MAX_DIST(s);

  000d3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  000d8	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000db	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  000e0	89 44 24 20	 mov	 DWORD PTR length$[rsp], eax

; 337  :         dictionary += dictLength - length; /* use the tail of the dictionary */

  000e4	8b 4c 24 20	 mov	 ecx, DWORD PTR length$[rsp]
  000e8	8b 44 24 60	 mov	 eax, DWORD PTR dictLength$[rsp]
  000ec	2b c1		 sub	 eax, ecx
  000ee	8b c8		 mov	 ecx, eax
  000f0	48 8b 44 24 58	 mov	 rax, QWORD PTR dictionary$[rsp]
  000f5	48 03 c1	 add	 rax, rcx
  000f8	48 89 44 24 58	 mov	 QWORD PTR dictionary$[rsp], rax
$LN5@deflateSet:

; 338  :     }
; 339  :     zmemcpy(s->window, dictionary, length);

  000fd	44 8b 44 24 20	 mov	 r8d, DWORD PTR length$[rsp]
  00102	48 8b 54 24 58	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00107	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0010c	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  00110	e8 00 00 00 00	 call	 memcpy

; 340  :     s->strstart = length;

  00115	4c 8b 5c 24 28	 mov	 r11, QWORD PTR s$[rsp]
  0011a	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  0011e	41 89 83 94 00
	00 00		 mov	 DWORD PTR [r11+148], eax

; 341  :     s->block_start = (long)length;

  00125	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0012a	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  0012e	89 81 84 00 00
	00		 mov	 DWORD PTR [rcx+132], eax

; 342  : 
; 343  :     /* Insert all strings in the hash table (except for the last two bytes).
; 344  :      * s->lookahead stays null, so s->ins_h will be recomputed at the next
; 345  :      * call of fill_window.
; 346  :      */
; 347  :     s->ins_h = s->window[0];

  00134	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00139	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0013d	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00140	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00145	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 348  :     UPDATE_HASH(s, s->ins_h, s->window[1]);

  00148	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0014d	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00153	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00158	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  0015b	d3 e0		 shl	 eax, cl
  0015d	8b c8		 mov	 ecx, eax
  0015f	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00164	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00168	0f b6 40 01	 movzx	 eax, BYTE PTR [rax+1]
  0016c	33 c8		 xor	 ecx, eax
  0016e	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  00173	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  00176	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0017b	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 349  :     for (n = 0; n <= length - MIN_MATCH; n++) {

  0017e	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR n$[rsp], 0
  00186	eb 0b		 jmp	 SHORT $LN4@deflateSet
$LN3@deflateSet:
  00188	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  0018c	83 c0 01	 add	 eax, 1
  0018f	89 44 24 24	 mov	 DWORD PTR n$[rsp], eax
$LN4@deflateSet:
  00193	8b 44 24 20	 mov	 eax, DWORD PTR length$[rsp]
  00197	83 e8 03	 sub	 eax, 3
  0019a	39 44 24 24	 cmp	 DWORD PTR n$[rsp], eax
  0019e	0f 87 b3 00 00
	00		 ja	 $LN2@deflateSet

; 350  :         INSERT_STRING(s, n, hash_head);

  001a4	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001a9	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  001af	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001b4	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  001b7	d3 e2		 shl	 edx, cl
  001b9	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  001bd	83 c0 02	 add	 eax, 2
  001c0	8b c8		 mov	 ecx, eax
  001c2	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001c7	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  001cb	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  001cf	8b ca		 mov	 ecx, edx
  001d1	33 c8		 xor	 ecx, eax
  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001d8	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  001db	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001e0	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  001e3	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001e8	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  001ec	4c 8b 44 24 28	 mov	 r8, QWORD PTR s$[rsp]
  001f1	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  001f5	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  001fa	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  001fd	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00201	23 c1		 and	 eax, ecx
  00203	8b d0		 mov	 edx, eax
  00205	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  0020a	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0020e	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  00213	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00217	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0021c	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0021f	8b 44 24 24	 mov	 eax, DWORD PTR n$[rsp]
  00223	23 c1		 and	 eax, ecx
  00225	8b c8		 mov	 ecx, eax
  00227	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0022c	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00230	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00234	89 44 24 30	 mov	 DWORD PTR hash_head$[rsp], eax
  00238	48 8b 44 24 28	 mov	 rax, QWORD PTR s$[rsp]
  0023d	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00240	48 8b 4c 24 28	 mov	 rcx, QWORD PTR s$[rsp]
  00245	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00249	0f b7 44 24 24	 movzx	 eax, WORD PTR n$[rsp]
  0024e	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 351  :     }

  00252	e9 31 ff ff ff	 jmp	 $LN3@deflateSet
$LN2@deflateSet:

; 352  :     if (hash_head) hash_head = 0;  /* to make compiler happy */

  00257	83 7c 24 30 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  0025c	74 08		 je	 SHORT $LN1@deflateSet
  0025e	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0
$LN1@deflateSet:

; 353  :     return Z_OK;

  00266	33 c0		 xor	 eax, eax
$LN10@deflateSet:

; 354  : }

  00268	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0026c	c3		 ret	 0
deflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	deflateInit2_
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit2_ DD imagerel $LN18
	DD	imagerel $LN18+1062
	DD	imagerel $unwind$deflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit2_ DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateInit2_
_TEXT	SEGMENT
s$ = 32
overlay$ = 40
wrap$ = 48
strm$ = 80
level$ = 88
method$ = 96
windowBits$ = 104
memLevel$ = 112
strategy$ = 120
version$ = 128
stream_size$ = 136
deflateInit2_ PROC					; COMDAT

; 226  : {

$LN18:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 227  :     deflate_state *s;
; 228  :     int wrap = 1;

  00017	c7 44 24 30 01
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 1

; 229  :     static const char my_version[] = ZLIB_VERSION;
; 230  : 
; 231  :     ushf *overlay;
; 232  :     /* We overlay pending_buf and d_buf+l_buf. This works since the average
; 233  :      * output size for (length,distance) codes is <= 24 bits.
; 234  :      */
; 235  : 
; 236  :     if (version == Z_NULL || version[0] != my_version[0] ||
; 237  :         stream_size != sizeof(z_stream)) {

  0001f	48 83 bc 24 80
	00 00 00 00	 cmp	 QWORD PTR version$[rsp], 0
  00028	74 24		 je	 SHORT $LN14@deflateIni
  0002a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR version$[rsp]
  00032	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00035	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ?my_version@?1??deflateInit2_@@9@9
  0003c	3b c8		 cmp	 ecx, eax
  0003e	75 0e		 jne	 SHORT $LN14@deflateIni
  00040	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR stream_size$[rsp]
  00048	48 83 f8 58	 cmp	 rax, 88			; 00000058H
  0004c	74 0a		 je	 SHORT $LN15@deflateIni
$LN14@deflateIni:

; 238  :         return Z_VERSION_ERROR;

  0004e	b8 fa ff ff ff	 mov	 eax, -6
  00053	e9 c9 03 00 00	 jmp	 $LN16@deflateIni
$LN15@deflateIni:

; 239  :     }
; 240  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00058	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0005e	75 0a		 jne	 SHORT $LN13@deflateIni
  00060	b8 fe ff ff ff	 mov	 eax, -2
  00065	e9 b7 03 00 00	 jmp	 $LN16@deflateIni
$LN13@deflateIni:

; 241  : 
; 242  :     strm->msg = Z_NULL;

  0006a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0006f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 243  :     if (strm->zalloc == (alloc_func)0) {

  00077	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0007c	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00081	75 1d		 jne	 SHORT $LN12@deflateIni

; 244  :         strm->zalloc = zcalloc;

  00083	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00088	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc
  0008f	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 245  :         strm->opaque = (voidpf)0;

  00093	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00098	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN12@deflateIni:

; 246  :     }
; 247  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  000a0	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  000a5	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000aa	75 10		 jne	 SHORT $LN11@deflateIni
  000ac	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  000b1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  000b8	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN11@deflateIni:

; 248  : 
; 249  : #ifdef FASTEST
; 250  :     if (level != 0) level = 1;
; 251  : #else
; 252  :     if (level == Z_DEFAULT_COMPRESSION) level = 6;

  000bc	83 7c 24 58 ff	 cmp	 DWORD PTR level$[rsp], -1
  000c1	75 08		 jne	 SHORT $LN10@deflateIni
  000c3	c7 44 24 58 06
	00 00 00	 mov	 DWORD PTR level$[rsp], 6
$LN10@deflateIni:

; 253  : #endif
; 254  : 
; 255  :     if (windowBits < 0) { /* suppress zlib wrapper */

  000cb	83 7c 24 68 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  000d0	7d 14		 jge	 SHORT $LN9@deflateIni

; 256  :         wrap = 0;

  000d2	c7 44 24 30 00
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 0

; 257  :         windowBits = -windowBits;

  000da	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  000de	f7 d8		 neg	 eax
  000e0	89 44 24 68	 mov	 DWORD PTR windowBits$[rsp], eax
  000e4	eb 1a		 jmp	 SHORT $LN8@deflateIni
$LN9@deflateIni:

; 258  :     }
; 259  : #ifdef GZIP
; 260  :     else if (windowBits > 15) {

  000e6	83 7c 24 68 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  000eb	7e 13		 jle	 SHORT $LN7@deflateIni

; 261  :         wrap = 2;       /* write gzip wrapper instead */

  000ed	c7 44 24 30 02
	00 00 00	 mov	 DWORD PTR wrap$[rsp], 2

; 262  :         windowBits -= 16;

  000f5	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  000f9	83 e8 10	 sub	 eax, 16
  000fc	89 44 24 68	 mov	 DWORD PTR windowBits$[rsp], eax
$LN7@deflateIni:
$LN8@deflateIni:

; 263  :     }
; 264  : #endif
; 265  :     if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method != Z_DEFLATED ||
; 266  :         windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||
; 267  :         strategy < 0 || strategy > Z_FIXED) {

  00100	83 7c 24 70 01	 cmp	 DWORD PTR memLevel$[rsp], 1
  00105	7c 38		 jl	 SHORT $LN5@deflateIni
  00107	83 7c 24 70 09	 cmp	 DWORD PTR memLevel$[rsp], 9
  0010c	7f 31		 jg	 SHORT $LN5@deflateIni
  0010e	83 7c 24 60 08	 cmp	 DWORD PTR method$[rsp], 8
  00113	75 2a		 jne	 SHORT $LN5@deflateIni
  00115	83 7c 24 68 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0011a	7c 23		 jl	 SHORT $LN5@deflateIni
  0011c	83 7c 24 68 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00121	7f 1c		 jg	 SHORT $LN5@deflateIni
  00123	83 7c 24 58 00	 cmp	 DWORD PTR level$[rsp], 0
  00128	7c 15		 jl	 SHORT $LN5@deflateIni
  0012a	83 7c 24 58 09	 cmp	 DWORD PTR level$[rsp], 9
  0012f	7f 0e		 jg	 SHORT $LN5@deflateIni
  00131	83 7c 24 78 00	 cmp	 DWORD PTR strategy$[rsp], 0
  00136	7c 07		 jl	 SHORT $LN5@deflateIni
  00138	83 7c 24 78 04	 cmp	 DWORD PTR strategy$[rsp], 4
  0013d	7e 0a		 jle	 SHORT $LN6@deflateIni
$LN5@deflateIni:

; 268  :         return Z_STREAM_ERROR;

  0013f	b8 fe ff ff ff	 mov	 eax, -2
  00144	e9 d8 02 00 00	 jmp	 $LN16@deflateIni
$LN6@deflateIni:

; 269  :     }
; 270  :     if (windowBits == 8) windowBits = 9;  /* until 256-byte window bug fixed */

  00149	83 7c 24 68 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  0014e	75 08		 jne	 SHORT $LN4@deflateIni
  00150	c7 44 24 68 09
	00 00 00	 mov	 DWORD PTR windowBits$[rsp], 9
$LN4@deflateIni:

; 271  :     s = (deflate_state *) ZALLOC(strm, 1, sizeof(deflate_state));

  00158	41 b8 18 17 00
	00		 mov	 r8d, 5912		; 00001718H
  0015e	ba 01 00 00 00	 mov	 edx, 1
  00163	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00168	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0016c	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00171	ff 50 30	 call	 QWORD PTR [rax+48]
  00174	48 89 44 24 20	 mov	 QWORD PTR s$[rsp], rax

; 272  :     if (s == Z_NULL) return Z_MEM_ERROR;

  00179	48 83 7c 24 20
	00		 cmp	 QWORD PTR s$[rsp], 0
  0017f	75 0a		 jne	 SHORT $LN3@deflateIni
  00181	b8 fc ff ff ff	 mov	 eax, -4
  00186	e9 96 02 00 00	 jmp	 $LN16@deflateIni
$LN3@deflateIni:

; 273  :     strm->state = (struct internal_state FAR *)s;

  0018b	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00190	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00195	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 274  :     s->strm = strm;

  00199	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0019e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001a3	48 89 01	 mov	 QWORD PTR [rcx], rax

; 275  : 
; 276  :     s->wrap = wrap;

  001a6	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001ab	8b 44 24 30	 mov	 eax, DWORD PTR wrap$[rsp]
  001af	89 41 2c	 mov	 DWORD PTR [rcx+44], eax

; 277  :     s->gzhead = Z_NULL;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001b7	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0

; 278  :     s->w_bits = windowBits;

  001bf	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  001c4	8b 44 24 68	 mov	 eax, DWORD PTR windowBits$[rsp]
  001c8	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 279  :     s->w_size = 1 << s->w_bits;

  001cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001d0	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  001d3	b8 01 00 00 00	 mov	 eax, 1
  001d8	d3 e0		 shl	 eax, cl
  001da	8b c8		 mov	 ecx, eax
  001dc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e1	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 280  :     s->w_mask = s->w_size - 1;

  001e4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001e9	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  001ec	83 e9 01	 sub	 ecx, 1
  001ef	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  001f4	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 281  : 
; 282  :     s->hash_bits = memLevel + 7;

  001f7	8b 4c 24 70	 mov	 ecx, DWORD PTR memLevel$[rsp]
  001fb	83 c1 07	 add	 ecx, 7
  001fe	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00203	89 48 78	 mov	 DWORD PTR [rax+120], ecx

; 283  :     s->hash_size = 1 << s->hash_bits;

  00206	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0020b	8b 48 78	 mov	 ecx, DWORD PTR [rax+120]
  0020e	b8 01 00 00 00	 mov	 eax, 1
  00213	d3 e0		 shl	 eax, cl
  00215	8b c8		 mov	 ecx, eax
  00217	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0021c	89 48 74	 mov	 DWORD PTR [rax+116], ecx

; 284  :     s->hash_mask = s->hash_size - 1;

  0021f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00224	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  00227	83 e9 01	 sub	 ecx, 1
  0022a	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0022f	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 285  :     s->hash_shift =  ((s->hash_bits+MIN_MATCH-1)/MIN_MATCH);

  00232	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00237	8b 40 78	 mov	 eax, DWORD PTR [rax+120]
  0023a	83 c0 02	 add	 eax, 2
  0023d	33 d2		 xor	 edx, edx
  0023f	b9 03 00 00 00	 mov	 ecx, 3
  00244	f7 f1		 div	 ecx
  00246	8b c8		 mov	 ecx, eax
  00248	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0024d	89 88 80 00 00
	00		 mov	 DWORD PTR [rax+128], ecx

; 286  : 
; 287  :     s->window = (Bytef *) ZALLOC(strm, s->w_size, 2*sizeof(Byte));

  00253	41 b8 02 00 00
	00		 mov	 r8d, 2
  00259	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0025e	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  00261	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00266	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0026a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0026f	ff 50 30	 call	 QWORD PTR [rax+48]
  00272	4c 8b d8	 mov	 r11, rax
  00275	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0027a	4c 89 58 50	 mov	 QWORD PTR [rax+80], r11

; 288  :     s->prev   = (Posf *)  ZALLOC(strm, s->w_size, sizeof(Pos));

  0027e	41 b8 02 00 00
	00		 mov	 r8d, 2
  00284	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00289	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  0028c	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00291	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00295	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0029a	ff 50 30	 call	 QWORD PTR [rax+48]
  0029d	4c 8b d8	 mov	 r11, rax
  002a0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002a5	4c 89 58 60	 mov	 QWORD PTR [rax+96], r11

; 289  :     s->head   = (Posf *)  ZALLOC(strm, s->hash_size, sizeof(Pos));

  002a9	41 b8 02 00 00
	00		 mov	 r8d, 2
  002af	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002b4	8b 50 74	 mov	 edx, DWORD PTR [rax+116]
  002b7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  002bc	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  002c0	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  002c5	ff 50 30	 call	 QWORD PTR [rax+48]
  002c8	4c 8b d8	 mov	 r11, rax
  002cb	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002d0	4c 89 58 68	 mov	 QWORD PTR [rax+104], r11

; 290  : 
; 291  :     s->lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */

  002d4	8b 4c 24 70	 mov	 ecx, DWORD PTR memLevel$[rsp]
  002d8	83 c1 06	 add	 ecx, 6
  002db	b8 01 00 00 00	 mov	 eax, 1
  002e0	d3 e0		 shl	 eax, cl
  002e2	8b c8		 mov	 ecx, eax
  002e4	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002e9	89 88 f0 16 00
	00		 mov	 DWORD PTR [rax+5872], ecx

; 292  : 
; 293  :     overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);

  002ef	41 b8 04 00 00
	00		 mov	 r8d, 4
  002f5	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  002fa	8b 90 f0 16 00
	00		 mov	 edx, DWORD PTR [rax+5872]
  00300	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  00305	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00309	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0030e	ff 50 30	 call	 QWORD PTR [rax+48]
  00311	48 89 44 24 28	 mov	 QWORD PTR overlay$[rsp], rax

; 294  :     s->pending_buf = (uchf *) overlay;

  00316	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0031b	48 8b 44 24 28	 mov	 rax, QWORD PTR overlay$[rsp]
  00320	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax

; 295  :     s->pending_buf_size = (ulg)s->lit_bufsize * (sizeof(ush)+2L);

  00324	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00329	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  0032f	48 c1 e1 02	 shl	 rcx, 2
  00333	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00338	89 48 18	 mov	 DWORD PTR [rax+24], ecx

; 296  : 
; 297  :     if (s->window == Z_NULL || s->prev == Z_NULL || s->head == Z_NULL ||
; 298  :         s->pending_buf == Z_NULL) {

  0033b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00340	48 83 78 50 00	 cmp	 QWORD PTR [rax+80], 0
  00345	74 24		 je	 SHORT $LN1@deflateIni
  00347	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  0034c	48 83 78 60 00	 cmp	 QWORD PTR [rax+96], 0
  00351	74 18		 je	 SHORT $LN1@deflateIni
  00353	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00358	48 83 78 68 00	 cmp	 QWORD PTR [rax+104], 0
  0035d	74 0c		 je	 SHORT $LN1@deflateIni
  0035f	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00364	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00369	75 30		 jne	 SHORT $LN2@deflateIni
$LN1@deflateIni:

; 299  :         s->status = FINISH_STATE;

  0036b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  00370	c7 40 08 9a 02
	00 00		 mov	 DWORD PTR [rax+8], 666	; 0000029aH

; 300  :         strm->msg = (char*)ERR_MSG(Z_MEM_ERROR);

  00377	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0037c	48 8b 05 30 00
	00 00		 mov	 rax, QWORD PTR z_errmsg+48
  00383	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 301  :         deflateEnd (strm);

  00387	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0038c	e8 00 00 00 00	 call	 deflateEnd

; 302  :         return Z_MEM_ERROR;

  00391	b8 fc ff ff ff	 mov	 eax, -4
  00396	e9 86 00 00 00	 jmp	 $LN16@deflateIni
$LN2@deflateIni:

; 303  :     }
; 304  :     s->d_buf = overlay + s->lit_bufsize/sizeof(ush);

  0039b	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003a0	8b 80 f0 16 00
	00		 mov	 eax, DWORD PTR [rax+5872]
  003a6	33 d2		 xor	 edx, edx
  003a8	b9 02 00 00 00	 mov	 ecx, 2
  003ad	48 f7 f1	 div	 rcx
  003b0	48 8b c8	 mov	 rcx, rax
  003b3	48 8b 44 24 28	 mov	 rax, QWORD PTR overlay$[rsp]
  003b8	48 8d 0c 48	 lea	 rcx, QWORD PTR [rax+rcx*2]
  003bc	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003c1	48 89 88 f8 16
	00 00		 mov	 QWORD PTR [rax+5880], rcx

; 305  :     s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;

  003c8	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003cd	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  003d3	48 6b c9 03	 imul	 rcx, 3
  003d7	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003dc	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  003e0	48 8b 44 24 20	 mov	 rax, QWORD PTR s$[rsp]
  003e5	48 89 88 e8 16
	00 00		 mov	 QWORD PTR [rax+5864], rcx

; 306  : 
; 307  :     s->level = level;

  003ec	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  003f1	8b 44 24 58	 mov	 eax, DWORD PTR level$[rsp]
  003f5	89 81 ac 00 00
	00		 mov	 DWORD PTR [rcx+172], eax

; 308  :     s->strategy = strategy;

  003fb	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  00400	8b 44 24 78	 mov	 eax, DWORD PTR strategy$[rsp]
  00404	89 81 b0 00 00
	00		 mov	 DWORD PTR [rcx+176], eax

; 309  :     s->method = (Byte)method;

  0040a	48 8b 4c 24 20	 mov	 rcx, QWORD PTR s$[rsp]
  0040f	0f b6 44 24 60	 movzx	 eax, BYTE PTR method$[rsp]
  00414	88 41 3c	 mov	 BYTE PTR [rcx+60], al

; 310  : 
; 311  :     return deflateReset(strm);

  00417	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0041c	e8 00 00 00 00	 call	 deflateReset
$LN16@deflateIni:

; 312  : }

  00421	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00425	c3		 ret	 0
deflateInit2_ ENDP
_TEXT	ENDS
PUBLIC	deflateInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+88
	DD	imagerel $unwind$deflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflateInit_ DD 011701H
	DD	08217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflateInit_
_TEXT	SEGMENT
strm$ = 80
level$ = 88
version$ = 96
stream_size$ = 104
deflateInit_ PROC					; COMDAT

; 209  : {

$LN3:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 210  :     return deflateInit2_(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL,
; 211  :                          Z_DEFAULT_STRATEGY, version, stream_size);

  00017	8b 44 24 68	 mov	 eax, DWORD PTR stream_size$[rsp]
  0001b	89 44 24 38	 mov	 DWORD PTR [rsp+56], eax
  0001f	48 8b 44 24 60	 mov	 rax, QWORD PTR version$[rsp]
  00024	48 89 44 24 30	 mov	 QWORD PTR [rsp+48], rax
  00029	c7 44 24 28 00
	00 00 00	 mov	 DWORD PTR [rsp+40], 0
  00031	c7 44 24 20 08
	00 00 00	 mov	 DWORD PTR [rsp+32], 8
  00039	41 b9 0f 00 00
	00		 mov	 r9d, 15
  0003f	41 b8 08 00 00
	00		 mov	 r8d, 8
  00045	8b 54 24 58	 mov	 edx, DWORD PTR level$[rsp]
  00049	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0004e	e8 00 00 00 00	 call	 deflateInit2_

; 212  :     /* To do: ignore strm->next_in if we use it as window */
; 213  : }

  00053	48 83 c4 48	 add	 rsp, 72			; 00000048H
  00057	c3		 ret	 0
deflateInit_ ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$fill_window DD imagerel fill_window
	DD	imagerel fill_window+799
	DD	imagerel $unwind$fill_window
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$fill_window DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT fill_window
_TEXT	SEGMENT
p$ = 32
n$ = 40
more$ = 44
wsize$ = 48
m$ = 52
tv141 = 56
tv153 = 60
s$ = 80
fill_window PROC					; COMDAT

; 1268 : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1269 :     register unsigned n, m;
; 1270 :     register Posf *p;
; 1271 :     unsigned more;    /* Amount of free space at the end of the window. */
; 1272 :     uInt wsize = s->w_size;

  00009	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0000e	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00011	89 44 24 30	 mov	 DWORD PTR wsize$[rsp], eax
$LN17@fill_windo:

; 1273 : 
; 1274 :     do {
; 1275 :         more = (unsigned)(s->window_size -(ulg)s->lookahead -(ulg)s->strstart);

  00015	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  0001a	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0001f	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00025	8b 42 58	 mov	 eax, DWORD PTR [rdx+88]
  00028	2b c1		 sub	 eax, ecx
  0002a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0002f	2b 81 94 00 00
	00		 sub	 eax, DWORD PTR [rcx+148]
  00035	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax

; 1276 : 
; 1277 :         /* Deal with !@#$% 64K limit: */
; 1278 :         if (sizeof(int) <= 2) {

  00039	33 c0		 xor	 eax, eax
  0003b	85 c0		 test	 eax, eax
  0003d	74 3f		 je	 SHORT $LN14@fill_windo

; 1279 :             if (more == 0 && s->strstart == 0 && s->lookahead == 0) {

  0003f	83 7c 24 2c 00	 cmp	 DWORD PTR more$[rsp], 0
  00044	75 26		 jne	 SHORT $LN13@fill_windo
  00046	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0004b	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  00052	75 18		 jne	 SHORT $LN13@fill_windo
  00054	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00059	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00060	75 0a		 jne	 SHORT $LN13@fill_windo

; 1280 :                 more = wsize;

  00062	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00066	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
  0006a	eb 12		 jmp	 SHORT $LN12@fill_windo
$LN13@fill_windo:

; 1281 : 
; 1282 :             } else if (more == (unsigned)(-1)) {

  0006c	83 7c 24 2c ff	 cmp	 DWORD PTR more$[rsp], -1 ; ffffffffH
  00071	75 0b		 jne	 SHORT $LN11@fill_windo

; 1283 :                 /* Very unlikely, but possible on 16 bit machine if
; 1284 :                  * strstart == 0 && lookahead == 1 (input done a byte at time)
; 1285 :                  */
; 1286 :                 more--;

  00073	8b 44 24 2c	 mov	 eax, DWORD PTR more$[rsp]
  00077	83 e8 01	 sub	 eax, 1
  0007a	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
$LN11@fill_windo:
$LN12@fill_windo:
$LN14@fill_windo:

; 1287 :             }
; 1288 :         }
; 1289 : 
; 1290 :         /* If the window is almost full and there is insufficient lookahead,
; 1291 :          * move the upper half to the lower one to make room in the upper half.
; 1292 :          */
; 1293 :         if (s->strstart >= wsize+MAX_DIST(s)) {

  0007e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00083	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00086	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  0008a	8d 8c 08 fa fe
	ff ff		 lea	 ecx, DWORD PTR [rax+rcx-262]
  00091	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00096	39 88 94 00 00
	00		 cmp	 DWORD PTR [rax+148], ecx
  0009c	0f 82 79 01 00
	00		 jb	 $LN10@fill_windo

; 1294 : 
; 1295 :             zmemcpy(s->window, s->window+wsize, (unsigned)wsize);

  000a2	44 8b 44 24 30	 mov	 r8d, DWORD PTR wsize$[rsp]
  000a7	8b 54 24 30	 mov	 edx, DWORD PTR wsize$[rsp]
  000ab	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000b0	48 03 50 50	 add	 rdx, QWORD PTR [rax+80]
  000b4	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000b9	48 8b 49 50	 mov	 rcx, QWORD PTR [rcx+80]
  000bd	e8 00 00 00 00	 call	 memcpy

; 1296 :             s->match_start -= wsize;

  000c2	4c 8b 5c 24 50	 mov	 r11, QWORD PTR s$[rsp]
  000c7	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000cb	41 8b 8b 98 00
	00 00		 mov	 ecx, DWORD PTR [r11+152]
  000d2	2b c8		 sub	 ecx, eax
  000d4	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000d9	89 88 98 00 00
	00		 mov	 DWORD PTR [rax+152], ecx

; 1297 :             s->strstart    -= wsize; /* we now have strstart >= MAX_DIST */

  000df	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  000e4	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  000e8	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000ee	2b c8		 sub	 ecx, eax
  000f0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  000f5	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1298 :             s->block_start -= (long) wsize;

  000fb	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  00100	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00104	8b 89 84 00 00
	00		 mov	 ecx, DWORD PTR [rcx+132]
  0010a	2b c8		 sub	 ecx, eax
  0010c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00111	89 88 84 00 00
	00		 mov	 DWORD PTR [rax+132], ecx

; 1299 : 
; 1300 :             /* Slide the hash table (could be avoided with 32 bit values
; 1301 :                at the expense of memory usage). We slide even when level == 0
; 1302 :                to keep the hash table consistent if we switch back to level > 0
; 1303 :                later. (Using level 0 permanently is not an optimal usage of
; 1304 :                zlib, so we don't care about this pathological case.)
; 1305 :              */
; 1306 :             /* %%% avoid this when Z_RLE */
; 1307 :             n = s->hash_size;

  00117	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0011c	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  0011f	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1308 :             p = &s->head[n];

  00123	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  00127	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0012c	48 8b 40 68	 mov	 rax, QWORD PTR [rax+104]
  00130	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  00134	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN9@fill_windo:

; 1309 :             do {
; 1310 :                 m = *--p;

  00139	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0013e	48 83 e8 02	 sub	 rax, 2
  00142	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  00147	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  0014c	0f b7 00	 movzx	 eax, WORD PTR [rax]
  0014f	89 44 24 34	 mov	 DWORD PTR m$[rsp], eax

; 1311 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  00153	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00157	39 44 24 34	 cmp	 DWORD PTR m$[rsp], eax
  0015b	72 10		 jb	 SHORT $LN20@fill_windo
  0015d	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  00161	8b 44 24 34	 mov	 eax, DWORD PTR m$[rsp]
  00165	2b c1		 sub	 eax, ecx
  00167	89 44 24 38	 mov	 DWORD PTR tv141[rsp], eax
  0016b	eb 08		 jmp	 SHORT $LN21@fill_windo
$LN20@fill_windo:
  0016d	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv141[rsp], 0
$LN21@fill_windo:
  00175	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  0017a	0f b7 44 24 38	 movzx	 eax, WORD PTR tv141[rsp]
  0017f	66 89 01	 mov	 WORD PTR [rcx], ax

; 1312 :             } while (--n);

  00182	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  00186	83 e8 01	 sub	 eax, 1
  00189	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  0018d	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  00192	75 a5		 jne	 SHORT $LN9@fill_windo

; 1313 : 
; 1314 :             n = wsize;

  00194	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  00198	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1315 : #ifndef FASTEST
; 1316 :             p = &s->prev[n];

  0019c	8b 4c 24 28	 mov	 ecx, DWORD PTR n$[rsp]
  001a0	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  001a5	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  001a9	48 8d 04 48	 lea	 rax, QWORD PTR [rax+rcx*2]
  001ad	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
$LN6@fill_windo:

; 1317 :             do {
; 1318 :                 m = *--p;

  001b2	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001b7	48 83 e8 02	 sub	 rax, 2
  001bb	48 89 44 24 20	 mov	 QWORD PTR p$[rsp], rax
  001c0	48 8b 44 24 20	 mov	 rax, QWORD PTR p$[rsp]
  001c5	0f b7 00	 movzx	 eax, WORD PTR [rax]
  001c8	89 44 24 34	 mov	 DWORD PTR m$[rsp], eax

; 1319 :                 *p = (Pos)(m >= wsize ? m-wsize : NIL);

  001cc	8b 44 24 30	 mov	 eax, DWORD PTR wsize$[rsp]
  001d0	39 44 24 34	 cmp	 DWORD PTR m$[rsp], eax
  001d4	72 10		 jb	 SHORT $LN22@fill_windo
  001d6	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  001da	8b 44 24 34	 mov	 eax, DWORD PTR m$[rsp]
  001de	2b c1		 sub	 eax, ecx
  001e0	89 44 24 3c	 mov	 DWORD PTR tv153[rsp], eax
  001e4	eb 08		 jmp	 SHORT $LN23@fill_windo
$LN22@fill_windo:
  001e6	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv153[rsp], 0
$LN23@fill_windo:
  001ee	48 8b 4c 24 20	 mov	 rcx, QWORD PTR p$[rsp]
  001f3	0f b7 44 24 3c	 movzx	 eax, WORD PTR tv153[rsp]
  001f8	66 89 01	 mov	 WORD PTR [rcx], ax

; 1320 :                 /* If n is not on any hash chain, prev[n] is garbage but
; 1321 :                  * its value will never be used.
; 1322 :                  */
; 1323 :             } while (--n);

  001fb	8b 44 24 28	 mov	 eax, DWORD PTR n$[rsp]
  001ff	83 e8 01	 sub	 eax, 1
  00202	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax
  00206	83 7c 24 28 00	 cmp	 DWORD PTR n$[rsp], 0
  0020b	75 a5		 jne	 SHORT $LN6@fill_windo

; 1324 : #endif
; 1325 :             more += wsize;

  0020d	8b 4c 24 30	 mov	 ecx, DWORD PTR wsize$[rsp]
  00211	8b 44 24 2c	 mov	 eax, DWORD PTR more$[rsp]
  00215	03 c1		 add	 eax, ecx
  00217	89 44 24 2c	 mov	 DWORD PTR more$[rsp], eax
$LN10@fill_windo:

; 1326 :         }
; 1327 :         if (s->strm->avail_in == 0) return;

  0021b	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00220	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00223	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00227	75 05		 jne	 SHORT $LN3@fill_windo
  00229	e9 ec 00 00 00	 jmp	 $LN18@fill_windo
$LN3@fill_windo:

; 1328 : 
; 1329 :         /* If there was no sliding:
; 1330 :          *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&
; 1331 :          *    more == window_size - lookahead - strstart
; 1332 :          * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)
; 1333 :          * => more >= window_size - 2*WSIZE + 2
; 1334 :          * In the BIG_MEM or MMAP case (not yet supported),
; 1335 :          *   window_size == input_size + MIN_LOOKAHEAD  &&
; 1336 :          *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.
; 1337 :          * Otherwise, window_size == 2*WSIZE so more >= 2.
; 1338 :          * If there was sliding, more >= WSIZE. So in all cases, more >= 2.
; 1339 :          */
; 1340 :         Assert(more >= 2, "more < 2");
; 1341 : 
; 1342 :         n = read_buf(s->strm, s->window + s->strstart + s->lookahead, more);

  0022e	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00233	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00239	48 8b 54 24 50	 mov	 rdx, QWORD PTR s$[rsp]
  0023e	48 8b 52 50	 mov	 rdx, QWORD PTR [rdx+80]
  00242	48 03 d0	 add	 rdx, rax
  00245	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0024a	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00250	48 03 d0	 add	 rdx, rax
  00253	44 8b 44 24 2c	 mov	 r8d, DWORD PTR more$[rsp]
  00258	48 8b 4c 24 50	 mov	 rcx, QWORD PTR s$[rsp]
  0025d	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00260	e8 00 00 00 00	 call	 read_buf
  00265	89 44 24 28	 mov	 DWORD PTR n$[rsp], eax

; 1343 :         s->lookahead += n;

  00269	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0026e	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00274	03 4c 24 28	 add	 ecx, DWORD PTR n$[rsp]
  00278	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0027d	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1344 : 
; 1345 :         /* Initialize the hash value now that we have some input: */
; 1346 :         if (s->lookahead >= MIN_MATCH) {

  00283	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00288	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0028f	72 66		 jb	 SHORT $LN2@fill_windo

; 1347 :             s->ins_h = s->window[s->strstart];

  00291	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  00296	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0029c	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002a1	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002a5	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  002a9	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002ae	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 1348 :             UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  002b1	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002b6	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  002bc	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002c1	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  002c4	d3 e2		 shl	 edx, cl
  002c6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002cb	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002d1	83 c0 01	 add	 eax, 1
  002d4	8b c8		 mov	 ecx, eax
  002d6	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002db	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  002df	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002e3	8b ca		 mov	 ecx, edx
  002e5	33 c8		 xor	 ecx, eax
  002e7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002ec	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  002ef	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002f4	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN2@fill_windo:

; 1349 : #if MIN_MATCH != 3
; 1350 :             Call UPDATE_HASH() MIN_MATCH-3 more times
; 1351 : #endif
; 1352 :         }
; 1353 :         /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,
; 1354 :          * but this is not important since only literal bytes will be emitted.
; 1355 :          */
; 1356 : 
; 1357 :     } while (s->lookahead < MIN_LOOKAHEAD && s->strm->avail_in != 0);

  002f7	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  002fc	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00306	73 12		 jae	 SHORT $LN1@fill_windo
  00308	48 8b 44 24 50	 mov	 rax, QWORD PTR s$[rsp]
  0030d	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00310	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00314	0f 85 fb fc ff
	ff		 jne	 $LN17@fill_windo
$LN1@fill_windo:
$LN18@fill_windo:

; 1358 : }

  0031a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0031e	c3		 ret	 0
fill_window ENDP
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_slow DD imagerel deflate_slow
	DD	imagerel deflate_slow+3199
	DD	imagerel $unwind$deflate_slow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_slow DD 010d01H
	DD	0e20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_slow
_TEXT	SEGMENT
bflush$ = 32
hash_head$ = 36
max_insert$78724 = 40
len$78725 = 44
dist$78726 = 48
cc$78741 = 52
cc$78751 = 53
tv255 = 56
tv272 = 60
tv348 = 64
tv392 = 72
tv405 = 80
tv466 = 88
tv469 = 92
tv481 = 96
tv490 = 104
tv492 = 108
s$ = 128
flush$ = 136
deflate_slow PROC					; COMDAT

; 1557 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 78	 sub	 rsp, 120		; 00000078H

; 1558 :     IPos hash_head = NIL;    /* head of hash chain */

  0000d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0
$LN26@deflate_sl:

; 1559 :     int bflush;              /* set if current block must be flushed */
; 1560 : 
; 1561 :     /* Process the input block. */
; 1562 :     for (;;) {
; 1563 :         /* Make sure that we always have enough lookahead, except
; 1564 :          * at the end of the input file. We need MAX_MATCH bytes
; 1565 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1566 :          * string following the next match.
; 1567 :          */
; 1568 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00015	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0001d	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00027	73 49		 jae	 SHORT $LN24@deflate_sl

; 1569 :             fill_window(s);

  00029	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00031	e8 00 00 00 00	 call	 fill_window

; 1570 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00036	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  0003e	41 81 bb 9c 00
	00 00 06 01 00
	00		 cmp	 DWORD PTR [r11+156], 262 ; 00000106H
  00049	73 11		 jae	 SHORT $LN23@deflate_sl
  0004b	83 bc 24 88 00
	00 00 00	 cmp	 DWORD PTR flush$[rsp], 0
  00053	75 07		 jne	 SHORT $LN23@deflate_sl

; 1571 :                 return need_more;

  00055	33 c0		 xor	 eax, eax
  00057	e9 1e 0c 00 00	 jmp	 $LN27@deflate_sl
$LN23@deflate_sl:

; 1572 :             }
; 1573 :             if (s->lookahead == 0) break; /* flush the current block */

  0005c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00064	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  0006b	75 05		 jne	 SHORT $LN22@deflate_sl
  0006d	e9 dc 09 00 00	 jmp	 $LN25@deflate_sl
$LN22@deflate_sl:
$LN24@deflate_sl:

; 1574 :         }
; 1575 : 
; 1576 :         /* Insert the string window[strstart .. strstart+2] in the
; 1577 :          * dictionary, and set hash_head to the head of the hash chain:
; 1578 :          */
; 1579 :         if (s->lookahead >= MIN_MATCH) {

  00072	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0007a	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  00081	0f 82 fd 00 00
	00		 jb	 $LN21@deflate_sl

; 1580 :             INSERT_STRING(s, s->strstart, hash_head);

  00087	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0008f	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00095	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0009d	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  000a0	d3 e2		 shl	 edx, cl
  000a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000aa	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  000b0	83 c0 02	 add	 eax, 2
  000b3	8b c8		 mov	 ecx, eax
  000b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000bd	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000c1	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000c5	8b ca		 mov	 ecx, edx
  000c7	33 c8		 xor	 ecx, eax
  000c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000d1	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  000d4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000dc	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  000df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  000e7	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  000eb	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  000f3	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  000f7	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  000ff	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00107	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0010a	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00110	23 c1		 and	 eax, ecx
  00112	8b d0		 mov	 edx, eax
  00114	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0011c	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00120	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  00125	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00129	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  00131	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00139	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0013c	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00142	23 c1		 and	 eax, ecx
  00144	8b c8		 mov	 ecx, eax
  00146	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0014e	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00152	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00156	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  0015a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00162	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00165	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0016d	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  00171	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00179	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  00180	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN21@deflate_sl:

; 1581 :         }
; 1582 : 
; 1583 :         /* Find the longest match, discarding those <= prev_length.
; 1584 :          */
; 1585 :         s->prev_length = s->match_length, s->prev_match = s->match_start;

  00184	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0018c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00194	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0019a	89 81 a0 00 00
	00		 mov	 DWORD PTR [rcx+160], eax
  001a0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001a8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001b0	8b 80 98 00 00
	00		 mov	 eax, DWORD PTR [rax+152]
  001b6	89 81 8c 00 00
	00		 mov	 DWORD PTR [rcx+140], eax

; 1586 :         s->match_length = MIN_MATCH-1;

  001bc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001c4	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1587 : 
; 1588 :         if (hash_head != NIL && s->prev_length < s->max_lazy_match &&
; 1589 :             s->strstart - hash_head <= MAX_DIST(s)) {

  001ce	83 7c 24 24 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  001d3	0f 84 4c 01 00
	00		 je	 $LN20@deflate_sl
  001d9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  001e1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  001e9	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  001ef	39 81 a0 00 00
	00		 cmp	 DWORD PTR [rcx+160], eax
  001f5	0f 83 2a 01 00
	00		 jae	 $LN20@deflate_sl
  001fb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00203	8b 44 24 24	 mov	 eax, DWORD PTR hash_head$[rsp]
  00207	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  0020d	2b c8		 sub	 ecx, eax
  0020f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00217	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  0021a	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  0021f	3b c8		 cmp	 ecx, eax
  00221	0f 87 fe 00 00
	00		 ja	 $LN20@deflate_sl

; 1590 :             /* To simplify the code, we prevent matches with the string
; 1591 :              * of window index 0 (in particular we have to avoid a match
; 1592 :              * of the string with itself at the start of the input file).
; 1593 :              */
; 1594 :             if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {

  00227	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0022f	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00236	74 36		 je	 SHORT $LN19@deflate_sl
  00238	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00240	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  00247	74 25		 je	 SHORT $LN19@deflate_sl

; 1595 :                 s->match_length = longest_match (s, hash_head);

  00249	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  0024d	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00255	e8 00 00 00 00	 call	 longest_match
  0025a	44 8b d8	 mov	 r11d, eax
  0025d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00265	44 89 98 88 00
	00 00		 mov	 DWORD PTR [rax+136], r11d
  0026c	eb 4d		 jmp	 SHORT $LN18@deflate_sl
$LN19@deflate_sl:

; 1596 :             } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {

  0026e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00276	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  0027d	75 3c		 jne	 SHORT $LN17@deflate_sl
  0027f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00287	8b 4c 24 24	 mov	 ecx, DWORD PTR hash_head$[rsp]
  0028b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00291	2b c1		 sub	 eax, ecx
  00293	83 f8 01	 cmp	 eax, 1
  00296	75 23		 jne	 SHORT $LN17@deflate_sl

; 1597 :                 s->match_length = longest_match_fast (s, hash_head);

  00298	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  0029c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  002a4	e8 00 00 00 00	 call	 longest_match_fast
  002a9	44 8b d8	 mov	 r11d, eax
  002ac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002b4	44 89 98 88 00
	00 00		 mov	 DWORD PTR [rax+136], r11d
$LN17@deflate_sl:
$LN18@deflate_sl:

; 1598 :             }
; 1599 :             /* longest_match() or longest_match_fast() sets match_start */
; 1600 : 
; 1601 :             if (s->match_length <= 5 && (s->strategy == Z_FILTERED
; 1602 : #if TOO_FAR <= 32767
; 1603 :                 || (s->match_length == MIN_MATCH &&
; 1604 :                     s->strstart - s->match_start > TOO_FAR)
; 1605 : #endif
; 1606 :                 )) {

  002bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002c3	83 b8 88 00 00
	00 05		 cmp	 DWORD PTR [rax+136], 5
  002ca	77 59		 ja	 SHORT $LN16@deflate_sl
  002cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002d4	83 b8 b0 00 00
	00 01		 cmp	 DWORD PTR [rax+176], 1
  002db	74 36		 je	 SHORT $LN15@deflate_sl
  002dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002e5	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  002ec	75 37		 jne	 SHORT $LN16@deflate_sl
  002ee	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  002f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  002fe	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [rax+152]
  00304	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  0030a	2b c1		 sub	 eax, ecx
  0030c	3d 00 10 00 00	 cmp	 eax, 4096		; 00001000H
  00311	76 12		 jbe	 SHORT $LN16@deflate_sl
$LN15@deflate_sl:

; 1607 : 
; 1608 :                 /* If prev_match is also MIN_MATCH, match_start is garbage
; 1609 :                  * but we will ignore the current match anyway.
; 1610 :                  */
; 1611 :                 s->match_length = MIN_MATCH-1;

  00313	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0031b	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2
$LN16@deflate_sl:
$LN20@deflate_sl:

; 1612 :             }
; 1613 :         }
; 1614 :         /* If there was a match at the previous step and the current
; 1615 :          * match is not better, output the previous match:
; 1616 :          */
; 1617 :         if (s->prev_length >= MIN_MATCH && s->match_length <= s->prev_length) {

  00325	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0032d	83 b8 a0 00 00
	00 03		 cmp	 DWORD PTR [rax+160], 3
  00334	0f 82 b3 04 00
	00		 jb	 $LN14@deflate_sl
  0033a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00342	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0034a	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  00350	39 81 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], eax
  00356	0f 87 91 04 00
	00		 ja	 $LN14@deflate_sl

; 1618 :             uInt max_insert = s->strstart + s->lookahead - MIN_MATCH;

  0035c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00364	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0036a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00372	8b 80 9c 00 00
	00		 mov	 eax, DWORD PTR [rax+156]
  00378	8d 44 01 fd	 lea	 eax, DWORD PTR [rcx+rax-3]
  0037c	89 44 24 28	 mov	 DWORD PTR max_insert$78724[rsp], eax

; 1619 :             /* Do not insert strings in hash table beyond this. */
; 1620 : 
; 1621 :             check_match(s, s->strstart-1, s->prev_match, s->prev_length);
; 1622 : 
; 1623 :             _tr_tally_dist(s, s->strstart -1 - s->prev_match,
; 1624 :                            s->prev_length - MIN_MATCH, bflush);

  00380	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00388	8b 80 a0 00 00
	00		 mov	 eax, DWORD PTR [rax+160]
  0038e	83 e8 03	 sub	 eax, 3
  00391	88 44 24 2c	 mov	 BYTE PTR len$78725[rsp], al
  00395	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0039d	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  003a3	83 e8 01	 sub	 eax, 1
  003a6	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003ae	2b 81 8c 00 00
	00		 sub	 eax, DWORD PTR [rcx+140]
  003b4	66 89 44 24 30	 mov	 WORD PTR dist$78726[rsp], ax
  003b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003c1	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  003c7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003cf	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  003d6	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78726[rsp]
  003db	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  003df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  003e7	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  003ed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  003f5	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  003fc	0f b6 44 24 2c	 movzx	 eax, BYTE PTR len$78725[rsp]
  00401	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00404	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0040c	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  00412	83 c1 01	 add	 ecx, 1
  00415	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0041d	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  00423	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78726[rsp]
  00428	66 83 e8 01	 sub	 ax, 1
  0042c	66 89 44 24 30	 mov	 WORD PTR dist$78726[rsp], ax
  00431	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR len$78725[rsp]
  00436	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  0043d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00441	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00446	48 63 c8	 movsxd	 rcx, eax
  00449	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00451	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00459	66 83 c2 01	 add	 dx, 1
  0045d	0f b6 4c 24 2c	 movzx	 ecx, BYTE PTR len$78725[rsp]
  00462	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  00469	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0046d	05 01 01 00 00	 add	 eax, 257		; 00000101H
  00472	48 63 c8	 movsxd	 rcx, eax
  00475	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0047d	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  00485	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78726[rsp]
  0048a	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  0048f	7d 16		 jge	 SHORT $LN29@deflate_sl
  00491	0f b7 4c 24 30	 movzx	 ecx, WORD PTR dist$78726[rsp]
  00496	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  0049d	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004a1	89 44 24 38	 mov	 DWORD PTR tv255[rsp], eax
  004a5	eb 1f		 jmp	 SHORT $LN30@deflate_sl
$LN29@deflate_sl:
  004a7	0f b7 44 24 30	 movzx	 eax, WORD PTR dist$78726[rsp]
  004ac	c1 f8 07	 sar	 eax, 7
  004af	05 00 01 00 00	 add	 eax, 256		; 00000100H
  004b4	48 63 c8	 movsxd	 rcx, eax
  004b7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  004be	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  004c2	89 44 24 38	 mov	 DWORD PTR tv255[rsp], eax
$LN30@deflate_sl:
  004c6	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tv255[rsp]
  004cb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004d3	0f b7 94 88 b0
	09 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+2480]
  004db	66 83 c2 01	 add	 dx, 1
  004df	48 63 4c 24 38	 movsxd	 rcx, DWORD PTR tv255[rsp]
  004e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004ec	66 89 94 88 b0
	09 00 00	 mov	 WORD PTR [rax+rcx*4+2480], dx
  004f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  004fc	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00502	83 e9 01	 sub	 ecx, 1
  00505	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0050d	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  00513	75 0a		 jne	 SHORT $LN31@deflate_sl
  00515	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv272[rsp], 1
  0051d	eb 08		 jmp	 SHORT $LN32@deflate_sl
$LN31@deflate_sl:
  0051f	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv272[rsp], 0
$LN32@deflate_sl:
  00527	8b 44 24 3c	 mov	 eax, DWORD PTR tv272[rsp]
  0052b	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1625 : 
; 1626 :             /* Insert in hash table all strings up to the end of the match.
; 1627 :              * strstart-1 and strstart are already inserted. If there is not
; 1628 :              * enough lookahead, the last two strings are not inserted in
; 1629 :              * the hash table.
; 1630 :              */
; 1631 :             s->lookahead -= s->prev_length-1;

  0052f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00537	8b 90 a0 00 00
	00		 mov	 edx, DWORD PTR [rax+160]
  0053d	83 ea 01	 sub	 edx, 1
  00540	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00548	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  0054e	2b ca		 sub	 ecx, edx
  00550	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00558	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1632 :             s->prev_length -= 2;

  0055e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00566	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  0056c	83 e9 02	 sub	 ecx, 2
  0056f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00577	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
$LN13@deflate_sl:

; 1633 :             do {
; 1634 :                 if (++s->strstart <= max_insert) {

  0057d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00585	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0058b	83 c1 01	 add	 ecx, 1
  0058e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00596	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
  0059c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  005a4	8b 44 24 28	 mov	 eax, DWORD PTR max_insert$78724[rsp]
  005a8	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  005ae	0f 87 fd 00 00
	00		 ja	 $LN10@deflate_sl

; 1635 :                     INSERT_STRING(s, s->strstart, hash_head);

  005b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005bc	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  005c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005ca	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  005cd	d3 e2		 shl	 edx, cl
  005cf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005d7	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  005dd	83 c0 02	 add	 eax, 2
  005e0	8b c8		 mov	 ecx, eax
  005e2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005ea	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  005ee	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  005f2	8b ca		 mov	 ecx, edx
  005f4	33 c8		 xor	 ecx, eax
  005f6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  005fe	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  00601	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00609	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  0060c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00614	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  00618	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR s$[rsp]
  00620	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  00624	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0062c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00634	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00637	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  0063d	23 c1		 and	 eax, ecx
  0063f	8b d0		 mov	 edx, eax
  00641	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00649	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  0064d	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  00652	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00656	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR s$[rsp]
  0065e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00666	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00669	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  0066f	23 c1		 and	 eax, ecx
  00671	8b c8		 mov	 ecx, eax
  00673	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0067b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0067f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  00683	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  00687	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0068f	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00692	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0069a	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0069e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006a6	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  006ad	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN10@deflate_sl:

; 1636 :                 }
; 1637 :             } while (--s->prev_length != 0);

  006b1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006b9	8b 88 a0 00 00
	00		 mov	 ecx, DWORD PTR [rax+160]
  006bf	83 e9 01	 sub	 ecx, 1
  006c2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ca	89 88 a0 00 00
	00		 mov	 DWORD PTR [rax+160], ecx
  006d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006d8	83 b8 a0 00 00
	00 00		 cmp	 DWORD PTR [rax+160], 0
  006df	0f 85 98 fe ff
	ff		 jne	 $LN13@deflate_sl

; 1638 :             s->match_available = 0;

  006e5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ed	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0

; 1639 :             s->match_length = MIN_MATCH-1;

  006f7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  006ff	c7 80 88 00 00
	00 02 00 00 00	 mov	 DWORD PTR [rax+136], 2

; 1640 :             s->strstart++;

  00709	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00711	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00717	83 c1 01	 add	 ecx, 1
  0071a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00722	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1641 : 
; 1642 :             if (bflush) FLUSH_BLOCK(s, 0);

  00728	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  0072d	0f 84 b5 00 00
	00		 je	 $LN9@deflate_sl
  00733	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0073b	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00742	7c 21		 jl	 SHORT $LN33@deflate_sl
  00744	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0074c	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00752	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0075a	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0075e	48 89 44 24 40	 mov	 QWORD PTR tv348[rsp], rax
  00763	eb 09		 jmp	 SHORT $LN34@deflate_sl
$LN33@deflate_sl:
  00765	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv348[rsp], 0
$LN34@deflate_sl:
  0076e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00776	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0077e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00784	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0078b	44 2b c0	 sub	 r8d, eax
  0078e	45 33 c9	 xor	 r9d, r9d
  00791	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv348[rsp]
  00796	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0079e	e8 00 00 00 00	 call	 _tr_flush_block
  007a3	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  007ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007b3	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007b9	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  007c0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  007c8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007cb	e8 00 00 00 00	 call	 flush_pending
  007d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007d8	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007db	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  007df	75 07		 jne	 SHORT $LN8@deflate_sl
  007e1	33 c0		 xor	 eax, eax
  007e3	e9 92 04 00 00	 jmp	 $LN27@deflate_sl
$LN8@deflate_sl:
$LN9@deflate_sl:
  007e8	e9 5c 02 00 00	 jmp	 $LN7@deflate_sl
$LN14@deflate_sl:

; 1643 : 
; 1644 :         } else if (s->match_available) {

  007ed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  007f5	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  007fc	0f 84 f7 01 00
	00		 je	 $LN6@deflate_sl

; 1645 :             /* If there was no match at the previous position, output a
; 1646 :              * single literal. If there was a match but the current match
; 1647 :              * is longer, truncate the previous match to a single literal.
; 1648 :              */
; 1649 :             Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1650 :             _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00802	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0080a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00810	83 e8 01	 sub	 eax, 1
  00813	8b c8		 mov	 ecx, eax
  00815	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0081d	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00821	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00825	88 44 24 34	 mov	 BYTE PTR cc$78741[rsp], al
  00829	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00831	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00837	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0083f	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00846	33 c0		 xor	 eax, eax
  00848	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0084c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00854	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  0085a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00862	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00869	0f b6 44 24 34	 movzx	 eax, BYTE PTR cc$78741[rsp]
  0086e	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00871	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00879	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  0087f	83 c1 01	 add	 ecx, 1
  00882	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0088a	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  00890	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$78741[rsp]
  00895	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0089d	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  008a5	66 83 c2 01	 add	 dx, 1
  008a9	0f b6 4c 24 34	 movzx	 ecx, BYTE PTR cc$78741[rsp]
  008ae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008b6	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  008be	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008c6	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  008cc	83 e9 01	 sub	 ecx, 1
  008cf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  008d7	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  008dd	75 0a		 jne	 SHORT $LN35@deflate_sl
  008df	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv392[rsp], 1
  008e7	eb 08		 jmp	 SHORT $LN36@deflate_sl
$LN35@deflate_sl:
  008e9	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv392[rsp], 0
$LN36@deflate_sl:
  008f1	8b 44 24 48	 mov	 eax, DWORD PTR tv392[rsp]
  008f5	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1651 :             if (bflush) {

  008f9	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  008fe	0f 84 9d 00 00
	00		 je	 $LN5@deflate_sl

; 1652 :                 FLUSH_BLOCK_ONLY(s, 0);

  00904	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0090c	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00913	7c 21		 jl	 SHORT $LN37@deflate_sl
  00915	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0091d	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00923	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0092b	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0092f	48 89 44 24 50	 mov	 QWORD PTR tv405[rsp], rax
  00934	eb 09		 jmp	 SHORT $LN38@deflate_sl
$LN37@deflate_sl:
  00936	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv405[rsp], 0
$LN38@deflate_sl:
  0093f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00947	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  0094f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00955	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0095c	44 2b c0	 sub	 r8d, eax
  0095f	45 33 c9	 xor	 r9d, r9d
  00962	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv405[rsp]
  00967	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  0096f	e8 00 00 00 00	 call	 _tr_flush_block
  00974	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  0097c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00984	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0098a	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00991	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00999	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0099c	e8 00 00 00 00	 call	 flush_pending
$LN5@deflate_sl:

; 1653 :             }
; 1654 :             s->strstart++;

  009a1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009a9	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  009af	83 c1 01	 add	 ecx, 1
  009b2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009ba	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1655 :             s->lookahead--;

  009c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009c8	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  009ce	83 e9 01	 sub	 ecx, 1
  009d1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009d9	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1656 :             if (s->strm->avail_out == 0) return need_more;

  009df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  009e7	48 8b 00	 mov	 rax, QWORD PTR [rax]
  009ea	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  009ee	75 07		 jne	 SHORT $LN4@deflate_sl
  009f0	33 c0		 xor	 eax, eax
  009f2	e9 83 02 00 00	 jmp	 $LN27@deflate_sl
$LN4@deflate_sl:

; 1657 :         } else {

  009f7	eb 50		 jmp	 SHORT $LN3@deflate_sl
$LN6@deflate_sl:

; 1658 :             /* There is no previous match to compare with, wait for
; 1659 :              * the next step to decide.
; 1660 :              */
; 1661 :             s->match_available = 1;

  009f9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a01	c7 80 90 00 00
	00 01 00 00 00	 mov	 DWORD PTR [rax+144], 1

; 1662 :             s->strstart++;

  00a0b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a13	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00a19	83 c1 01	 add	 ecx, 1
  00a1c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a24	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1663 :             s->lookahead--;

  00a2a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a32	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00a38	83 e9 01	 sub	 ecx, 1
  00a3b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a43	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx
$LN3@deflate_sl:
$LN7@deflate_sl:

; 1664 :         }
; 1665 :     }

  00a49	e9 c7 f5 ff ff	 jmp	 $LN26@deflate_sl
$LN25@deflate_sl:

; 1666 :     Assert (flush != Z_NO_FLUSH, "no flush?");
; 1667 :     if (s->match_available) {

  00a4e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a56	83 b8 90 00 00
	00 00		 cmp	 DWORD PTR [rax+144], 0
  00a5d	0f 84 09 01 00
	00		 je	 $LN2@deflate_sl

; 1668 :         Tracevv((stderr,"%c", s->window[s->strstart-1]));
; 1669 :         _tr_tally_lit(s, s->window[s->strstart-1], bflush);

  00a63	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a6b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00a71	83 e8 01	 sub	 eax, 1
  00a74	8b c8		 mov	 ecx, eax
  00a76	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a7e	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00a82	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  00a86	88 44 24 35	 mov	 BYTE PTR cc$78751[rsp], al
  00a8a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00a92	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00a98	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00aa0	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00aa7	33 c0		 xor	 eax, eax
  00aa9	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00aad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ab5	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00abb	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00ac3	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00aca	0f b6 44 24 35	 movzx	 eax, BYTE PTR cc$78751[rsp]
  00acf	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00ad2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ada	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  00ae0	83 c1 01	 add	 ecx, 1
  00ae3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00aeb	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  00af1	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR cc$78751[rsp]
  00af6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00afe	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  00b06	66 83 c2 01	 add	 dx, 1
  00b0a	0f b6 4c 24 35	 movzx	 ecx, BYTE PTR cc$78751[rsp]
  00b0f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b17	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  00b1f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b27	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00b2d	83 e9 01	 sub	 ecx, 1
  00b30	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b38	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  00b3e	75 0a		 jne	 SHORT $LN39@deflate_sl
  00b40	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR tv466[rsp], 1
  00b48	eb 08		 jmp	 SHORT $LN40@deflate_sl
$LN39@deflate_sl:
  00b4a	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv466[rsp], 0
$LN40@deflate_sl:
  00b52	8b 44 24 58	 mov	 eax, DWORD PTR tv466[rsp]
  00b56	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1670 :         s->match_available = 0;

  00b5a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b62	c7 80 90 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+144], 0
$LN2@deflate_sl:

; 1671 :     }
; 1672 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00b6c	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00b74	75 0a		 jne	 SHORT $LN41@deflate_sl
  00b76	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv469[rsp], 1
  00b7e	eb 08		 jmp	 SHORT $LN42@deflate_sl
$LN41@deflate_sl:
  00b80	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR tv469[rsp], 0
$LN42@deflate_sl:
  00b88	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00b90	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00b97	7c 21		 jl	 SHORT $LN43@deflate_sl
  00b99	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00ba1	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00ba7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00baf	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00bb3	48 89 44 24 60	 mov	 QWORD PTR tv481[rsp], rax
  00bb8	eb 09		 jmp	 SHORT $LN44@deflate_sl
$LN43@deflate_sl:
  00bba	48 c7 44 24 60
	00 00 00 00	 mov	 QWORD PTR tv481[rsp], 0
$LN44@deflate_sl:
  00bc3	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bcb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00bd3	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00bd9	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00be0	44 2b c0	 sub	 r8d, eax
  00be3	44 8b 4c 24 5c	 mov	 r9d, DWORD PTR tv469[rsp]
  00be8	48 8b 54 24 60	 mov	 rdx, QWORD PTR tv481[rsp]
  00bed	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00bf5	e8 00 00 00 00	 call	 _tr_flush_block
  00bfa	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR s$[rsp]
  00c02	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c0a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00c10	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00c17	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR s$[rsp]
  00c1f	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00c22	e8 00 00 00 00	 call	 flush_pending
  00c27	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR s$[rsp]
  00c2f	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00c32	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00c36	75 22		 jne	 SHORT $LN1@deflate_sl
  00c38	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00c40	75 0a		 jne	 SHORT $LN45@deflate_sl
  00c42	c7 44 24 68 02
	00 00 00	 mov	 DWORD PTR tv490[rsp], 2
  00c4a	eb 08		 jmp	 SHORT $LN46@deflate_sl
$LN45@deflate_sl:
  00c4c	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR tv490[rsp], 0
$LN46@deflate_sl:
  00c54	8b 44 24 68	 mov	 eax, DWORD PTR tv490[rsp]
  00c58	eb 20		 jmp	 SHORT $LN27@deflate_sl
$LN1@deflate_sl:

; 1673 :     return flush == Z_FINISH ? finish_done : block_done;

  00c5a	83 bc 24 88 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  00c62	75 0a		 jne	 SHORT $LN47@deflate_sl
  00c64	c7 44 24 6c 03
	00 00 00	 mov	 DWORD PTR tv492[rsp], 3
  00c6c	eb 08		 jmp	 SHORT $LN48@deflate_sl
$LN47@deflate_sl:
  00c6e	c7 44 24 6c 01
	00 00 00	 mov	 DWORD PTR tv492[rsp], 1
$LN48@deflate_sl:
  00c76	8b 44 24 6c	 mov	 eax, DWORD PTR tv492[rsp]
$LN27@deflate_sl:

; 1674 : }

  00c7a	48 83 c4 78	 add	 rsp, 120		; 00000078H
  00c7e	c3		 ret	 0
deflate_slow ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_fast DD imagerel deflate_fast
	DD	imagerel deflate_fast+2111
	DD	imagerel $unwind$deflate_fast
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_fast DD 010d01H
	DD	0c20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_fast
_TEXT	SEGMENT
bflush$ = 32
hash_head$ = 36
len$78680 = 40
dist$78681 = 44
cc$78689 = 48
tv228 = 52
tv245 = 56
tv368 = 60
tv389 = 64
tv398 = 72
tv410 = 80
tv419 = 88
tv421 = 92
s$ = 112
flush$ = 120
deflate_fast PROC					; COMDAT

; 1451 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 68	 sub	 rsp, 104		; 00000068H

; 1452 :     IPos hash_head = NIL; /* head of the hash chain */

  0000d	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR hash_head$[rsp], 0
$LN20@deflate_fa:

; 1453 :     int bflush;           /* set if current block must be flushed */
; 1454 : 
; 1455 :     for (;;) {
; 1456 :         /* Make sure that we always have enough lookahead, except
; 1457 :          * at the end of the input file. We need MAX_MATCH bytes
; 1458 :          * for the next match, plus MIN_MATCH bytes to insert the
; 1459 :          * string following the next match.
; 1460 :          */
; 1461 :         if (s->lookahead < MIN_LOOKAHEAD) {

  00015	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0001a	81 b8 9c 00 00
	00 06 01 00 00	 cmp	 DWORD PTR [rax+156], 262 ; 00000106H
  00024	73 3d		 jae	 SHORT $LN18@deflate_fa

; 1462 :             fill_window(s);

  00026	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0002b	e8 00 00 00 00	 call	 fill_window

; 1463 :             if (s->lookahead < MIN_LOOKAHEAD && flush == Z_NO_FLUSH) {

  00030	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  00035	41 81 bb 9c 00
	00 00 06 01 00
	00		 cmp	 DWORD PTR [r11+156], 262 ; 00000106H
  00040	73 0e		 jae	 SHORT $LN17@deflate_fa
  00042	83 7c 24 78 00	 cmp	 DWORD PTR flush$[rsp], 0
  00047	75 07		 jne	 SHORT $LN17@deflate_fa

; 1464 :                 return need_more;

  00049	33 c0		 xor	 eax, eax
  0004b	e9 ea 07 00 00	 jmp	 $LN21@deflate_fa
$LN17@deflate_fa:

; 1465 :             }
; 1466 :             if (s->lookahead == 0) break; /* flush the current block */

  00050	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00055	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  0005c	75 05		 jne	 SHORT $LN16@deflate_fa
  0005e	e9 f0 06 00 00	 jmp	 $LN19@deflate_fa
$LN16@deflate_fa:
$LN18@deflate_fa:

; 1467 :         }
; 1468 : 
; 1469 :         /* Insert the string window[strstart .. strstart+2] in the
; 1470 :          * dictionary, and set hash_head to the head of the hash chain:
; 1471 :          */
; 1472 :         if (s->lookahead >= MIN_MATCH) {

  00063	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00068	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  0006f	0f 82 ca 00 00
	00		 jb	 $LN15@deflate_fa

; 1473 :             INSERT_STRING(s, s->strstart, hash_head);

  00075	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0007a	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00080	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00085	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00088	d3 e2		 shl	 edx, cl
  0008a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0008f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00095	83 c0 02	 add	 eax, 2
  00098	8b c8		 mov	 ecx, eax
  0009a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0009f	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  000a3	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  000a7	8b ca		 mov	 ecx, edx
  000a9	33 c8		 xor	 ecx, eax
  000ab	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b0	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  000b3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000b8	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  000bb	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000c0	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  000c4	4c 8b 44 24 70	 mov	 r8, QWORD PTR s$[rsp]
  000c9	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  000cd	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  000d2	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  000d7	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  000da	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  000e0	23 c1		 and	 eax, ecx
  000e2	8b d0		 mov	 edx, eax
  000e4	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  000e9	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  000ed	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  000f2	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  000f6	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  000fb	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00100	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00103	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00109	23 c1		 and	 eax, ecx
  0010b	8b c8		 mov	 ecx, eax
  0010d	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00112	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00116	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  0011a	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  0011e	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00123	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00126	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0012b	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  0012f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00134	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  0013b	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
$LN15@deflate_fa:

; 1474 :         }
; 1475 : 
; 1476 :         /* Find the longest match, discarding those <= prev_length.
; 1477 :          * At this point we have always match_length < MIN_MATCH
; 1478 :          */
; 1479 :         if (hash_head != NIL && s->strstart - hash_head <= MAX_DIST(s)) {

  0013f	83 7c 24 24 00	 cmp	 DWORD PTR hash_head$[rsp], 0
  00144	0f 84 9e 00 00
	00		 je	 $LN14@deflate_fa
  0014a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0014f	8b 44 24 24	 mov	 eax, DWORD PTR hash_head$[rsp]
  00153	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  00159	2b c8		 sub	 ecx, eax
  0015b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00160	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  00163	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  00168	3b c8		 cmp	 ecx, eax
  0016a	77 7c		 ja	 SHORT $LN14@deflate_fa

; 1480 :             /* To simplify the code, we prevent matches with the string
; 1481 :              * of window index 0 (in particular we have to avoid a match
; 1482 :              * of the string with itself at the start of the input file).
; 1483 :              */
; 1484 : #ifdef FASTEST
; 1485 :             if ((s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) ||
; 1486 :                 (s->strategy == Z_RLE && s->strstart - hash_head == 1)) {
; 1487 :                 s->match_length = longest_match_fast (s, hash_head);
; 1488 :             }
; 1489 : #else
; 1490 :             if (s->strategy != Z_HUFFMAN_ONLY && s->strategy != Z_RLE) {

  0016c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00171	83 b8 b0 00 00
	00 02		 cmp	 DWORD PTR [rax+176], 2
  00178	74 2d		 je	 SHORT $LN13@deflate_fa
  0017a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0017f	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  00186	74 1f		 je	 SHORT $LN13@deflate_fa

; 1491 :                 s->match_length = longest_match (s, hash_head);

  00188	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  0018c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00191	e8 00 00 00 00	 call	 longest_match
  00196	44 8b d8	 mov	 r11d, eax
  00199	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0019e	44 89 98 88 00
	00 00		 mov	 DWORD PTR [rax+136], r11d
  001a5	eb 41		 jmp	 SHORT $LN12@deflate_fa
$LN13@deflate_fa:

; 1492 :             } else if (s->strategy == Z_RLE && s->strstart - hash_head == 1) {

  001a7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001ac	83 b8 b0 00 00
	00 03		 cmp	 DWORD PTR [rax+176], 3
  001b3	75 33		 jne	 SHORT $LN11@deflate_fa
  001b5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001ba	8b 4c 24 24	 mov	 ecx, DWORD PTR hash_head$[rsp]
  001be	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  001c4	2b c1		 sub	 eax, ecx
  001c6	83 f8 01	 cmp	 eax, 1
  001c9	75 1d		 jne	 SHORT $LN11@deflate_fa

; 1493 :                 s->match_length = longest_match_fast (s, hash_head);

  001cb	8b 54 24 24	 mov	 edx, DWORD PTR hash_head$[rsp]
  001cf	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  001d4	e8 00 00 00 00	 call	 longest_match_fast
  001d9	44 8b d8	 mov	 r11d, eax
  001dc	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001e1	44 89 98 88 00
	00 00		 mov	 DWORD PTR [rax+136], r11d
$LN11@deflate_fa:
$LN12@deflate_fa:
$LN14@deflate_fa:

; 1494 :             }
; 1495 : #endif
; 1496 :             /* longest_match() or longest_match_fast() sets match_start */
; 1497 :         }
; 1498 :         if (s->match_length >= MIN_MATCH) {

  001e8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001ed	83 b8 88 00 00
	00 03		 cmp	 DWORD PTR [rax+136], 3
  001f4	0f 82 b2 03 00
	00		 jb	 $LN10@deflate_fa

; 1499 :             check_match(s, s->strstart, s->match_start, s->match_length);
; 1500 : 
; 1501 :             _tr_tally_dist(s, s->strstart - s->match_start,
; 1502 :                            s->match_length - MIN_MATCH, bflush);

  001fa	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  001ff	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  00205	83 e8 03	 sub	 eax, 3
  00208	88 44 24 28	 mov	 BYTE PTR len$78680[rsp], al
  0020c	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  00211	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00216	8b 88 98 00 00
	00		 mov	 ecx, DWORD PTR [rax+152]
  0021c	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00222	2b c1		 sub	 eax, ecx
  00224	66 89 44 24 2c	 mov	 WORD PTR dist$78681[rsp], ax
  00229	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0022e	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00234	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00239	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  00240	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78681[rsp]
  00245	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  00249	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0024e	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  00254	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00259	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  00260	0f b6 44 24 28	 movzx	 eax, BYTE PTR len$78680[rsp]
  00265	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00268	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0026d	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  00273	83 c1 01	 add	 ecx, 1
  00276	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0027b	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  00281	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78681[rsp]
  00286	66 83 e8 01	 sub	 ax, 1
  0028a	66 89 44 24 2c	 mov	 WORD PTR dist$78681[rsp], ax
  0028f	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR len$78680[rsp]
  00294	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  0029b	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0029f	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002a4	48 63 c8	 movsxd	 rcx, eax
  002a7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002ac	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  002b4	66 83 c2 01	 add	 dx, 1
  002b8	0f b6 4c 24 28	 movzx	 ecx, BYTE PTR len$78680[rsp]
  002bd	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_length_code
  002c4	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002c8	05 01 01 00 00	 add	 eax, 257		; 00000101H
  002cd	48 63 c8	 movsxd	 rcx, eax
  002d0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  002d5	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  002dd	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78681[rsp]
  002e2	3d 00 01 00 00	 cmp	 eax, 256		; 00000100H
  002e7	7d 16		 jge	 SHORT $LN23@deflate_fa
  002e9	0f b7 4c 24 2c	 movzx	 ecx, WORD PTR dist$78681[rsp]
  002ee	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  002f5	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  002f9	89 44 24 34	 mov	 DWORD PTR tv228[rsp], eax
  002fd	eb 1f		 jmp	 SHORT $LN24@deflate_fa
$LN23@deflate_fa:
  002ff	0f b7 44 24 2c	 movzx	 eax, WORD PTR dist$78681[rsp]
  00304	c1 f8 07	 sar	 eax, 7
  00307	05 00 01 00 00	 add	 eax, 256		; 00000100H
  0030c	48 63 c8	 movsxd	 rcx, eax
  0030f	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:_dist_code
  00316	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0031a	89 44 24 34	 mov	 DWORD PTR tv228[rsp], eax
$LN24@deflate_fa:
  0031e	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR tv228[rsp]
  00323	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00328	0f b7 94 88 b0
	09 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+2480]
  00330	66 83 c2 01	 add	 dx, 1
  00334	48 63 4c 24 34	 movsxd	 rcx, DWORD PTR tv228[rsp]
  00339	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0033e	66 89 94 88 b0
	09 00 00	 mov	 WORD PTR [rax+rcx*4+2480], dx
  00346	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0034b	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00351	83 e9 01	 sub	 ecx, 1
  00354	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00359	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  0035f	75 0a		 jne	 SHORT $LN25@deflate_fa
  00361	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv245[rsp], 1
  00369	eb 08		 jmp	 SHORT $LN26@deflate_fa
$LN25@deflate_fa:
  0036b	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv245[rsp], 0
$LN26@deflate_fa:
  00373	8b 44 24 38	 mov	 eax, DWORD PTR tv245[rsp]
  00377	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1503 : 
; 1504 :             s->lookahead -= s->match_length;

  0037b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00380	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00385	8b 80 88 00 00
	00		 mov	 eax, DWORD PTR [rax+136]
  0038b	8b 89 9c 00 00
	00		 mov	 ecx, DWORD PTR [rcx+156]
  00391	2b c8		 sub	 ecx, eax
  00393	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00398	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1505 : 
; 1506 :             /* Insert new strings in the hash table only if the match length
; 1507 :              * is not too large. This saves time but degrades compression.
; 1508 :              */
; 1509 : #ifndef FASTEST
; 1510 :             if (s->match_length <= s->max_insert_length &&
; 1511 :                 s->lookahead >= MIN_MATCH) {

  0039e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  003a3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003a8	8b 80 a8 00 00
	00		 mov	 eax, DWORD PTR [rax+168]
  003ae	39 81 88 00 00
	00		 cmp	 DWORD PTR [rcx+136], eax
  003b4	0f 87 57 01 00
	00		 ja	 $LN9@deflate_fa
  003ba	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003bf	83 b8 9c 00 00
	00 03		 cmp	 DWORD PTR [rax+156], 3
  003c6	0f 82 45 01 00
	00		 jb	 $LN9@deflate_fa

; 1512 :                 s->match_length--; /* string at strstart already in table */

  003cc	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003d1	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  003d7	83 e9 01	 sub	 ecx, 1
  003da	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003df	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
$LN8@deflate_fa:

; 1513 :                 do {
; 1514 :                     s->strstart++;

  003e5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003ea	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  003f0	83 c1 01	 add	 ecx, 1
  003f3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  003f8	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1515 :                     INSERT_STRING(s, s->strstart, hash_head);

  003fe	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00403	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  00409	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0040e	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00411	d3 e2		 shl	 edx, cl
  00413	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00418	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0041e	83 c0 02	 add	 eax, 2
  00421	8b c8		 mov	 ecx, eax
  00423	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00428	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0042c	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00430	8b ca		 mov	 ecx, edx
  00432	33 c8		 xor	 ecx, eax
  00434	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00439	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  0043c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00441	89 48 70	 mov	 DWORD PTR [rax+112], ecx
  00444	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00449	44 8b 48 70	 mov	 r9d, DWORD PTR [rax+112]
  0044d	4c 8b 44 24 70	 mov	 r8, QWORD PTR s$[rsp]
  00452	4d 8b 40 68	 mov	 r8, QWORD PTR [r8+104]
  00456	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  0045b	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00460	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  00463	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00469	23 c1		 and	 eax, ecx
  0046b	8b d0		 mov	 edx, eax
  0046d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00472	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00476	43 0f b7 04 48	 movzx	 eax, WORD PTR [r8+r9*2]
  0047b	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  0047f	48 8b 54 24 70	 mov	 rdx, QWORD PTR s$[rsp]
  00484	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00489	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  0048c	8b 82 94 00 00
	00		 mov	 eax, DWORD PTR [rdx+148]
  00492	23 c1		 and	 eax, ecx
  00494	8b c8		 mov	 ecx, eax
  00496	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0049b	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  0049f	0f b7 04 48	 movzx	 eax, WORD PTR [rax+rcx*2]
  004a3	89 44 24 24	 mov	 DWORD PTR hash_head$[rsp], eax
  004a7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004ac	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  004af	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  004b4	48 8b 49 68	 mov	 rcx, QWORD PTR [rcx+104]
  004b8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004bd	0f b7 80 94 00
	00 00		 movzx	 eax, WORD PTR [rax+148]
  004c4	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax

; 1516 :                     /* strstart never exceeds WSIZE-MAX_MATCH, so there are
; 1517 :                      * always MIN_MATCH bytes ahead.
; 1518 :                      */
; 1519 :                 } while (--s->match_length != 0);

  004c8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004cd	8b 88 88 00 00
	00		 mov	 ecx, DWORD PTR [rax+136]
  004d3	83 e9 01	 sub	 ecx, 1
  004d6	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004db	89 88 88 00 00
	00		 mov	 DWORD PTR [rax+136], ecx
  004e1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004e6	83 b8 88 00 00
	00 00		 cmp	 DWORD PTR [rax+136], 0
  004ed	0f 85 f2 fe ff
	ff		 jne	 $LN8@deflate_fa

; 1520 :                 s->strstart++;

  004f3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  004f8	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  004fe	83 c1 01	 add	 ecx, 1
  00501	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00506	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1521 :             } else

  0050c	e9 96 00 00 00	 jmp	 $LN5@deflate_fa
$LN9@deflate_fa:

; 1522 : #endif
; 1523 :             {
; 1524 :                 s->strstart += s->match_length;

  00511	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00516	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0051c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00521	03 88 88 00 00
	00		 add	 ecx, DWORD PTR [rax+136]
  00527	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0052c	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1525 :                 s->match_length = 0;

  00532	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00537	c7 80 88 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+136], 0

; 1526 :                 s->ins_h = s->window[s->strstart];

  00541	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00546	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0054c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00551	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  00555	0f b6 0c 08	 movzx	 ecx, BYTE PTR [rax+rcx]
  00559	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0055e	89 48 70	 mov	 DWORD PTR [rax+112], ecx

; 1527 :                 UPDATE_HASH(s, s->ins_h, s->window[s->strstart+1]);

  00561	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00566	8b 88 80 00 00
	00		 mov	 ecx, DWORD PTR [rax+128]
  0056c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00571	8b 50 70	 mov	 edx, DWORD PTR [rax+112]
  00574	d3 e2		 shl	 edx, cl
  00576	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0057b	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00581	83 c0 01	 add	 eax, 1
  00584	8b c8		 mov	 ecx, eax
  00586	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0058b	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  0058f	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00593	8b ca		 mov	 ecx, edx
  00595	33 c8		 xor	 ecx, eax
  00597	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0059c	23 48 7c	 and	 ecx, DWORD PTR [rax+124]
  0059f	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005a4	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN5@deflate_fa:

; 1528 : #if MIN_MATCH != 3
; 1529 :                 Call UPDATE_HASH() MIN_MATCH-3 more times
; 1530 : #endif
; 1531 :                 /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not
; 1532 :                  * matter since it will be recomputed at next deflate call.
; 1533 :                  */
; 1534 :             }
; 1535 :         } else {

  005a7	e9 00 01 00 00	 jmp	 $LN4@deflate_fa
$LN10@deflate_fa:

; 1536 :             /* No match, output a literal byte */
; 1537 :             Tracevv((stderr,"%c", s->window[s->strstart]));
; 1538 :             _tr_tally_lit (s, s->window[s->strstart], bflush);

  005ac	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005b1	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  005b7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005bc	48 8b 40 50	 mov	 rax, QWORD PTR [rax+80]
  005c0	0f b6 04 01	 movzx	 eax, BYTE PTR [rcx+rax]
  005c4	88 44 24 30	 mov	 BYTE PTR cc$78689[rsp], al
  005c8	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005cd	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  005d3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  005d8	48 8b 89 f8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5880]
  005df	33 c0		 xor	 eax, eax
  005e1	66 89 04 51	 mov	 WORD PTR [rcx+rdx*2], ax
  005e5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  005ea	8b 90 f4 16 00
	00		 mov	 edx, DWORD PTR [rax+5876]
  005f0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  005f5	48 8b 89 e8 16
	00 00		 mov	 rcx, QWORD PTR [rcx+5864]
  005fc	0f b6 44 24 30	 movzx	 eax, BYTE PTR cc$78689[rsp]
  00601	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00604	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00609	8b 88 f4 16 00
	00		 mov	 ecx, DWORD PTR [rax+5876]
  0060f	83 c1 01	 add	 ecx, 1
  00612	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00617	89 88 f4 16 00
	00		 mov	 DWORD PTR [rax+5876], ecx
  0061d	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR cc$78689[rsp]
  00622	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00627	0f b7 94 88 bc
	00 00 00	 movzx	 edx, WORD PTR [rax+rcx*4+188]
  0062f	66 83 c2 01	 add	 dx, 1
  00633	0f b6 4c 24 30	 movzx	 ecx, BYTE PTR cc$78689[rsp]
  00638	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0063d	66 89 94 88 bc
	00 00 00	 mov	 WORD PTR [rax+rcx*4+188], dx
  00645	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0064a	8b 88 f0 16 00
	00		 mov	 ecx, DWORD PTR [rax+5872]
  00650	83 e9 01	 sub	 ecx, 1
  00653	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00658	39 88 f4 16 00
	00		 cmp	 DWORD PTR [rax+5876], ecx
  0065e	75 0a		 jne	 SHORT $LN27@deflate_fa
  00660	c7 44 24 3c 01
	00 00 00	 mov	 DWORD PTR tv368[rsp], 1
  00668	eb 08		 jmp	 SHORT $LN28@deflate_fa
$LN27@deflate_fa:
  0066a	c7 44 24 3c 00
	00 00 00	 mov	 DWORD PTR tv368[rsp], 0
$LN28@deflate_fa:
  00672	8b 44 24 3c	 mov	 eax, DWORD PTR tv368[rsp]
  00676	89 44 24 20	 mov	 DWORD PTR bflush$[rsp], eax

; 1539 :             s->lookahead--;

  0067a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0067f	8b 88 9c 00 00
	00		 mov	 ecx, DWORD PTR [rax+156]
  00685	83 e9 01	 sub	 ecx, 1
  00688	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0068d	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1540 :             s->strstart++;

  00693	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00698	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  0069e	83 c1 01	 add	 ecx, 1
  006a1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  006a6	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx
$LN4@deflate_fa:

; 1541 :         }
; 1542 :         if (bflush) FLUSH_BLOCK(s, 0);

  006ac	83 7c 24 20 00	 cmp	 DWORD PTR bflush$[rsp], 0
  006b1	0f 84 97 00 00
	00		 je	 $LN3@deflate_fa
  006b7	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  006bc	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  006c3	7c 1b		 jl	 SHORT $LN29@deflate_fa
  006c5	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  006ca	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  006d0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  006d5	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  006d9	48 89 44 24 40	 mov	 QWORD PTR tv389[rsp], rax
  006de	eb 09		 jmp	 SHORT $LN30@deflate_fa
$LN29@deflate_fa:
  006e0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv389[rsp], 0
$LN30@deflate_fa:
  006e9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  006ee	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  006f3	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  006f9	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00700	44 2b c0	 sub	 r8d, eax
  00703	45 33 c9	 xor	 r9d, r9d
  00706	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv389[rsp]
  0070b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00710	e8 00 00 00 00	 call	 _tr_flush_block
  00715	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  0071a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0071f	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00725	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  0072c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  00731	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00734	e8 00 00 00 00	 call	 flush_pending
  00739	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0073e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00741	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00745	75 07		 jne	 SHORT $LN2@deflate_fa
  00747	33 c0		 xor	 eax, eax
  00749	e9 ec 00 00 00	 jmp	 $LN21@deflate_fa
$LN2@deflate_fa:
$LN3@deflate_fa:

; 1543 :     }

  0074e	e9 c2 f8 ff ff	 jmp	 $LN20@deflate_fa
$LN19@deflate_fa:

; 1544 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  00753	83 7c 24 78 04	 cmp	 DWORD PTR flush$[rsp], 4
  00758	75 0a		 jne	 SHORT $LN31@deflate_fa
  0075a	c7 44 24 48 01
	00 00 00	 mov	 DWORD PTR tv398[rsp], 1
  00762	eb 08		 jmp	 SHORT $LN32@deflate_fa
$LN31@deflate_fa:
  00764	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv398[rsp], 0
$LN32@deflate_fa:
  0076c	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  00771	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00778	7c 1b		 jl	 SHORT $LN33@deflate_fa
  0077a	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  0077f	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00785	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  0078a	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  0078e	48 89 44 24 50	 mov	 QWORD PTR tv410[rsp], rax
  00793	eb 09		 jmp	 SHORT $LN34@deflate_fa
$LN33@deflate_fa:
  00795	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR tv410[rsp], 0
$LN34@deflate_fa:
  0079e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  007a3	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  007a8	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  007ae	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  007b5	44 2b c0	 sub	 r8d, eax
  007b8	44 8b 4c 24 48	 mov	 r9d, DWORD PTR tv398[rsp]
  007bd	48 8b 54 24 50	 mov	 rdx, QWORD PTR tv410[rsp]
  007c2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  007c7	e8 00 00 00 00	 call	 _tr_flush_block
  007cc	4c 8b 5c 24 70	 mov	 r11, QWORD PTR s$[rsp]
  007d1	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  007d6	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  007dc	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  007e3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR s$[rsp]
  007e8	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  007eb	e8 00 00 00 00	 call	 flush_pending
  007f0	48 8b 44 24 70	 mov	 rax, QWORD PTR s$[rsp]
  007f5	48 8b 00	 mov	 rax, QWORD PTR [rax]
  007f8	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  007fc	75 1f		 jne	 SHORT $LN1@deflate_fa
  007fe	83 7c 24 78 04	 cmp	 DWORD PTR flush$[rsp], 4
  00803	75 0a		 jne	 SHORT $LN35@deflate_fa
  00805	c7 44 24 58 02
	00 00 00	 mov	 DWORD PTR tv419[rsp], 2
  0080d	eb 08		 jmp	 SHORT $LN36@deflate_fa
$LN35@deflate_fa:
  0080f	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR tv419[rsp], 0
$LN36@deflate_fa:
  00817	8b 44 24 58	 mov	 eax, DWORD PTR tv419[rsp]
  0081b	eb 1d		 jmp	 SHORT $LN21@deflate_fa
$LN1@deflate_fa:

; 1545 :     return flush == Z_FINISH ? finish_done : block_done;

  0081d	83 7c 24 78 04	 cmp	 DWORD PTR flush$[rsp], 4
  00822	75 0a		 jne	 SHORT $LN37@deflate_fa
  00824	c7 44 24 5c 03
	00 00 00	 mov	 DWORD PTR tv421[rsp], 3
  0082c	eb 08		 jmp	 SHORT $LN38@deflate_fa
$LN37@deflate_fa:
  0082e	c7 44 24 5c 01
	00 00 00	 mov	 DWORD PTR tv421[rsp], 1
$LN38@deflate_fa:
  00836	8b 44 24 5c	 mov	 eax, DWORD PTR tv421[rsp]
$LN21@deflate_fa:

; 1546 : }

  0083a	48 83 c4 68	 add	 rsp, 104		; 00000068H
  0083e	c3		 ret	 0
deflate_fast ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$deflate_stored DD imagerel deflate_stored
	DD	imagerel deflate_stored+858
	DD	imagerel $unwind$deflate_stored
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$deflate_stored DD 010d01H
	DD	0a20dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT deflate_stored
_TEXT	SEGMENT
max_start$ = 32
max_block_size$ = 36
tv135 = 40
tv160 = 48
tv169 = 56
tv181 = 64
tv190 = 72
tv192 = 76
s$ = 96
flush$ = 104
deflate_stored PROC					; COMDAT

; 1393 : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 58	 sub	 rsp, 88			; 00000058H

; 1394 :     /* Stored blocks are limited to 0xffff bytes, pending_buf is limited
; 1395 :      * to pending_buf_size, and each stored block has a 5 byte header:
; 1396 :      */
; 1397 :     ulg max_block_size = 0xffff;

  0000d	c7 44 24 24 ff
	ff 00 00	 mov	 DWORD PTR max_block_size$[rsp], 65535 ; 0000ffffH

; 1398 :     ulg max_start;
; 1399 : 
; 1400 :     if (max_block_size > s->pending_buf_size - 5) {

  00015	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0001a	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0001d	83 e8 05	 sub	 eax, 5
  00020	39 44 24 24	 cmp	 DWORD PTR max_block_size$[rsp], eax
  00024	76 0f		 jbe	 SHORT $LN12@deflate_st

; 1401 :         max_block_size = s->pending_buf_size - 5;

  00026	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0002b	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  0002e	83 e8 05	 sub	 eax, 5
  00031	89 44 24 24	 mov	 DWORD PTR max_block_size$[rsp], eax
$LN12@deflate_st:
$LN11@deflate_st:

; 1402 :     }
; 1403 : 
; 1404 :     /* Copy as much as possible from input to output: */
; 1405 :     for (;;) {
; 1406 :         /* Fill the window as much as possible: */
; 1407 :         if (s->lookahead <= 1) {

  00035	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0003a	83 b8 9c 00 00
	00 01		 cmp	 DWORD PTR [rax+156], 1
  00041	77 3a		 ja	 SHORT $LN9@deflate_st

; 1408 : 
; 1409 :             Assert(s->strstart < s->w_size+MAX_DIST(s) ||
; 1410 :                    s->block_start >= (long)s->w_size, "slide too late");
; 1411 : 
; 1412 :             fill_window(s);

  00043	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00048	e8 00 00 00 00	 call	 fill_window

; 1413 :             if (s->lookahead == 0 && flush == Z_NO_FLUSH) return need_more;

  0004d	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00052	41 83 bb 9c 00
	00 00 00	 cmp	 DWORD PTR [r11+156], 0
  0005a	75 0e		 jne	 SHORT $LN8@deflate_st
  0005c	83 7c 24 68 00	 cmp	 DWORD PTR flush$[rsp], 0
  00061	75 07		 jne	 SHORT $LN8@deflate_st
  00063	33 c0		 xor	 eax, eax
  00065	e9 eb 02 00 00	 jmp	 $LN13@deflate_st
$LN8@deflate_st:

; 1414 : 
; 1415 :             if (s->lookahead == 0) break; /* flush the current block */

  0006a	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0006f	83 b8 9c 00 00
	00 00		 cmp	 DWORD PTR [rax+156], 0
  00076	75 05		 jne	 SHORT $LN7@deflate_st
  00078	e9 f1 01 00 00	 jmp	 $LN10@deflate_st
$LN7@deflate_st:
$LN9@deflate_st:

; 1416 :         }
; 1417 :         Assert(s->block_start >= 0L, "block gone");
; 1418 : 
; 1419 :         s->strstart += s->lookahead;

  0007d	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00082	8b 88 94 00 00
	00		 mov	 ecx, DWORD PTR [rax+148]
  00088	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0008d	03 88 9c 00 00
	00		 add	 ecx, DWORD PTR [rax+156]
  00093	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00098	89 88 94 00 00
	00		 mov	 DWORD PTR [rax+148], ecx

; 1420 :         s->lookahead = 0;

  0009e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000a3	c7 80 9c 00 00
	00 00 00 00 00	 mov	 DWORD PTR [rax+156], 0

; 1421 : 
; 1422 :         /* Emit a stored block if pending_buf will be full: */
; 1423 :         max_start = s->block_start + max_block_size;

  000ad	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000b2	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  000b8	03 44 24 24	 add	 eax, DWORD PTR max_block_size$[rsp]
  000bc	89 44 24 20	 mov	 DWORD PTR max_start$[rsp], eax

; 1424 :         if (s->strstart == 0 || (ulg)s->strstart >= max_start) {

  000c0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000c5	83 b8 94 00 00
	00 00		 cmp	 DWORD PTR [rax+148], 0
  000cc	74 15		 je	 SHORT $LN5@deflate_st
  000ce	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000d3	8b 44 24 20	 mov	 eax, DWORD PTR max_start$[rsp]
  000d7	39 81 94 00 00
	00		 cmp	 DWORD PTR [rcx+148], eax
  000dd	0f 82 c2 00 00
	00		 jb	 $LN6@deflate_st
$LN5@deflate_st:

; 1425 :             /* strstart == 0 is possible when wraparound on 16-bit machine */
; 1426 :             s->lookahead = (uInt)(s->strstart - max_start);

  000e3	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  000e8	8b 44 24 20	 mov	 eax, DWORD PTR max_start$[rsp]
  000ec	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  000f2	2b c8		 sub	 ecx, eax
  000f4	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  000f9	89 88 9c 00 00
	00		 mov	 DWORD PTR [rax+156], ecx

; 1427 :             s->strstart = (uInt)max_start;

  000ff	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00104	8b 44 24 20	 mov	 eax, DWORD PTR max_start$[rsp]
  00108	89 81 94 00 00
	00		 mov	 DWORD PTR [rcx+148], eax

; 1428 :             FLUSH_BLOCK(s, 0);

  0010e	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00113	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  0011a	7c 1b		 jl	 SHORT $LN15@deflate_st
  0011c	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00121	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00127	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0012c	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  00130	48 89 44 24 28	 mov	 QWORD PTR tv135[rsp], rax
  00135	eb 09		 jmp	 SHORT $LN16@deflate_st
$LN15@deflate_st:
  00137	48 c7 44 24 28
	00 00 00 00	 mov	 QWORD PTR tv135[rsp], 0
$LN16@deflate_st:
  00140	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00145	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0014a	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00150	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  00157	44 2b c0	 sub	 r8d, eax
  0015a	45 33 c9	 xor	 r9d, r9d
  0015d	48 8b 54 24 28	 mov	 rdx, QWORD PTR tv135[rsp]
  00162	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00167	e8 00 00 00 00	 call	 _tr_flush_block
  0016c	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00171	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00176	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  0017c	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00183	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00188	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0018b	e8 00 00 00 00	 call	 flush_pending
  00190	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00195	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00198	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  0019c	75 07		 jne	 SHORT $LN4@deflate_st
  0019e	33 c0		 xor	 eax, eax
  001a0	e9 b0 01 00 00	 jmp	 $LN13@deflate_st
$LN4@deflate_st:
$LN6@deflate_st:

; 1429 :         }
; 1430 :         /* Flush if we may have to slide, otherwise block_start may become
; 1431 :          * negative and the data will be gone:
; 1432 :          */
; 1433 :         if (s->strstart - (uInt)s->block_start >= MAX_DIST(s)) {

  001a5	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001aa	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001af	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001b5	8b 89 94 00 00
	00		 mov	 ecx, DWORD PTR [rcx+148]
  001bb	2b c8		 sub	 ecx, eax
  001bd	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001c2	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  001c5	2d 06 01 00 00	 sub	 eax, 262		; 00000106H
  001ca	3b c8		 cmp	 ecx, eax
  001cc	0f 82 97 00 00
	00		 jb	 $LN3@deflate_st

; 1434 :             FLUSH_BLOCK(s, 0);

  001d2	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001d7	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  001de	7c 1b		 jl	 SHORT $LN17@deflate_st
  001e0	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  001e5	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  001eb	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  001f0	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  001f4	48 89 44 24 30	 mov	 QWORD PTR tv160[rsp], rax
  001f9	eb 09		 jmp	 SHORT $LN18@deflate_st
$LN17@deflate_st:
  001fb	48 c7 44 24 30
	00 00 00 00	 mov	 QWORD PTR tv160[rsp], 0
$LN18@deflate_st:
  00204	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00209	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0020e	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  00214	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  0021b	44 2b c0	 sub	 r8d, eax
  0021e	45 33 c9	 xor	 r9d, r9d
  00221	48 8b 54 24 30	 mov	 rdx, QWORD PTR tv160[rsp]
  00226	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0022b	e8 00 00 00 00	 call	 _tr_flush_block
  00230	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  00235	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0023a	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  00240	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  00247	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  0024c	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  0024f	e8 00 00 00 00	 call	 flush_pending
  00254	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00259	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0025c	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00260	75 07		 jne	 SHORT $LN2@deflate_st
  00262	33 c0		 xor	 eax, eax
  00264	e9 ec 00 00 00	 jmp	 $LN13@deflate_st
$LN2@deflate_st:
$LN3@deflate_st:

; 1435 :         }
; 1436 :     }

  00269	e9 c7 fd ff ff	 jmp	 $LN11@deflate_st
$LN10@deflate_st:

; 1437 :     FLUSH_BLOCK(s, flush == Z_FINISH);

  0026e	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  00273	75 0a		 jne	 SHORT $LN19@deflate_st
  00275	c7 44 24 38 01
	00 00 00	 mov	 DWORD PTR tv169[rsp], 1
  0027d	eb 08		 jmp	 SHORT $LN20@deflate_st
$LN19@deflate_st:
  0027f	c7 44 24 38 00
	00 00 00	 mov	 DWORD PTR tv169[rsp], 0
$LN20@deflate_st:
  00287	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0028c	83 b8 84 00 00
	00 00		 cmp	 DWORD PTR [rax+132], 0
  00293	7c 1b		 jl	 SHORT $LN21@deflate_st
  00295	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  0029a	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  002a0	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002a5	48 03 41 50	 add	 rax, QWORD PTR [rcx+80]
  002a9	48 89 44 24 40	 mov	 QWORD PTR tv181[rsp], rax
  002ae	eb 09		 jmp	 SHORT $LN22@deflate_st
$LN21@deflate_st:
  002b0	48 c7 44 24 40
	00 00 00 00	 mov	 QWORD PTR tv181[rsp], 0
$LN22@deflate_st:
  002b9	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002be	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002c3	8b 80 84 00 00
	00		 mov	 eax, DWORD PTR [rax+132]
  002c9	44 8b 81 94 00
	00 00		 mov	 r8d, DWORD PTR [rcx+148]
  002d0	44 2b c0	 sub	 r8d, eax
  002d3	44 8b 4c 24 38	 mov	 r9d, DWORD PTR tv169[rsp]
  002d8	48 8b 54 24 40	 mov	 rdx, QWORD PTR tv181[rsp]
  002dd	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  002e2	e8 00 00 00 00	 call	 _tr_flush_block
  002e7	4c 8b 5c 24 60	 mov	 r11, QWORD PTR s$[rsp]
  002ec	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  002f1	8b 80 94 00 00
	00		 mov	 eax, DWORD PTR [rax+148]
  002f7	41 89 83 84 00
	00 00		 mov	 DWORD PTR [r11+132], eax
  002fe	48 8b 4c 24 60	 mov	 rcx, QWORD PTR s$[rsp]
  00303	48 8b 09	 mov	 rcx, QWORD PTR [rcx]
  00306	e8 00 00 00 00	 call	 flush_pending
  0030b	48 8b 44 24 60	 mov	 rax, QWORD PTR s$[rsp]
  00310	48 8b 00	 mov	 rax, QWORD PTR [rax]
  00313	83 78 18 00	 cmp	 DWORD PTR [rax+24], 0
  00317	75 1f		 jne	 SHORT $LN1@deflate_st
  00319	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0031e	75 0a		 jne	 SHORT $LN23@deflate_st
  00320	c7 44 24 48 02
	00 00 00	 mov	 DWORD PTR tv190[rsp], 2
  00328	eb 08		 jmp	 SHORT $LN24@deflate_st
$LN23@deflate_st:
  0032a	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR tv190[rsp], 0
$LN24@deflate_st:
  00332	8b 44 24 48	 mov	 eax, DWORD PTR tv190[rsp]
  00336	eb 1d		 jmp	 SHORT $LN13@deflate_st
$LN1@deflate_st:

; 1438 :     return flush == Z_FINISH ? finish_done : block_done;

  00338	83 7c 24 68 04	 cmp	 DWORD PTR flush$[rsp], 4
  0033d	75 0a		 jne	 SHORT $LN25@deflate_st
  0033f	c7 44 24 4c 03
	00 00 00	 mov	 DWORD PTR tv192[rsp], 3
  00347	eb 08		 jmp	 SHORT $LN26@deflate_st
$LN25@deflate_st:
  00349	c7 44 24 4c 01
	00 00 00	 mov	 DWORD PTR tv192[rsp], 1
$LN26@deflate_st:
  00351	8b 44 24 4c	 mov	 eax, DWORD PTR tv192[rsp]
$LN13@deflate_st:

; 1439 : }

  00355	48 83 c4 58	 add	 rsp, 88			; 00000058H
  00359	c3		 ret	 0
deflate_stored ENDP
END
