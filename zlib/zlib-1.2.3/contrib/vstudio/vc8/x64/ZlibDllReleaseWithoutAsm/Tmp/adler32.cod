; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	adler32
;	COMDAT pdata
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\adler32.c
pdata	SEGMENT
$pdata$adler32 DD imagerel $LN21
	DD	imagerel $LN21+1631
	DD	imagerel $unwind$adler32
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$adler32 DD 011201H
	DD	02212H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT adler32
_TEXT	SEGMENT
n$ = 0
sum2$ = 4
adler$ = 32
buf$ = 40
len$ = 48
adler32	PROC						; COMDAT

; 61   : {

$LN21:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	89 4c 24 08	 mov	 DWORD PTR [rsp+8], ecx
  0000e	48 83 ec 18	 sub	 rsp, 24

; 62   :     unsigned long sum2;
; 63   :     unsigned n;
; 64   : 
; 65   :     /* split Adler-32 into component sums */
; 66   :     sum2 = (adler >> 16) & 0xffff;

  00012	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00016	c1 e8 10	 shr	 eax, 16
  00019	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0001e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 67   :     adler &= 0xffff;

  00022	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00026	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  0002b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 68   : 
; 69   :     /* in case user likes doing a byte at a time, keep it fast */
; 70   :     if (len == 1) {

  0002f	83 7c 24 30 01	 cmp	 DWORD PTR len$[rsp], 1
  00034	75 60		 jne	 SHORT $LN18@adler32

; 71   :         adler += buf[0];

  00036	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0003b	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  0003e	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00042	03 c1		 add	 eax, ecx
  00044	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax

; 72   :         if (adler >= BASE)

  00048	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  00050	72 0d		 jb	 SHORT $LN17@adler32

; 73   :             adler -= BASE;

  00052	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00056	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  0005b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
$LN17@adler32:

; 74   :         sum2 += adler;

  0005f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00063	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00067	03 c1		 add	 eax, ecx
  00069	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 75   :         if (sum2 >= BASE)

  0006d	81 7c 24 04 f1
	ff 00 00	 cmp	 DWORD PTR sum2$[rsp], 65521 ; 0000fff1H
  00075	72 0d		 jb	 SHORT $LN16@adler32

; 76   :             sum2 -= BASE;

  00077	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0007b	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00080	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
$LN16@adler32:

; 77   :         return adler | (sum2 << 16);

  00084	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00088	c1 e1 10	 shl	 ecx, 16
  0008b	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0008f	0b c1		 or	 eax, ecx
  00091	e9 c4 05 00 00	 jmp	 $LN19@adler32
$LN18@adler32:

; 78   :     }
; 79   : 
; 80   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 81   :     if (buf == Z_NULL)

  00096	48 83 7c 24 28
	00		 cmp	 QWORD PTR buf$[rsp], 0
  0009c	75 0a		 jne	 SHORT $LN15@adler32

; 82   :         return 1L;

  0009e	b8 01 00 00 00	 mov	 eax, 1
  000a3	e9 b2 05 00 00	 jmp	 $LN19@adler32
$LN15@adler32:

; 83   : 
; 84   :     /* in case short lengths are provided, keep it somewhat fast */
; 85   :     if (len < 16) {

  000a8	83 7c 24 30 10	 cmp	 DWORD PTR len$[rsp], 16
  000ad	73 7d		 jae	 SHORT $LN14@adler32
$LN13@adler32:

; 86   :         while (len--) {

  000af	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  000b3	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  000b7	83 e8 01	 sub	 eax, 1
  000ba	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
  000be	85 c9		 test	 ecx, ecx
  000c0	74 30		 je	 SHORT $LN12@adler32

; 87   :             adler += *buf++;

  000c2	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  000c7	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  000ca	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  000ce	03 c1		 add	 eax, ecx
  000d0	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  000d4	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  000d9	48 83 c0 01	 add	 rax, 1
  000dd	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 88   :             sum2 += adler;

  000e2	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  000e6	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  000ea	03 c1		 add	 eax, ecx
  000ec	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 89   :         }

  000f0	eb bd		 jmp	 SHORT $LN13@adler32
$LN12@adler32:

; 90   :         if (adler >= BASE)

  000f2	81 7c 24 20 f1
	ff 00 00	 cmp	 DWORD PTR adler$[rsp], 65521 ; 0000fff1H
  000fa	72 0d		 jb	 SHORT $LN11@adler32

; 91   :             adler -= BASE;

  000fc	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00100	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00105	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
$LN11@adler32:

; 92   :         MOD4(sum2);             /* only added so many BASE's */

  00109	33 d2		 xor	 edx, edx
  0010b	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0010f	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00114	f7 f1		 div	 ecx
  00116	89 54 24 04	 mov	 DWORD PTR sum2$[rsp], edx

; 93   :         return adler | (sum2 << 16);

  0011a	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  0011e	c1 e1 10	 shl	 ecx, 16
  00121	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00125	0b c1		 or	 eax, ecx
  00127	e9 2e 05 00 00	 jmp	 $LN19@adler32
$LN14@adler32:
$LN10@adler32:

; 94   :     }
; 95   : 
; 96   :     /* do length NMAX blocks -- requires just one modulo operation */
; 97   :     while (len >= NMAX) {

  0012c	81 7c 24 30 b0
	15 00 00	 cmp	 DWORD PTR len$[rsp], 5552 ; 000015b0H
  00134	0f 82 6b 02 00
	00		 jb	 $LN9@adler32

; 98   :         len -= NMAX;

  0013a	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  0013e	2d b0 15 00 00	 sub	 eax, 5552		; 000015b0H
  00143	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 99   :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00147	c7 04 24 5b 01
	00 00		 mov	 DWORD PTR n$[rsp], 347	; 0000015bH
$LN8@adler32:

; 100  :         do {
; 101  :             DO16(buf);          /* 16 sums unrolled */

  0014e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00153	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00156	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0015a	03 c1		 add	 eax, ecx
  0015c	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00160	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00164	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00168	03 c1		 add	 eax, ecx
  0016a	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0016e	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00173	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  00177	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0017b	03 c1		 add	 eax, ecx
  0017d	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00181	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00185	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00189	03 c1		 add	 eax, ecx
  0018b	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0018f	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00194	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00198	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0019c	03 c1		 add	 eax, ecx
  0019e	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001a2	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001a6	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  001aa	03 c1		 add	 eax, ecx
  001ac	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001b0	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001b5	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  001b9	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001bd	03 c1		 add	 eax, ecx
  001bf	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001c3	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001c7	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  001cb	03 c1		 add	 eax, ecx
  001cd	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001d1	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001d6	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  001da	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001de	03 c1		 add	 eax, ecx
  001e0	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  001e4	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  001e8	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  001ec	03 c1		 add	 eax, ecx
  001ee	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  001f2	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  001f7	0f b6 48 05	 movzx	 ecx, BYTE PTR [rax+5]
  001fb	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  001ff	03 c1		 add	 eax, ecx
  00201	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00205	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00209	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0020d	03 c1		 add	 eax, ecx
  0020f	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00213	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00218	0f b6 48 06	 movzx	 ecx, BYTE PTR [rax+6]
  0021c	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00220	03 c1		 add	 eax, ecx
  00222	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00226	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0022a	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0022e	03 c1		 add	 eax, ecx
  00230	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00234	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00239	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  0023d	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00241	03 c1		 add	 eax, ecx
  00243	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00247	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0024b	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0024f	03 c1		 add	 eax, ecx
  00251	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00255	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0025a	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  0025e	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00262	03 c1		 add	 eax, ecx
  00264	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00268	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0026c	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00270	03 c1		 add	 eax, ecx
  00272	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00276	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0027b	0f b6 48 09	 movzx	 ecx, BYTE PTR [rax+9]
  0027f	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00283	03 c1		 add	 eax, ecx
  00285	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00289	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0028d	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00291	03 c1		 add	 eax, ecx
  00293	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00297	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0029c	0f b6 48 0a	 movzx	 ecx, BYTE PTR [rax+10]
  002a0	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002a4	03 c1		 add	 eax, ecx
  002a6	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002aa	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002ae	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  002b2	03 c1		 add	 eax, ecx
  002b4	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002b8	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002bd	0f b6 48 0b	 movzx	 ecx, BYTE PTR [rax+11]
  002c1	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002c5	03 c1		 add	 eax, ecx
  002c7	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002cb	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002cf	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  002d3	03 c1		 add	 eax, ecx
  002d5	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002d9	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002de	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  002e2	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  002e6	03 c1		 add	 eax, ecx
  002e8	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  002ec	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  002f0	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  002f4	03 c1		 add	 eax, ecx
  002f6	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  002fa	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  002ff	0f b6 48 0d	 movzx	 ecx, BYTE PTR [rax+13]
  00303	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00307	03 c1		 add	 eax, ecx
  00309	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0030d	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00311	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00315	03 c1		 add	 eax, ecx
  00317	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0031b	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00320	0f b6 48 0e	 movzx	 ecx, BYTE PTR [rax+14]
  00324	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00328	03 c1		 add	 eax, ecx
  0032a	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0032e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00332	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00336	03 c1		 add	 eax, ecx
  00338	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0033c	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00341	0f b6 48 0f	 movzx	 ecx, BYTE PTR [rax+15]
  00345	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00349	03 c1		 add	 eax, ecx
  0034b	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0034f	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00353	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00357	03 c1		 add	 eax, ecx
  00359	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 102  :             buf += 16;

  0035d	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00362	48 83 c0 10	 add	 rax, 16
  00366	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 103  :         } while (--n);

  0036b	8b 04 24	 mov	 eax, DWORD PTR n$[rsp]
  0036e	83 e8 01	 sub	 eax, 1
  00371	89 04 24	 mov	 DWORD PTR n$[rsp], eax
  00374	83 3c 24 00	 cmp	 DWORD PTR n$[rsp], 0
  00378	0f 85 d0 fd ff
	ff		 jne	 $LN8@adler32

; 104  :         MOD(adler);

  0037e	33 d2		 xor	 edx, edx
  00380	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00384	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00389	f7 f1		 div	 ecx
  0038b	89 54 24 20	 mov	 DWORD PTR adler$[rsp], edx

; 105  :         MOD(sum2);

  0038f	33 d2		 xor	 edx, edx
  00391	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00395	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0039a	f7 f1		 div	 ecx
  0039c	89 54 24 04	 mov	 DWORD PTR sum2$[rsp], edx

; 106  :     }

  003a0	e9 87 fd ff ff	 jmp	 $LN10@adler32
$LN9@adler32:

; 107  : 
; 108  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 109  :     if (len) {                  /* avoid modulos if none remaining */

  003a5	83 7c 24 30 00	 cmp	 DWORD PTR len$[rsp], 0
  003aa	0f 84 9d 02 00
	00		 je	 $LN5@adler32
$LN4@adler32:

; 110  :         while (len >= 16) {

  003b0	83 7c 24 30 10	 cmp	 DWORD PTR len$[rsp], 16
  003b5	0f 82 2d 02 00
	00		 jb	 $LN3@adler32

; 111  :             len -= 16;

  003bb	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  003bf	83 e8 10	 sub	 eax, 16
  003c2	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax

; 112  :             DO16(buf);

  003c6	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  003cb	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  003ce	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  003d2	03 c1		 add	 eax, ecx
  003d4	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  003d8	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  003dc	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  003e0	03 c1		 add	 eax, ecx
  003e2	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  003e6	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  003eb	0f b6 48 01	 movzx	 ecx, BYTE PTR [rax+1]
  003ef	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  003f3	03 c1		 add	 eax, ecx
  003f5	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  003f9	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  003fd	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00401	03 c1		 add	 eax, ecx
  00403	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00407	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0040c	0f b6 48 02	 movzx	 ecx, BYTE PTR [rax+2]
  00410	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00414	03 c1		 add	 eax, ecx
  00416	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0041a	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0041e	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00422	03 c1		 add	 eax, ecx
  00424	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00428	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0042d	0f b6 48 03	 movzx	 ecx, BYTE PTR [rax+3]
  00431	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00435	03 c1		 add	 eax, ecx
  00437	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0043b	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0043f	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00443	03 c1		 add	 eax, ecx
  00445	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00449	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0044e	0f b6 48 04	 movzx	 ecx, BYTE PTR [rax+4]
  00452	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00456	03 c1		 add	 eax, ecx
  00458	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0045c	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00460	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00464	03 c1		 add	 eax, ecx
  00466	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0046a	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  0046f	0f b6 48 05	 movzx	 ecx, BYTE PTR [rax+5]
  00473	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00477	03 c1		 add	 eax, ecx
  00479	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0047d	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00481	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00485	03 c1		 add	 eax, ecx
  00487	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0048b	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00490	0f b6 48 06	 movzx	 ecx, BYTE PTR [rax+6]
  00494	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00498	03 c1		 add	 eax, ecx
  0049a	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0049e	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004a2	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  004a6	03 c1		 add	 eax, ecx
  004a8	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004ac	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004b1	0f b6 48 07	 movzx	 ecx, BYTE PTR [rax+7]
  004b5	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004b9	03 c1		 add	 eax, ecx
  004bb	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  004bf	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004c3	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  004c7	03 c1		 add	 eax, ecx
  004c9	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004cd	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004d2	0f b6 48 08	 movzx	 ecx, BYTE PTR [rax+8]
  004d6	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004da	03 c1		 add	 eax, ecx
  004dc	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  004e0	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  004e4	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  004e8	03 c1		 add	 eax, ecx
  004ea	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  004ee	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  004f3	0f b6 48 09	 movzx	 ecx, BYTE PTR [rax+9]
  004f7	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  004fb	03 c1		 add	 eax, ecx
  004fd	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00501	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00505	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00509	03 c1		 add	 eax, ecx
  0050b	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  0050f	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00514	0f b6 48 0a	 movzx	 ecx, BYTE PTR [rax+10]
  00518	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0051c	03 c1		 add	 eax, ecx
  0051e	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00522	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00526	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0052a	03 c1		 add	 eax, ecx
  0052c	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00530	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00535	0f b6 48 0b	 movzx	 ecx, BYTE PTR [rax+11]
  00539	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0053d	03 c1		 add	 eax, ecx
  0053f	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00543	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00547	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0054b	03 c1		 add	 eax, ecx
  0054d	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00551	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00556	0f b6 48 0c	 movzx	 ecx, BYTE PTR [rax+12]
  0055a	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0055e	03 c1		 add	 eax, ecx
  00560	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00564	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00568	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0056c	03 c1		 add	 eax, ecx
  0056e	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00572	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00577	0f b6 48 0d	 movzx	 ecx, BYTE PTR [rax+13]
  0057b	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  0057f	03 c1		 add	 eax, ecx
  00581	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  00585	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  00589	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  0058d	03 c1		 add	 eax, ecx
  0058f	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  00593	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00598	0f b6 48 0e	 movzx	 ecx, BYTE PTR [rax+14]
  0059c	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005a0	03 c1		 add	 eax, ecx
  005a2	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  005a6	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  005aa	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  005ae	03 c1		 add	 eax, ecx
  005b0	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax
  005b4	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005b9	0f b6 48 0f	 movzx	 ecx, BYTE PTR [rax+15]
  005bd	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  005c1	03 c1		 add	 eax, ecx
  005c3	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  005c7	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  005cb	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  005cf	03 c1		 add	 eax, ecx
  005d1	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 113  :             buf += 16;

  005d5	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  005da	48 83 c0 10	 add	 rax, 16
  005de	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 114  :         }

  005e3	e9 c8 fd ff ff	 jmp	 $LN4@adler32
$LN3@adler32:
$LN2@adler32:

; 115  :         while (len--) {

  005e8	8b 4c 24 30	 mov	 ecx, DWORD PTR len$[rsp]
  005ec	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  005f0	83 e8 01	 sub	 eax, 1
  005f3	89 44 24 30	 mov	 DWORD PTR len$[rsp], eax
  005f7	85 c9		 test	 ecx, ecx
  005f9	74 30		 je	 SHORT $LN1@adler32

; 116  :             adler += *buf++;

  005fb	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00600	0f b6 08	 movzx	 ecx, BYTE PTR [rax]
  00603	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00607	03 c1		 add	 eax, ecx
  00609	89 44 24 20	 mov	 DWORD PTR adler$[rsp], eax
  0060d	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00612	48 83 c0 01	 add	 rax, 1
  00616	48 89 44 24 28	 mov	 QWORD PTR buf$[rsp], rax

; 117  :             sum2 += adler;

  0061b	8b 4c 24 20	 mov	 ecx, DWORD PTR adler$[rsp]
  0061f	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00623	03 c1		 add	 eax, ecx
  00625	89 44 24 04	 mov	 DWORD PTR sum2$[rsp], eax

; 118  :         }

  00629	eb bd		 jmp	 SHORT $LN2@adler32
$LN1@adler32:

; 119  :         MOD(adler);

  0062b	33 d2		 xor	 edx, edx
  0062d	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00631	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00636	f7 f1		 div	 ecx
  00638	89 54 24 20	 mov	 DWORD PTR adler$[rsp], edx

; 120  :         MOD(sum2);

  0063c	33 d2		 xor	 edx, edx
  0063e	8b 44 24 04	 mov	 eax, DWORD PTR sum2$[rsp]
  00642	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00647	f7 f1		 div	 ecx
  00649	89 54 24 04	 mov	 DWORD PTR sum2$[rsp], edx
$LN5@adler32:

; 121  :     }
; 122  : 
; 123  :     /* return recombined sums */
; 124  :     return adler | (sum2 << 16);

  0064d	8b 4c 24 04	 mov	 ecx, DWORD PTR sum2$[rsp]
  00651	c1 e1 10	 shl	 ecx, 16
  00654	8b 44 24 20	 mov	 eax, DWORD PTR adler$[rsp]
  00658	0b c1		 or	 eax, ecx
$LN19@adler32:

; 125  : }

  0065a	48 83 c4 18	 add	 rsp, 24
  0065e	c3		 ret	 0
adler32	ENDP
END
