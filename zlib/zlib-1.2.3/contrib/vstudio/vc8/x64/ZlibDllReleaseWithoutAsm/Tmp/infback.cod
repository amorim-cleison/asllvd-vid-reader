; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	inflateBackEnd
;	COMDAT pdata
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\infback.c
pdata	SEGMENT
$pdata$inflateBackEnd DD imagerel $LN5
	DD	imagerel $LN5+94
	DD	imagerel $unwind$inflateBackEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackEnd DD 010901H
	DD	04209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBackEnd
_TEXT	SEGMENT
strm$ = 48
inflateBackEnd PROC					; COMDAT

; 616  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 617  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 83 7c 24 30
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 18		 je	 SHORT $LN1@inflateBac
  00011	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 0c		 je	 SHORT $LN1@inflateBac
  0001d	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 07		 jne	 SHORT $LN2@inflateBac
$LN1@inflateBac:

; 618  :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2
  0002e	eb 29		 jmp	 SHORT $LN3@inflateBac
$LN2@inflateBac:

; 619  :     ZFREE(strm, strm->state);

  00030	48 8b 54 24 30	 mov	 rdx, QWORD PTR strm$[rsp]
  00035	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  00039	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  0003e	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00042	48 8b 44 24 30	 mov	 rax, QWORD PTR strm$[rsp]
  00047	ff 50 38	 call	 QWORD PTR [rax+56]

; 620  :     strm->state = Z_NULL;

  0004a	4c 8b 5c 24 30	 mov	 r11, QWORD PTR strm$[rsp]
  0004f	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 621  :     Tracev((stderr, "inflate: end\n"));
; 622  :     return Z_OK;

  00057	33 c0		 xor	 eax, eax
$LN3@inflateBac:

; 623  : }

  00059	48 83 c4 28	 add	 rsp, 40			; 00000028H
  0005d	c3		 ret	 0
inflateBackEnd ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 75   : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00005	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00011	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 111  :     state->lenbits = 9;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0001a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 112  :     state->distcode = distfix;

  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  0002d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 113  :     state->distbits = 5;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 6c 05 00
	00 00		 mov	 DWORD PTR [rax+108], 5

; 114  : }

  0003d	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflateBackInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBackInit_ DD imagerel $LN10
	DD	imagerel $LN10+341
	DD	imagerel $unwind$inflateBackInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBackInit_ DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBackInit_
_TEXT	SEGMENT
state$ = 32
strm$ = 64
windowBits$ = 72
window$ = 80
version$ = 88
stream_size$ = 96
inflateBackInit_ PROC					; COMDAT

; 34   : {

$LN10:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00017	48 83 7c 24 58
	00		 cmp	 QWORD PTR version$[rsp], 0
  0001d	74 1a		 je	 SHORT $LN6@inflateBac@2
  0001f	48 8b 44 24 58	 mov	 rax, QWORD PTR version$[rsp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00027	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ??_C@_05GDHACFMB@1?42?43?$AA@
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 07		 jne	 SHORT $LN6@inflateBac@2
  00032	83 7c 24 60 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00037	74 0a		 je	 SHORT $LN7@inflateBac@2
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  00039	b8 fa ff ff ff	 mov	 eax, -6
  0003e	e9 0d 01 00 00	 jmp	 $LN8@inflateBac@2
$LN7@inflateBac@2:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00049	74 16		 je	 SHORT $LN4@inflateBac@2
  0004b	48 83 7c 24 50
	00		 cmp	 QWORD PTR window$[rsp], 0
  00051	74 0e		 je	 SHORT $LN4@inflateBac@2
  00053	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00058	7c 07		 jl	 SHORT $LN4@inflateBac@2
  0005a	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  0005f	7e 0a		 jle	 SHORT $LN5@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  00061	b8 fe ff ff ff	 mov	 eax, -2
  00066	e9 e5 00 00 00	 jmp	 $LN8@inflateBac@2
$LN5@inflateBac@2:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0006b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00070	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00078	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007d	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00082	75 1d		 jne	 SHORT $LN3@inflateBac@2

; 45   :         strm->zalloc = zcalloc;

  00084	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00089	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc
  00090	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 46   :         strm->opaque = (voidpf)0;

  00094	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00099	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN3@inflateBac@2:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  000a1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000a6	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000ab	75 10		 jne	 SHORT $LN2@inflateBac@2
  000ad	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b2	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  000b9	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN2@inflateBac@2:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  000bd	41 b8 48 25 00
	00		 mov	 r8d, 9544		; 00002548H
  000c3	ba 01 00 00 00	 mov	 edx, 1
  000c8	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000cd	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000d1	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000d6	ff 50 30	 call	 QWORD PTR [rax+48]
  000d9	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000de	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  000e4	75 07		 jne	 SHORT $LN1@inflateBac@2
  000e6	b8 fc ff ff ff	 mov	 eax, -4
  000eb	eb 63		 jmp	 SHORT $LN8@inflateBac@2
$LN1@inflateBac@2:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000ed	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000f2	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f7	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 54   :     state->dmax = 32768U;

  000fb	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00100	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H

; 55   :     state->wbits = windowBits;

  00107	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0010c	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00110	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 56   :     state->wsize = 1U << windowBits;

  00113	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  00117	b8 01 00 00 00	 mov	 eax, 1
  0011c	d3 e0		 shl	 eax, cl
  0011e	8b c8		 mov	 ecx, eax
  00120	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00125	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 57   :     state->window = window;

  00128	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  0012d	48 8b 44 24 50	 mov	 rax, QWORD PTR window$[rsp]
  00132	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 58   :     state->write = 0;

  00136	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  0013b	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 59   :     state->whave = 0;

  00142	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00147	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 60   :     return Z_OK;

  0014e	33 c0		 xor	 eax, eax
$LN8@inflateBac@2:

; 61   : }

  00150	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00154	c3		 ret	 0
inflateBackInit_ ENDP
PUBLIC	inflateBack
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateBack DD imagerel $LN354
	DD	imagerel $LN354+7164
	DD	imagerel $unwind$inflateBack
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateBack DD 021b01H
	DD	013011bH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateBack
_TEXT	SEGMENT
put$ = 48
last$ = 56
have$ = 60
len$ = 64
bits$ = 68
left$ = 72
next$ = 80
ret$ = 88
hold$ = 92
this$ = 96
copy$ = 100
from$ = 104
state$ = 112
tv73 = 120
tv76 = 124
tv137 = 128
tv791 = 132
strm$ = 160
in$ = 168
in_desc$ = 176
out$ = 184
out_desc$ = 192
inflateBack PROC					; COMDAT

; 247  : {

$LN354:
  00000	4c 89 4c 24 20	 mov	 QWORD PTR [rsp+32], r9
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000f	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00014	48 81 ec 98 00
	00 00		 sub	 rsp, 152		; 00000098H

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code this;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  0001b	48 83 bc 24 a0
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00024	74 0f		 je	 SHORT $LN345@inflateBac@3
  00026	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0002e	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00033	75 0a		 jne	 SHORT $LN346@inflateBac@3
$LN345@inflateBac@3:

; 265  :         return Z_STREAM_ERROR;

  00035	b8 fe ff ff ff	 mov	 eax, -2
  0003a	e9 70 1b 00 00	 jmp	 $LN347@inflateBac@3
$LN346@inflateBac@3:

; 266  :     state = (struct inflate_state FAR *)strm->state;

  0003f	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00047	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0004b	48 89 44 24 70	 mov	 QWORD PTR state$[rsp], rax

; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00050	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00058	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 270  :     state->mode = TYPE;

  00060	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00065	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 271  :     state->last = 0;

  0006b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00070	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 272  :     state->whave = 0;

  00077	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0007c	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 273  :     next = strm->next_in;

  00083	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0008b	48 8b 00	 mov	 rax, QWORD PTR [rax]
  0008e	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00093	48 83 7c 24 50
	00		 cmp	 QWORD PTR next$[rsp], 0
  00099	74 11		 je	 SHORT $LN349@inflateBac@3
  0009b	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a3	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000a6	89 44 24 78	 mov	 DWORD PTR tv73[rsp], eax
  000aa	eb 08		 jmp	 SHORT $LN350@inflateBac@3
$LN349@inflateBac@3:
  000ac	c7 44 24 78 00
	00 00 00	 mov	 DWORD PTR tv73[rsp], 0
$LN350@inflateBac@3:
  000b4	8b 44 24 78	 mov	 eax, DWORD PTR tv73[rsp]
  000b8	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax

; 275  :     hold = 0;

  000bc	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0

; 276  :     bits = 0;

  000c4	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0

; 277  :     put = state->window;

  000cc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000d1	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  000d5	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 278  :     left = state->wsize;

  000da	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000df	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000e2	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax
$LN344@inflateBac@3:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  000e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  000eb	8b 00		 mov	 eax, DWORD PTR [rax]
  000ed	89 44 24 7c	 mov	 DWORD PTR tv76[rsp], eax
  000f1	8b 44 24 7c	 mov	 eax, DWORD PTR tv76[rsp]
  000f5	83 e8 0b	 sub	 eax, 11
  000f8	89 44 24 7c	 mov	 DWORD PTR tv76[rsp], eax
  000fc	83 7c 24 7c 10	 cmp	 DWORD PTR tv76[rsp], 16
  00101	0f 87 76 1a 00
	00		 ja	 $LN1@inflateBac@3
  00107	48 63 44 24 7c	 movsxd	 rax, DWORD PTR tv76[rsp]
  0010c	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00113	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN353@inflateBac@3[rcx+rax*4]
  0011a	48 03 c1	 add	 rax, rcx
  0011d	ff e0		 jmp	 rax
$LN340@inflateBac@3:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  0011f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00124	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  00128	74 3b		 je	 SHORT $LN339@inflateBac@3
$LN338@inflateBac@3:

; 286  :                 BYTEBITS();

  0012a	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0012e	83 e0 07	 and	 eax, 7
  00131	0f b6 c8	 movzx	 ecx, al
  00134	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00138	d3 e8		 shr	 eax, cl
  0013a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0013e	8b 4c 24 44	 mov	 ecx, DWORD PTR bits$[rsp]
  00142	83 e1 07	 and	 ecx, 7
  00145	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00149	2b c1		 sub	 eax, ecx
  0014b	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  0014f	33 c0		 xor	 eax, eax
  00151	85 c0		 test	 eax, eax
  00153	75 d5		 jne	 SHORT $LN338@inflateBac@3

; 287  :                 state->mode = DONE;

  00155	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0015a	c7 00 1a 00 00
	00		 mov	 DWORD PTR [rax], 26

; 288  :                 break;

  00160	e9 22 1a 00 00	 jmp	 $LN341@inflateBac@3
$LN339@inflateBac@3:
$LN335@inflateBac@3:
$LN332@inflateBac@3:

; 289  :             }
; 290  :             NEEDBITS(3);

  00165	83 7c 24 44 03	 cmp	 DWORD PTR bits$[rsp], 3
  0016a	0f 83 94 00 00
	00		 jae	 $LN331@inflateBac@3
$LN330@inflateBac@3:
$LN327@inflateBac@3:
  00170	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00175	75 35		 jne	 SHORT $LN324@inflateBac@3
  00177	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0017c	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00184	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0018b	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  0018f	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00194	75 16		 jne	 SHORT $LN323@inflateBac@3
  00196	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0019f	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  001a7	e9 e0 19 00 00	 jmp	 $inf_leave$78193
$LN323@inflateBac@3:
$LN324@inflateBac@3:
  001ac	33 c0		 xor	 eax, eax
  001ae	85 c0		 test	 eax, eax
  001b0	75 be		 jne	 SHORT $LN327@inflateBac@3
  001b2	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  001b6	83 e8 01	 sub	 eax, 1
  001b9	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  001bd	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001c2	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  001c5	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  001c9	0f b6 c8	 movzx	 ecx, al
  001cc	8b c2		 mov	 eax, edx
  001ce	d3 e0		 shl	 eax, cl
  001d0	8b c8		 mov	 ecx, eax
  001d2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  001d6	03 c1		 add	 eax, ecx
  001d8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  001dc	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001e1	48 83 c0 01	 add	 rax, 1
  001e5	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  001ea	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  001ee	83 c0 08	 add	 eax, 8
  001f1	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  001f5	33 c0		 xor	 eax, eax
  001f7	85 c0		 test	 eax, eax
  001f9	0f 85 71 ff ff
	ff		 jne	 $LN330@inflateBac@3
  001ff	e9 61 ff ff ff	 jmp	 $LN332@inflateBac@3
$LN331@inflateBac@3:
  00204	33 c0		 xor	 eax, eax
  00206	85 c0		 test	 eax, eax
  00208	0f 85 57 ff ff
	ff		 jne	 $LN335@inflateBac@3

; 291  :             state->last = BITS(1);

  0020e	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00212	83 e1 01	 and	 ecx, 1
  00215	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0021a	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN322@inflateBac@3:

; 292  :             DROPBITS(1);

  0021d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00221	d1 e8		 shr	 eax, 1
  00223	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00227	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0022b	83 e8 01	 sub	 eax, 1
  0022e	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00232	33 c0		 xor	 eax, eax
  00234	85 c0		 test	 eax, eax
  00236	75 e5		 jne	 SHORT $LN322@inflateBac@3

; 293  :             switch (BITS(2)) {

  00238	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0023c	83 e0 03	 and	 eax, 3
  0023f	89 84 24 80 00
	00 00		 mov	 DWORD PTR tv137[rsp], eax
  00246	83 bc 24 80 00
	00 00 00	 cmp	 DWORD PTR tv137[rsp], 0
  0024e	74 20		 je	 SHORT $LN317@inflateBac@3
  00250	83 bc 24 80 00
	00 00 01	 cmp	 DWORD PTR tv137[rsp], 1
  00258	74 23		 je	 SHORT $LN316@inflateBac@3
  0025a	83 bc 24 80 00
	00 00 02	 cmp	 DWORD PTR tv137[rsp], 2
  00262	74 31		 je	 SHORT $LN315@inflateBac@3
  00264	83 bc 24 80 00
	00 00 03	 cmp	 DWORD PTR tv137[rsp], 3
  0026c	74 34		 je	 SHORT $LN314@inflateBac@3
  0026e	eb 50		 jmp	 SHORT $LN318@inflateBac@3
$LN317@inflateBac@3:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  00270	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00275	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 298  :                 break;

  0027b	eb 43		 jmp	 SHORT $LN318@inflateBac@3
$LN316@inflateBac@3:

; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  0027d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00282	e8 00 00 00 00	 call	 fixedtables

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  00287	4c 8b 5c 24 70	 mov	 r11, QWORD PTR state$[rsp]
  0028c	41 c7 03 12 00
	00 00		 mov	 DWORD PTR [r11], 18

; 304  :                 break;

  00293	eb 2b		 jmp	 SHORT $LN318@inflateBac@3
$LN315@inflateBac@3:

; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  00295	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0029a	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15

; 309  :                 break;

  002a0	eb 1e		 jmp	 SHORT $LN318@inflateBac@3
$LN314@inflateBac@3:

; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  002a2	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  002aa	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  002b1	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 312  :                 state->mode = BAD;

  002b5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  002ba	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27
$LN318@inflateBac@3:
$LN313@inflateBac@3:

; 313  :             }
; 314  :             DROPBITS(2);

  002c0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002c4	c1 e8 02	 shr	 eax, 2
  002c7	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  002cb	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  002cf	83 e8 02	 sub	 eax, 2
  002d2	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  002d6	33 c0		 xor	 eax, eax
  002d8	85 c0		 test	 eax, eax
  002da	75 e4		 jne	 SHORT $LN313@inflateBac@3

; 315  :             break;

  002dc	e9 a6 18 00 00	 jmp	 $LN341@inflateBac@3
$LN310@inflateBac@3:
$LN309@inflateBac@3:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  002e1	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  002e5	83 e0 07	 and	 eax, 7
  002e8	0f b6 c8	 movzx	 ecx, al
  002eb	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002ef	d3 e8		 shr	 eax, cl
  002f1	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  002f5	8b 4c 24 44	 mov	 ecx, DWORD PTR bits$[rsp]
  002f9	83 e1 07	 and	 ecx, 7
  002fc	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00300	2b c1		 sub	 eax, ecx
  00302	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00306	33 c0		 xor	 eax, eax
  00308	85 c0		 test	 eax, eax
  0030a	75 d5		 jne	 SHORT $LN309@inflateBac@3
$LN306@inflateBac@3:
$LN303@inflateBac@3:

; 320  :             NEEDBITS(32);

  0030c	83 7c 24 44 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00311	0f 83 94 00 00
	00		 jae	 $LN302@inflateBac@3
$LN301@inflateBac@3:
$LN298@inflateBac@3:
  00317	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0031c	75 35		 jne	 SHORT $LN295@inflateBac@3
  0031e	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00323	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0032b	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00332	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00336	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0033b	75 16		 jne	 SHORT $LN294@inflateBac@3
  0033d	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00346	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0034e	e9 39 18 00 00	 jmp	 $inf_leave$78193
$LN294@inflateBac@3:
$LN295@inflateBac@3:
  00353	33 c0		 xor	 eax, eax
  00355	85 c0		 test	 eax, eax
  00357	75 be		 jne	 SHORT $LN298@inflateBac@3
  00359	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0035d	83 e8 01	 sub	 eax, 1
  00360	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00364	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00369	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0036c	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00370	0f b6 c8	 movzx	 ecx, al
  00373	8b c2		 mov	 eax, edx
  00375	d3 e0		 shl	 eax, cl
  00377	8b c8		 mov	 ecx, eax
  00379	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0037d	03 c1		 add	 eax, ecx
  0037f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00383	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00388	48 83 c0 01	 add	 rax, 1
  0038c	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00391	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00395	83 c0 08	 add	 eax, 8
  00398	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  0039c	33 c0		 xor	 eax, eax
  0039e	85 c0		 test	 eax, eax
  003a0	0f 85 71 ff ff
	ff		 jne	 $LN301@inflateBac@3
  003a6	e9 61 ff ff ff	 jmp	 $LN303@inflateBac@3
$LN302@inflateBac@3:
  003ab	33 c0		 xor	 eax, eax
  003ad	85 c0		 test	 eax, eax
  003af	0f 85 57 ff ff
	ff		 jne	 $LN306@inflateBac@3

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  003b5	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  003b9	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003bf	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  003c3	c1 e8 10	 shr	 eax, 16
  003c6	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  003cb	3b c8		 cmp	 ecx, eax
  003cd	74 23		 je	 SHORT $LN293@inflateBac@3

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  003cf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003d7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  003de	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 323  :                 state->mode = BAD;

  003e2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  003e7	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 324  :                 break;

  003ed	e9 95 17 00 00	 jmp	 $LN341@inflateBac@3
$LN293@inflateBac@3:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  003f2	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  003f6	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  003fc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00401	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN292@inflateBac@3:

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  00404	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0040c	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00414	33 c0		 xor	 eax, eax
  00416	85 c0		 test	 eax, eax
  00418	75 ea		 jne	 SHORT $LN292@inflateBac@3
$LN289@inflateBac@3:

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  0041a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0041f	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00423	0f 84 3e 01 00
	00		 je	 $LN288@inflateBac@3

; 333  :                 copy = state->length;

  00429	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0042e	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  00431	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN287@inflateBac@3:

; 334  :                 PULL();

  00435	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0043a	75 35		 jne	 SHORT $LN284@inflateBac@3
  0043c	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00441	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00449	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00450	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00454	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00459	75 16		 jne	 SHORT $LN283@inflateBac@3
  0045b	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00464	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0046c	e9 1b 17 00 00	 jmp	 $inf_leave$78193
$LN283@inflateBac@3:
$LN284@inflateBac@3:
  00471	33 c0		 xor	 eax, eax
  00473	85 c0		 test	 eax, eax
  00475	75 be		 jne	 SHORT $LN287@inflateBac@3
$LN282@inflateBac@3:

; 335  :                 ROOM();

  00477	83 7c 24 48 00	 cmp	 DWORD PTR left$[rsp], 0
  0047c	75 50		 jne	 SHORT $LN279@inflateBac@3
  0047e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00483	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  00487	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0048c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00491	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00494	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax
  00498	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0049d	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  004a1	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  004a4	44 8b 44 24 48	 mov	 r8d, DWORD PTR left$[rsp]
  004a9	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  004ae	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  004b6	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  004bd	85 c0		 test	 eax, eax
  004bf	74 0d		 je	 SHORT $LN278@inflateBac@3
  004c1	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  004c9	e9 be 16 00 00	 jmp	 $inf_leave$78193
$LN278@inflateBac@3:
$LN279@inflateBac@3:
  004ce	33 c0		 xor	 eax, eax
  004d0	85 c0		 test	 eax, eax
  004d2	75 a3		 jne	 SHORT $LN282@inflateBac@3

; 336  :                 if (copy > have) copy = have;

  004d4	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  004d8	39 44 24 64	 cmp	 DWORD PTR copy$[rsp], eax
  004dc	76 08		 jbe	 SHORT $LN277@inflateBac@3
  004de	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  004e2	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN277@inflateBac@3:

; 337  :                 if (copy > left) copy = left;

  004e6	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  004ea	39 44 24 64	 cmp	 DWORD PTR copy$[rsp], eax
  004ee	76 08		 jbe	 SHORT $LN276@inflateBac@3
  004f0	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  004f4	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN276@inflateBac@3:

; 338  :                 zmemcpy(put, next, copy);

  004f8	44 8b 44 24 64	 mov	 r8d, DWORD PTR copy$[rsp]
  004fd	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  00502	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  00507	e8 00 00 00 00	 call	 memcpy

; 339  :                 have -= copy;

  0050c	44 8b 5c 24 64	 mov	 r11d, DWORD PTR copy$[rsp]
  00511	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00515	41 2b c3	 sub	 eax, r11d
  00518	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax

; 340  :                 next += copy;

  0051c	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  00520	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00525	48 03 c1	 add	 rax, rcx
  00528	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 341  :                 left -= copy;

  0052d	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  00531	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  00535	2b c1		 sub	 eax, ecx
  00537	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax

; 342  :                 put += copy;

  0053b	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  0053f	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  00544	48 03 c1	 add	 rax, rcx
  00547	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 343  :                 state->length -= copy;

  0054c	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00551	8b 44 24 64	 mov	 eax, DWORD PTR copy$[rsp]
  00555	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  00558	2b c8		 sub	 ecx, eax
  0055a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0055f	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 344  :             }

  00562	e9 b3 fe ff ff	 jmp	 $LN289@inflateBac@3
$LN288@inflateBac@3:

; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  00567	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0056c	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 347  :             break;

  00572	e9 10 16 00 00	 jmp	 $LN341@inflateBac@3
$LN275@inflateBac@3:
$LN274@inflateBac@3:
$LN271@inflateBac@3:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  00577	83 7c 24 44 0e	 cmp	 DWORD PTR bits$[rsp], 14
  0057c	0f 83 94 00 00
	00		 jae	 $LN270@inflateBac@3
$LN269@inflateBac@3:
$LN266@inflateBac@3:
  00582	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00587	75 35		 jne	 SHORT $LN263@inflateBac@3
  00589	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0058e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00596	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0059d	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  005a1	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  005a6	75 16		 jne	 SHORT $LN262@inflateBac@3
  005a8	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  005b1	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  005b9	e9 ce 15 00 00	 jmp	 $inf_leave$78193
$LN262@inflateBac@3:
$LN263@inflateBac@3:
  005be	33 c0		 xor	 eax, eax
  005c0	85 c0		 test	 eax, eax
  005c2	75 be		 jne	 SHORT $LN266@inflateBac@3
  005c4	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  005c8	83 e8 01	 sub	 eax, 1
  005cb	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  005cf	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005d4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  005d7	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  005db	0f b6 c8	 movzx	 ecx, al
  005de	8b c2		 mov	 eax, edx
  005e0	d3 e0		 shl	 eax, cl
  005e2	8b c8		 mov	 ecx, eax
  005e4	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  005e8	03 c1		 add	 eax, ecx
  005ea	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  005ee	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005f3	48 83 c0 01	 add	 rax, 1
  005f7	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  005fc	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00600	83 c0 08	 add	 eax, 8
  00603	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00607	33 c0		 xor	 eax, eax
  00609	85 c0		 test	 eax, eax
  0060b	0f 85 71 ff ff
	ff		 jne	 $LN269@inflateBac@3
  00611	e9 61 ff ff ff	 jmp	 $LN271@inflateBac@3
$LN270@inflateBac@3:
  00616	33 c0		 xor	 eax, eax
  00618	85 c0		 test	 eax, eax
  0061a	0f 85 57 ff ff
	ff		 jne	 $LN274@inflateBac@3

; 352  :             state->nlen = BITS(5) + 257;

  00620	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00624	83 e1 1f	 and	 ecx, 31
  00627	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  0062d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00632	89 48 74	 mov	 DWORD PTR [rax+116], ecx
$LN261@inflateBac@3:

; 353  :             DROPBITS(5);

  00635	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00639	c1 e8 05	 shr	 eax, 5
  0063c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00640	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00644	83 e8 05	 sub	 eax, 5
  00647	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  0064b	33 c0		 xor	 eax, eax
  0064d	85 c0		 test	 eax, eax
  0064f	75 e4		 jne	 SHORT $LN261@inflateBac@3

; 354  :             state->ndist = BITS(5) + 1;

  00651	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00655	83 e1 1f	 and	 ecx, 31
  00658	83 c1 01	 add	 ecx, 1
  0065b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00660	89 48 78	 mov	 DWORD PTR [rax+120], ecx
$LN258@inflateBac@3:

; 355  :             DROPBITS(5);

  00663	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00667	c1 e8 05	 shr	 eax, 5
  0066a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0066e	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00672	83 e8 05	 sub	 eax, 5
  00675	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00679	33 c0		 xor	 eax, eax
  0067b	85 c0		 test	 eax, eax
  0067d	75 e4		 jne	 SHORT $LN258@inflateBac@3

; 356  :             state->ncode = BITS(4) + 4;

  0067f	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00683	83 e1 0f	 and	 ecx, 15
  00686	83 c1 04	 add	 ecx, 4
  00689	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0068e	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN255@inflateBac@3:

; 357  :             DROPBITS(4);

  00691	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00695	c1 e8 04	 shr	 eax, 4
  00698	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0069c	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  006a0	83 e8 04	 sub	 eax, 4
  006a3	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  006a7	33 c0		 xor	 eax, eax
  006a9	85 c0		 test	 eax, eax
  006ab	75 e4		 jne	 SHORT $LN255@inflateBac@3

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  006ad	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006b2	81 78 74 1e 01
	00 00		 cmp	 DWORD PTR [rax+116], 286 ; 0000011eH
  006b9	77 0b		 ja	 SHORT $LN251@inflateBac@3
  006bb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006c0	83 78 78 1e	 cmp	 DWORD PTR [rax+120], 30
  006c4	76 23		 jbe	 SHORT $LN252@inflateBac@3
$LN251@inflateBac@3:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  006c6	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  006ce	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  006d5	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 361  :                 state->mode = BAD;

  006d9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006de	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 362  :                 break;

  006e4	e9 9e 14 00 00	 jmp	 $LN341@inflateBac@3
$LN252@inflateBac@3:

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  006e9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006ee	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0
$LN250@inflateBac@3:

; 369  :             while (state->have < state->ncode) {

  006f5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  006fa	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  006ff	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  00702	39 41 7c	 cmp	 DWORD PTR [rcx+124], eax
  00705	0f 83 04 01 00
	00		 jae	 $LN249@inflateBac@3
$LN248@inflateBac@3:
$LN245@inflateBac@3:

; 370  :                 NEEDBITS(3);

  0070b	83 7c 24 44 03	 cmp	 DWORD PTR bits$[rsp], 3
  00710	0f 83 94 00 00
	00		 jae	 $LN244@inflateBac@3
$LN243@inflateBac@3:
$LN240@inflateBac@3:
  00716	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0071b	75 35		 jne	 SHORT $LN237@inflateBac@3
  0071d	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00722	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0072a	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00731	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00735	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0073a	75 16		 jne	 SHORT $LN236@inflateBac@3
  0073c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00745	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0074d	e9 3a 14 00 00	 jmp	 $inf_leave$78193
$LN236@inflateBac@3:
$LN237@inflateBac@3:
  00752	33 c0		 xor	 eax, eax
  00754	85 c0		 test	 eax, eax
  00756	75 be		 jne	 SHORT $LN240@inflateBac@3
  00758	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0075c	83 e8 01	 sub	 eax, 1
  0075f	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00763	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00768	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0076b	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0076f	0f b6 c8	 movzx	 ecx, al
  00772	8b c2		 mov	 eax, edx
  00774	d3 e0		 shl	 eax, cl
  00776	8b c8		 mov	 ecx, eax
  00778	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0077c	03 c1		 add	 eax, ecx
  0077e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00782	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00787	48 83 c0 01	 add	 rax, 1
  0078b	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00790	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00794	83 c0 08	 add	 eax, 8
  00797	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  0079b	33 c0		 xor	 eax, eax
  0079d	85 c0		 test	 eax, eax
  0079f	0f 85 71 ff ff
	ff		 jne	 $LN243@inflateBac@3
  007a5	e9 61 ff ff ff	 jmp	 $LN245@inflateBac@3
$LN244@inflateBac@3:
  007aa	33 c0		 xor	 eax, eax
  007ac	85 c0		 test	 eax, eax
  007ae	0f 85 57 ff ff
	ff		 jne	 $LN248@inflateBac@3

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  007b4	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  007b8	83 e2 07	 and	 edx, 7
  007bb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007c0	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  007c3	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflateBack@@9@9
  007ca	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  007ce	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007d3	66 89 94 48 88
	00 00 00	 mov	 WORD PTR [rax+rcx*2+136], dx
  007db	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007e0	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  007e3	83 c1 01	 add	 ecx, 1
  007e6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  007eb	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN235@inflateBac@3:

; 372  :                 DROPBITS(3);

  007ee	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  007f2	c1 e8 03	 shr	 eax, 3
  007f5	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  007f9	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  007fd	83 e8 03	 sub	 eax, 3
  00800	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00804	33 c0		 xor	 eax, eax
  00806	85 c0		 test	 eax, eax
  00808	75 e4		 jne	 SHORT $LN235@inflateBac@3

; 373  :             }

  0080a	e9 e6 fe ff ff	 jmp	 $LN250@inflateBac@3
$LN249@inflateBac@3:
$LN232@inflateBac@3:

; 374  :             while (state->have < 19)

  0080f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00814	83 78 7c 13	 cmp	 DWORD PTR [rax+124], 19
  00818	73 37		 jae	 SHORT $LN231@inflateBac@3

; 375  :                 state->lens[order[state->have++]] = 0;

  0081a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0081f	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00822	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflateBack@@9@9
  00829	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  0082d	33 c9		 xor	 ecx, ecx
  0082f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00834	66 89 8c 50 88
	00 00 00	 mov	 WORD PTR [rax+rdx*2+136], cx
  0083c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00841	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00844	83 c1 01	 add	 ecx, 1
  00847	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0084c	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  0084f	eb be		 jmp	 SHORT $LN232@inflateBac@3
$LN231@inflateBac@3:

; 376  :             state->next = state->codes;

  00851	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00856	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  0085d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00862	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 377  :             state->lencode = (code const FAR *)(state->next);

  00869	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0086e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00873	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  0087a	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 378  :             state->lenbits = 7;

  0087e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00883	c7 40 68 07 00
	00 00		 mov	 DWORD PTR [rax+104], 7

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  0088a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0088f	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  00896	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0089b	48 83 c0 68	 add	 rax, 104		; 00000068H
  0089f	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  008a4	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  008ab	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  008b0	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  008b7	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  008bc	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  008c1	41 b8 13 00 00
	00		 mov	 r8d, 19
  008c7	33 c9		 xor	 ecx, ecx
  008c9	e8 00 00 00 00	 call	 inflate_table
  008ce	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 381  :             if (ret) {

  008d2	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  008d7	74 23		 je	 SHORT $LN230@inflateBac@3

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  008d9	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  008e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  008e8	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 383  :                 state->mode = BAD;

  008ec	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  008f1	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 384  :                 break;

  008f7	e9 8b 12 00 00	 jmp	 $LN341@inflateBac@3
$LN230@inflateBac@3:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;

  008fc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00901	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0
$LN229@inflateBac@3:

; 390  :             while (state->have < state->nlen + state->ndist) {

  00908	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0090d	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  00910	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00915	03 48 78	 add	 ecx, DWORD PTR [rax+120]
  00918	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0091d	39 48 7c	 cmp	 DWORD PTR [rax+124], ecx
  00920	0f 83 f0 05 00
	00		 jae	 $LN228@inflateBac@3
$LN227@inflateBac@3:

; 391  :                 for (;;) {
; 392  :                     this = state->lencode[BITS(state->lenbits)];

  00926	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0092b	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  0092e	b8 01 00 00 00	 mov	 eax, 1
  00933	d3 e0		 shl	 eax, cl
  00935	8b c8		 mov	 ecx, eax
  00937	83 e9 01	 sub	 ecx, 1
  0093a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0093e	23 c1		 and	 eax, ecx
  00940	8b c8		 mov	 ecx, eax
  00942	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00947	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0094b	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0094e	89 44 24 60	 mov	 DWORD PTR this$[rsp], eax

; 393  :                     if ((unsigned)(this.bits) <= bits) break;

  00952	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00957	3b 44 24 44	 cmp	 eax, DWORD PTR bits$[rsp]
  0095b	77 05		 ja	 SHORT $LN225@inflateBac@3
  0095d	e9 94 00 00 00	 jmp	 $LN226@inflateBac@3
$LN225@inflateBac@3:
$LN224@inflateBac@3:
$LN221@inflateBac@3:

; 394  :                     PULLBYTE();

  00962	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00967	75 35		 jne	 SHORT $LN218@inflateBac@3
  00969	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  0096e	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00976	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  0097d	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00981	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00986	75 16		 jne	 SHORT $LN217@inflateBac@3
  00988	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00991	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00999	e9 ee 11 00 00	 jmp	 $inf_leave$78193
$LN217@inflateBac@3:
$LN218@inflateBac@3:
  0099e	33 c0		 xor	 eax, eax
  009a0	85 c0		 test	 eax, eax
  009a2	75 be		 jne	 SHORT $LN221@inflateBac@3
  009a4	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  009a8	83 e8 01	 sub	 eax, 1
  009ab	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  009af	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  009b4	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  009b7	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  009bb	0f b6 c8	 movzx	 ecx, al
  009be	8b c2		 mov	 eax, edx
  009c0	d3 e0		 shl	 eax, cl
  009c2	8b c8		 mov	 ecx, eax
  009c4	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  009c8	03 c1		 add	 eax, ecx
  009ca	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  009ce	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  009d3	48 83 c0 01	 add	 rax, 1
  009d7	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  009dc	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  009e0	83 c0 08	 add	 eax, 8
  009e3	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  009e7	33 c0		 xor	 eax, eax
  009e9	85 c0		 test	 eax, eax
  009eb	0f 85 71 ff ff
	ff		 jne	 $LN224@inflateBac@3

; 395  :                 }

  009f1	e9 30 ff ff ff	 jmp	 $LN227@inflateBac@3
$LN226@inflateBac@3:

; 396  :                 if (this.val < 16) {

  009f6	0f b7 44 24 62	 movzx	 eax, WORD PTR this$[rsp+2]
  009fb	83 f8 10	 cmp	 eax, 16
  009fe	0f 8d 06 01 00
	00		 jge	 $LN216@inflateBac@3
$LN215@inflateBac@3:
$LN212@inflateBac@3:

; 397  :                     NEEDBITS(this.bits);

  00a04	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00a09	39 44 24 44	 cmp	 DWORD PTR bits$[rsp], eax
  00a0d	0f 83 94 00 00
	00		 jae	 $LN211@inflateBac@3
$LN210@inflateBac@3:
$LN207@inflateBac@3:
  00a13	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00a18	75 35		 jne	 SHORT $LN204@inflateBac@3
  00a1a	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00a1f	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00a27	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00a2e	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00a32	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00a37	75 16		 jne	 SHORT $LN203@inflateBac@3
  00a39	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00a42	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00a4a	e9 3d 11 00 00	 jmp	 $inf_leave$78193
$LN203@inflateBac@3:
$LN204@inflateBac@3:
  00a4f	33 c0		 xor	 eax, eax
  00a51	85 c0		 test	 eax, eax
  00a53	75 be		 jne	 SHORT $LN207@inflateBac@3
  00a55	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00a59	83 e8 01	 sub	 eax, 1
  00a5c	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00a60	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a65	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00a68	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00a6c	0f b6 c8	 movzx	 ecx, al
  00a6f	8b c2		 mov	 eax, edx
  00a71	d3 e0		 shl	 eax, cl
  00a73	8b c8		 mov	 ecx, eax
  00a75	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00a79	03 c1		 add	 eax, ecx
  00a7b	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00a7f	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a84	48 83 c0 01	 add	 rax, 1
  00a88	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00a8d	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00a91	83 c0 08	 add	 eax, 8
  00a94	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00a98	33 c0		 xor	 eax, eax
  00a9a	85 c0		 test	 eax, eax
  00a9c	0f 85 71 ff ff
	ff		 jne	 $LN210@inflateBac@3
  00aa2	e9 5d ff ff ff	 jmp	 $LN212@inflateBac@3
$LN211@inflateBac@3:
  00aa7	33 c0		 xor	 eax, eax
  00aa9	85 c0		 test	 eax, eax
  00aab	0f 85 53 ff ff
	ff		 jne	 $LN215@inflateBac@3
$LN202@inflateBac@3:

; 398  :                     DROPBITS(this.bits);

  00ab1	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00ab6	0f b6 c8	 movzx	 ecx, al
  00ab9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00abd	d3 e8		 shr	 eax, cl
  00abf	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00ac3	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  00ac8	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00acc	2b c1		 sub	 eax, ecx
  00ace	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00ad2	33 c0		 xor	 eax, eax
  00ad4	85 c0		 test	 eax, eax
  00ad6	75 d9		 jne	 SHORT $LN202@inflateBac@3

; 399  :                     state->lens[state->have++] = this.val;

  00ad8	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00add	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  00ae0	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00ae5	0f b7 44 24 62	 movzx	 eax, WORD PTR this$[rsp+2]
  00aea	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  00af2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00af7	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00afa	83 c1 01	 add	 ecx, 1
  00afd	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00b02	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 400  :                 }
; 401  :                 else {

  00b05	e9 07 04 00 00	 jmp	 $LN199@inflateBac@3
$LN216@inflateBac@3:

; 402  :                     if (this.val == 16) {

  00b0a	0f b7 44 24 62	 movzx	 eax, WORD PTR this$[rsp+2]
  00b0f	83 f8 10	 cmp	 eax, 16
  00b12	0f 85 52 01 00
	00		 jne	 $LN198@inflateBac@3
$LN197@inflateBac@3:
$LN194@inflateBac@3:

; 403  :                         NEEDBITS(this.bits + 2);

  00b18	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00b1d	83 c0 02	 add	 eax, 2
  00b20	39 44 24 44	 cmp	 DWORD PTR bits$[rsp], eax
  00b24	0f 83 94 00 00
	00		 jae	 $LN193@inflateBac@3
$LN192@inflateBac@3:
$LN189@inflateBac@3:
  00b2a	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00b2f	75 35		 jne	 SHORT $LN186@inflateBac@3
  00b31	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00b36	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00b3e	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00b45	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00b49	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00b4e	75 16		 jne	 SHORT $LN185@inflateBac@3
  00b50	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00b59	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00b61	e9 26 10 00 00	 jmp	 $inf_leave$78193
$LN185@inflateBac@3:
$LN186@inflateBac@3:
  00b66	33 c0		 xor	 eax, eax
  00b68	85 c0		 test	 eax, eax
  00b6a	75 be		 jne	 SHORT $LN189@inflateBac@3
  00b6c	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00b70	83 e8 01	 sub	 eax, 1
  00b73	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00b77	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b7c	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00b7f	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00b83	0f b6 c8	 movzx	 ecx, al
  00b86	8b c2		 mov	 eax, edx
  00b88	d3 e0		 shl	 eax, cl
  00b8a	8b c8		 mov	 ecx, eax
  00b8c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00b90	03 c1		 add	 eax, ecx
  00b92	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00b96	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b9b	48 83 c0 01	 add	 rax, 1
  00b9f	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00ba4	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00ba8	83 c0 08	 add	 eax, 8
  00bab	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00baf	33 c0		 xor	 eax, eax
  00bb1	85 c0		 test	 eax, eax
  00bb3	0f 85 71 ff ff
	ff		 jne	 $LN192@inflateBac@3
  00bb9	e9 5a ff ff ff	 jmp	 $LN194@inflateBac@3
$LN193@inflateBac@3:
  00bbe	33 c0		 xor	 eax, eax
  00bc0	85 c0		 test	 eax, eax
  00bc2	0f 85 50 ff ff
	ff		 jne	 $LN197@inflateBac@3
$LN184@inflateBac@3:

; 404  :                         DROPBITS(this.bits);

  00bc8	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00bcd	0f b6 c8	 movzx	 ecx, al
  00bd0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00bd4	d3 e8		 shr	 eax, cl
  00bd6	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00bda	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  00bdf	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00be3	2b c1		 sub	 eax, ecx
  00be5	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00be9	33 c0		 xor	 eax, eax
  00beb	85 c0		 test	 eax, eax
  00bed	75 d9		 jne	 SHORT $LN184@inflateBac@3

; 405  :                         if (state->have == 0) {

  00bef	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00bf4	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  00bf8	75 23		 jne	 SHORT $LN181@inflateBac@3

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  00bfa	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00c02	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00c09	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 407  :                             state->mode = BAD;

  00c0d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c12	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 408  :                             break;

  00c18	e9 f9 02 00 00	 jmp	 $LN228@inflateBac@3
$LN181@inflateBac@3:

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);

  00c1d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c22	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  00c25	83 e8 01	 sub	 eax, 1
  00c28	8b c8		 mov	 ecx, eax
  00c2a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00c2f	0f b7 84 48 88
	00 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+136]
  00c37	89 44 24 40	 mov	 DWORD PTR len$[rsp], eax

; 411  :                         copy = 3 + BITS(2);

  00c3b	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00c3f	83 e0 03	 and	 eax, 3
  00c42	83 c0 03	 add	 eax, 3
  00c45	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN180@inflateBac@3:

; 412  :                         DROPBITS(2);

  00c49	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00c4d	c1 e8 02	 shr	 eax, 2
  00c50	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00c54	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00c58	83 e8 02	 sub	 eax, 2
  00c5b	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00c5f	33 c0		 xor	 eax, eax
  00c61	85 c0		 test	 eax, eax
  00c63	75 e4		 jne	 SHORT $LN180@inflateBac@3

; 413  :                     }
; 414  :                     else if (this.val == 17) {

  00c65	e9 25 02 00 00	 jmp	 $LN177@inflateBac@3
$LN198@inflateBac@3:
  00c6a	0f b7 44 24 62	 movzx	 eax, WORD PTR this$[rsp+2]
  00c6f	83 f8 11	 cmp	 eax, 17
  00c72	0f 85 0e 01 00
	00		 jne	 $LN176@inflateBac@3
$LN175@inflateBac@3:
$LN172@inflateBac@3:

; 415  :                         NEEDBITS(this.bits + 3);

  00c78	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00c7d	83 c0 03	 add	 eax, 3
  00c80	39 44 24 44	 cmp	 DWORD PTR bits$[rsp], eax
  00c84	0f 83 94 00 00
	00		 jae	 $LN171@inflateBac@3
$LN170@inflateBac@3:
$LN167@inflateBac@3:
  00c8a	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00c8f	75 35		 jne	 SHORT $LN164@inflateBac@3
  00c91	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00c96	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00c9e	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00ca5	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00ca9	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00cae	75 16		 jne	 SHORT $LN163@inflateBac@3
  00cb0	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00cb9	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00cc1	e9 c6 0e 00 00	 jmp	 $inf_leave$78193
$LN163@inflateBac@3:
$LN164@inflateBac@3:
  00cc6	33 c0		 xor	 eax, eax
  00cc8	85 c0		 test	 eax, eax
  00cca	75 be		 jne	 SHORT $LN167@inflateBac@3
  00ccc	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00cd0	83 e8 01	 sub	 eax, 1
  00cd3	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00cd7	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00cdc	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00cdf	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00ce3	0f b6 c8	 movzx	 ecx, al
  00ce6	8b c2		 mov	 eax, edx
  00ce8	d3 e0		 shl	 eax, cl
  00cea	8b c8		 mov	 ecx, eax
  00cec	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00cf0	03 c1		 add	 eax, ecx
  00cf2	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00cf6	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00cfb	48 83 c0 01	 add	 rax, 1
  00cff	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00d04	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00d08	83 c0 08	 add	 eax, 8
  00d0b	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00d0f	33 c0		 xor	 eax, eax
  00d11	85 c0		 test	 eax, eax
  00d13	0f 85 71 ff ff
	ff		 jne	 $LN170@inflateBac@3
  00d19	e9 5a ff ff ff	 jmp	 $LN172@inflateBac@3
$LN171@inflateBac@3:
  00d1e	33 c0		 xor	 eax, eax
  00d20	85 c0		 test	 eax, eax
  00d22	0f 85 50 ff ff
	ff		 jne	 $LN175@inflateBac@3
$LN162@inflateBac@3:

; 416  :                         DROPBITS(this.bits);

  00d28	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00d2d	0f b6 c8	 movzx	 ecx, al
  00d30	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d34	d3 e8		 shr	 eax, cl
  00d36	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00d3a	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  00d3f	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00d43	2b c1		 sub	 eax, ecx
  00d45	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00d49	33 c0		 xor	 eax, eax
  00d4b	85 c0		 test	 eax, eax
  00d4d	75 d9		 jne	 SHORT $LN162@inflateBac@3

; 417  :                         len = 0;

  00d4f	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 418  :                         copy = 3 + BITS(3);

  00d57	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d5b	83 e0 07	 and	 eax, 7
  00d5e	83 c0 03	 add	 eax, 3
  00d61	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN159@inflateBac@3:

; 419  :                         DROPBITS(3);

  00d65	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00d69	c1 e8 03	 shr	 eax, 3
  00d6c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00d70	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00d74	83 e8 03	 sub	 eax, 3
  00d77	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00d7b	33 c0		 xor	 eax, eax
  00d7d	85 c0		 test	 eax, eax
  00d7f	75 e4		 jne	 SHORT $LN159@inflateBac@3

; 420  :                     }
; 421  :                     else {

  00d81	e9 09 01 00 00	 jmp	 $LN156@inflateBac@3
$LN176@inflateBac@3:
$LN155@inflateBac@3:
$LN152@inflateBac@3:

; 422  :                         NEEDBITS(this.bits + 7);

  00d86	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00d8b	83 c0 07	 add	 eax, 7
  00d8e	39 44 24 44	 cmp	 DWORD PTR bits$[rsp], eax
  00d92	0f 83 94 00 00
	00		 jae	 $LN151@inflateBac@3
$LN150@inflateBac@3:
$LN147@inflateBac@3:
  00d98	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00d9d	75 35		 jne	 SHORT $LN144@inflateBac@3
  00d9f	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  00da4	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  00dac	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  00db3	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00db7	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00dbc	75 16		 jne	 SHORT $LN143@inflateBac@3
  00dbe	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  00dc7	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  00dcf	e9 b8 0d 00 00	 jmp	 $inf_leave$78193
$LN143@inflateBac@3:
$LN144@inflateBac@3:
  00dd4	33 c0		 xor	 eax, eax
  00dd6	85 c0		 test	 eax, eax
  00dd8	75 be		 jne	 SHORT $LN147@inflateBac@3
  00dda	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00dde	83 e8 01	 sub	 eax, 1
  00de1	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00de5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00dea	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00ded	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00df1	0f b6 c8	 movzx	 ecx, al
  00df4	8b c2		 mov	 eax, edx
  00df6	d3 e0		 shl	 eax, cl
  00df8	8b c8		 mov	 ecx, eax
  00dfa	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00dfe	03 c1		 add	 eax, ecx
  00e00	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e04	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00e09	48 83 c0 01	 add	 rax, 1
  00e0d	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00e12	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00e16	83 c0 08	 add	 eax, 8
  00e19	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00e1d	33 c0		 xor	 eax, eax
  00e1f	85 c0		 test	 eax, eax
  00e21	0f 85 71 ff ff
	ff		 jne	 $LN150@inflateBac@3
  00e27	e9 5a ff ff ff	 jmp	 $LN152@inflateBac@3
$LN151@inflateBac@3:
  00e2c	33 c0		 xor	 eax, eax
  00e2e	85 c0		 test	 eax, eax
  00e30	0f 85 50 ff ff
	ff		 jne	 $LN155@inflateBac@3
$LN142@inflateBac@3:

; 423  :                         DROPBITS(this.bits);

  00e36	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  00e3b	0f b6 c8	 movzx	 ecx, al
  00e3e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e42	d3 e8		 shr	 eax, cl
  00e44	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e48	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  00e4d	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00e51	2b c1		 sub	 eax, ecx
  00e53	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00e57	33 c0		 xor	 eax, eax
  00e59	85 c0		 test	 eax, eax
  00e5b	75 d9		 jne	 SHORT $LN142@inflateBac@3

; 424  :                         len = 0;

  00e5d	c7 44 24 40 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 425  :                         copy = 11 + BITS(7);

  00e65	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e69	83 e0 7f	 and	 eax, 127		; 0000007fH
  00e6c	83 c0 0b	 add	 eax, 11
  00e6f	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN139@inflateBac@3:

; 426  :                         DROPBITS(7);

  00e73	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e77	c1 e8 07	 shr	 eax, 7
  00e7a	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e7e	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  00e82	83 e8 07	 sub	 eax, 7
  00e85	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  00e89	33 c0		 xor	 eax, eax
  00e8b	85 c0		 test	 eax, eax
  00e8d	75 e4		 jne	 SHORT $LN139@inflateBac@3
$LN156@inflateBac@3:
$LN177@inflateBac@3:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00e8f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00e94	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  00e97	03 54 24 64	 add	 edx, DWORD PTR copy$[rsp]
  00e9b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ea0	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  00ea3	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00ea8	03 41 78	 add	 eax, DWORD PTR [rcx+120]
  00eab	3b d0		 cmp	 edx, eax
  00ead	76 20		 jbe	 SHORT $LN136@inflateBac@3

; 429  :                         strm->msg = (char *)"invalid bit length repeat";

  00eaf	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00eb7	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  00ebe	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 430  :                         state->mode = BAD;

  00ec2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ec7	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 431  :                         break;

  00ecd	eb 47		 jmp	 SHORT $LN228@inflateBac@3
$LN136@inflateBac@3:
$LN135@inflateBac@3:

; 432  :                     }
; 433  :                     while (copy--)

  00ecf	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  00ed3	8b 44 24 64	 mov	 eax, DWORD PTR copy$[rsp]
  00ed7	83 e8 01	 sub	 eax, 1
  00eda	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
  00ede	85 c9		 test	 ecx, ecx
  00ee0	74 2f		 je	 SHORT $LN134@inflateBac@3

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00ee2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ee7	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  00eea	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00eef	0f b7 44 24 40	 movzx	 eax, WORD PTR len$[rsp]
  00ef4	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  00efc	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f01	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  00f04	83 c1 01	 add	 ecx, 1
  00f07	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f0c	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  00f0f	eb be		 jmp	 SHORT $LN135@inflateBac@3
$LN134@inflateBac@3:
$LN199@inflateBac@3:

; 435  :                 }
; 436  :             }

  00f11	e9 f2 f9 ff ff	 jmp	 $LN229@inflateBac@3
$LN228@inflateBac@3:

; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00f16	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f1b	83 38 1b	 cmp	 DWORD PTR [rax], 27
  00f1e	75 05		 jne	 SHORT $LN133@inflateBac@3
  00f20	e9 62 0c 00 00	 jmp	 $LN341@inflateBac@3
$LN133@inflateBac@3:

; 440  : 
; 441  :             /* build code tables */
; 442  :             state->next = state->codes;

  00f25	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f2a	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  00f31	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f36	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 443  :             state->lencode = (code const FAR *)(state->next);

  00f3d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f42	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f47	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00f4e	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 444  :             state->lenbits = 9;

  00f52	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f57	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 445  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 446  :                                 &(state->lenbits), state->work);

  00f5e	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00f63	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  00f6a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f6f	48 83 c0 68	 add	 rax, 104		; 00000068H
  00f73	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  00f78	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  00f7f	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  00f84	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  00f8b	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  00f90	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  00f95	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00f9a	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  00f9e	b9 01 00 00 00	 mov	 ecx, 1
  00fa3	e8 00 00 00 00	 call	 inflate_table
  00fa8	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 447  :             if (ret) {

  00fac	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  00fb1	74 23		 je	 SHORT $LN132@inflateBac@3

; 448  :                 strm->msg = (char *)"invalid literal/lengths set";

  00fb3	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00fbb	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  00fc2	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 449  :                 state->mode = BAD;

  00fc6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00fcb	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 450  :                 break;

  00fd1	e9 b1 0b 00 00	 jmp	 $LN341@inflateBac@3
$LN132@inflateBac@3:

; 451  :             }
; 452  :             state->distcode = (code const FAR *)(state->next);

  00fd6	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  00fdb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00fe0	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00fe7	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 453  :             state->distbits = 6;

  00feb	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  00ff0	c7 40 6c 06 00
	00 00		 mov	 DWORD PTR [rax+108], 6

; 454  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 455  :                             &(state->next), &(state->distbits), state->work);

  00ff7	4c 8b 54 24 70	 mov	 r10, QWORD PTR state$[rsp]
  00ffc	49 81 c2 08 03
	00 00		 add	 r10, 776		; 00000308H
  01003	4c 8b 44 24 70	 mov	 r8, QWORD PTR state$[rsp]
  01008	49 83 c0 6c	 add	 r8, 108			; 0000006cH
  0100c	4c 8b 4c 24 70	 mov	 r9, QWORD PTR state$[rsp]
  01011	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  01018	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0101d	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  01020	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01025	48 8d 94 48 88
	00 00 00	 lea	 rdx, QWORD PTR [rax+rcx*2+136]
  0102d	4c 89 54 24 28	 mov	 QWORD PTR [rsp+40], r10
  01032	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  01037	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0103c	44 8b 40 78	 mov	 r8d, DWORD PTR [rax+120]
  01040	b9 02 00 00 00	 mov	 ecx, 2
  01045	e8 00 00 00 00	 call	 inflate_table
  0104a	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 456  :             if (ret) {

  0104e	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  01053	74 23		 je	 SHORT $LN131@inflateBac@3

; 457  :                 strm->msg = (char *)"invalid distances set";

  01055	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0105d	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  01064	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 458  :                 state->mode = BAD;

  01068	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0106d	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 459  :                 break;

  01073	e9 0f 0b 00 00	 jmp	 $LN341@inflateBac@3
$LN131@inflateBac@3:

; 460  :             }
; 461  :             Tracev((stderr, "inflate:       codes ok\n"));
; 462  :             state->mode = LEN;

  01078	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0107d	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18
$LN130@inflateBac@3:

; 463  : 
; 464  :         case LEN:
; 465  :             /* use inflate_fast() if we have enough input and output */
; 466  :             if (have >= 6 && left >= 258) {

  01083	83 7c 24 3c 06	 cmp	 DWORD PTR have$[rsp], 6
  01088	0f 82 0a 01 00
	00		 jb	 $LN129@inflateBac@3
  0108e	81 7c 24 48 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  01096	0f 82 fc 00 00
	00		 jb	 $LN129@inflateBac@3
$LN128@inflateBac@3:

; 467  :                 RESTORE();

  0109c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010a4	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  010a9	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  010ad	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010b5	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  010b9	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  010bc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010c4	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  010c9	48 89 01	 mov	 QWORD PTR [rcx], rax
  010cc	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010d4	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  010d8	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  010db	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  010e0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  010e4	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  010e7	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  010ec	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  010f0	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  010f3	33 c0		 xor	 eax, eax
  010f5	85 c0		 test	 eax, eax
  010f7	75 a3		 jne	 SHORT $LN128@inflateBac@3

; 468  :                 if (state->whave < state->wsize)

  010f9	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  010fe	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01103	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01106	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  01109	73 16		 jae	 SHORT $LN125@inflateBac@3

; 469  :                     state->whave = state->wsize - left;

  0110b	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01110	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01114	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  01117	2b c8		 sub	 ecx, eax
  01119	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0111e	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN125@inflateBac@3:

; 470  :                 inflate_fast(strm, state->wsize);

  01121	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01126	8b 50 2c	 mov	 edx, DWORD PTR [rax+44]
  01129	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01131	e8 00 00 00 00	 call	 inflate_fast
$LN124@inflateBac@3:

; 471  :                 LOAD();

  01136	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0113e	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01142	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01147	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0114f	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01152	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax
  01156	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0115e	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01161	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01166	48 8b 84 24 a0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0116e	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01171	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01175	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0117a	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  0117d	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01181	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01186	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  01189	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  0118d	33 c0		 xor	 eax, eax
  0118f	85 c0		 test	 eax, eax
  01191	75 a3		 jne	 SHORT $LN124@inflateBac@3

; 472  :                 break;

  01193	e9 ef 09 00 00	 jmp	 $LN341@inflateBac@3
$LN129@inflateBac@3:
$LN121@inflateBac@3:

; 473  :             }
; 474  : 
; 475  :             /* get a literal, length, or end-of-block code */
; 476  :             for (;;) {
; 477  :                 this = state->lencode[BITS(state->lenbits)];

  01198	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0119d	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  011a0	b8 01 00 00 00	 mov	 eax, 1
  011a5	d3 e0		 shl	 eax, cl
  011a7	8b c8		 mov	 ecx, eax
  011a9	83 e9 01	 sub	 ecx, 1
  011ac	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  011b0	23 c1		 and	 eax, ecx
  011b2	8b c8		 mov	 ecx, eax
  011b4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  011b9	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  011bd	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  011c0	89 44 24 60	 mov	 DWORD PTR this$[rsp], eax

; 478  :                 if ((unsigned)(this.bits) <= bits) break;

  011c4	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  011c9	3b 44 24 44	 cmp	 eax, DWORD PTR bits$[rsp]
  011cd	77 05		 ja	 SHORT $LN119@inflateBac@3
  011cf	e9 94 00 00 00	 jmp	 $LN120@inflateBac@3
$LN119@inflateBac@3:
$LN118@inflateBac@3:
$LN115@inflateBac@3:

; 479  :                 PULLBYTE();

  011d4	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  011d9	75 35		 jne	 SHORT $LN112@inflateBac@3
  011db	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  011e0	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  011e8	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  011ef	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  011f3	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  011f8	75 16		 jne	 SHORT $LN111@inflateBac@3
  011fa	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01203	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0120b	e9 7c 09 00 00	 jmp	 $inf_leave$78193
$LN111@inflateBac@3:
$LN112@inflateBac@3:
  01210	33 c0		 xor	 eax, eax
  01212	85 c0		 test	 eax, eax
  01214	75 be		 jne	 SHORT $LN115@inflateBac@3
  01216	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0121a	83 e8 01	 sub	 eax, 1
  0121d	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01221	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01226	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01229	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0122d	0f b6 c8	 movzx	 ecx, al
  01230	8b c2		 mov	 eax, edx
  01232	d3 e0		 shl	 eax, cl
  01234	8b c8		 mov	 ecx, eax
  01236	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0123a	03 c1		 add	 eax, ecx
  0123c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01240	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01245	48 83 c0 01	 add	 rax, 1
  01249	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  0124e	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  01252	83 c0 08	 add	 eax, 8
  01255	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  01259	33 c0		 xor	 eax, eax
  0125b	85 c0		 test	 eax, eax
  0125d	0f 85 71 ff ff
	ff		 jne	 $LN118@inflateBac@3

; 480  :             }

  01263	e9 30 ff ff ff	 jmp	 $LN121@inflateBac@3
$LN120@inflateBac@3:

; 481  :             if (this.op && (this.op & 0xf0) == 0) {

  01268	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  0126d	85 c0		 test	 eax, eax
  0126f	0f 84 33 01 00
	00		 je	 $LN110@inflateBac@3
  01275	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  0127a	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  0127f	85 c0		 test	 eax, eax
  01281	0f 85 21 01 00
	00		 jne	 $LN110@inflateBac@3

; 482  :                 last = this;

  01287	8b 44 24 60	 mov	 eax, DWORD PTR this$[rsp]
  0128b	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN109@inflateBac@3:

; 483  :                 for (;;) {
; 484  :                     this = state->lencode[last.val +
; 485  :                             (BITS(last.bits + last.op) >> last.bits)];

  0128f	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  01295	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  0129a	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  0129f	03 c8		 add	 ecx, eax
  012a1	b8 01 00 00 00	 mov	 eax, 1
  012a6	d3 e0		 shl	 eax, cl
  012a8	83 e8 01	 sub	 eax, 1
  012ab	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  012af	23 d0		 and	 edx, eax
  012b1	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  012b6	0f b6 c8	 movzx	 ecx, al
  012b9	8b c2		 mov	 eax, edx
  012bb	d3 e8		 shr	 eax, cl
  012bd	8b c8		 mov	 ecx, eax
  012bf	41 8b c0	 mov	 eax, r8d
  012c2	03 c1		 add	 eax, ecx
  012c4	8b c8		 mov	 ecx, eax
  012c6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  012cb	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  012cf	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  012d2	89 44 24 60	 mov	 DWORD PTR this$[rsp], eax

; 486  :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  012d6	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  012db	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  012e0	03 c1		 add	 eax, ecx
  012e2	3b 44 24 44	 cmp	 eax, DWORD PTR bits$[rsp]
  012e6	77 05		 ja	 SHORT $LN107@inflateBac@3
  012e8	e9 94 00 00 00	 jmp	 $LN108@inflateBac@3
$LN107@inflateBac@3:
$LN106@inflateBac@3:
$LN103@inflateBac@3:

; 487  :                     PULLBYTE();

  012ed	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  012f2	75 35		 jne	 SHORT $LN100@inflateBac@3
  012f4	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  012f9	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01301	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01308	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  0130c	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01311	75 16		 jne	 SHORT $LN99@inflateBac@3
  01313	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0131c	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01324	e9 63 08 00 00	 jmp	 $inf_leave$78193
$LN99@inflateBac@3:
$LN100@inflateBac@3:
  01329	33 c0		 xor	 eax, eax
  0132b	85 c0		 test	 eax, eax
  0132d	75 be		 jne	 SHORT $LN103@inflateBac@3
  0132f	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01333	83 e8 01	 sub	 eax, 1
  01336	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  0133a	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0133f	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01342	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  01346	0f b6 c8	 movzx	 ecx, al
  01349	8b c2		 mov	 eax, edx
  0134b	d3 e0		 shl	 eax, cl
  0134d	8b c8		 mov	 ecx, eax
  0134f	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01353	03 c1		 add	 eax, ecx
  01355	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01359	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0135e	48 83 c0 01	 add	 rax, 1
  01362	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01367	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0136b	83 c0 08	 add	 eax, 8
  0136e	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  01372	33 c0		 xor	 eax, eax
  01374	85 c0		 test	 eax, eax
  01376	0f 85 71 ff ff
	ff		 jne	 $LN106@inflateBac@3

; 488  :                 }

  0137c	e9 0e ff ff ff	 jmp	 $LN109@inflateBac@3
$LN108@inflateBac@3:
$LN98@inflateBac@3:

; 489  :                 DROPBITS(last.bits);

  01381	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01386	0f b6 c8	 movzx	 ecx, al
  01389	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0138d	d3 e8		 shr	 eax, cl
  0138f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01393	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  01398	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0139c	2b c1		 sub	 eax, ecx
  0139e	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  013a2	33 c0		 xor	 eax, eax
  013a4	85 c0		 test	 eax, eax
  013a6	75 d9		 jne	 SHORT $LN98@inflateBac@3
$LN110@inflateBac@3:
$LN95@inflateBac@3:

; 490  :             }
; 491  :             DROPBITS(this.bits);

  013a8	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  013ad	0f b6 c8	 movzx	 ecx, al
  013b0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  013b4	d3 e8		 shr	 eax, cl
  013b6	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  013ba	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  013bf	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  013c3	2b c1		 sub	 eax, ecx
  013c5	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  013c9	33 c0		 xor	 eax, eax
  013cb	85 c0		 test	 eax, eax
  013cd	75 d9		 jne	 SHORT $LN95@inflateBac@3

; 492  :             state->length = (unsigned)this.val;

  013cf	0f b7 4c 24 62	 movzx	 ecx, WORD PTR this$[rsp+2]
  013d4	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  013d9	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 493  : 
; 494  :             /* process literal */
; 495  :             if (this.op == 0) {

  013dc	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  013e1	85 c0		 test	 eax, eax
  013e3	0f 85 96 00 00
	00		 jne	 $LN92@inflateBac@3
$LN91@inflateBac@3:

; 496  :                 Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
; 497  :                         "inflate:         literal '%c'\n" :
; 498  :                         "inflate:         literal 0x%02x\n", this.val));
; 499  :                 ROOM();

  013e9	83 7c 24 48 00	 cmp	 DWORD PTR left$[rsp], 0
  013ee	75 50		 jne	 SHORT $LN88@inflateBac@3
  013f0	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  013f5	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  013f9	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  013fe	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01403	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01406	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax
  0140a	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0140f	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01413	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  01416	44 8b 44 24 48	 mov	 r8d, DWORD PTR left$[rsp]
  0141b	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  01420	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01428	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  0142f	85 c0		 test	 eax, eax
  01431	74 0d		 je	 SHORT $LN87@inflateBac@3
  01433	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0143b	e9 4c 07 00 00	 jmp	 $inf_leave$78193
$LN87@inflateBac@3:
$LN88@inflateBac@3:
  01440	33 c0		 xor	 eax, eax
  01442	85 c0		 test	 eax, eax
  01444	75 a3		 jne	 SHORT $LN91@inflateBac@3

; 500  :                 *put++ = (unsigned char)(state->length);

  01446	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  0144b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01450	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  01454	88 01		 mov	 BYTE PTR [rcx], al
  01456	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  0145b	48 83 c0 01	 add	 rax, 1
  0145f	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 501  :                 left--;

  01464	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01468	83 e8 01	 sub	 eax, 1
  0146b	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax

; 502  :                 state->mode = LEN;

  0146f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01474	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18

; 503  :                 break;

  0147a	e9 08 07 00 00	 jmp	 $LN341@inflateBac@3
$LN92@inflateBac@3:

; 504  :             }
; 505  : 
; 506  :             /* process end of block */
; 507  :             if (this.op & 32) {

  0147f	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  01484	83 e0 20	 and	 eax, 32			; 00000020H
  01487	85 c0		 test	 eax, eax
  01489	74 10		 je	 SHORT $LN86@inflateBac@3

; 508  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 509  :                 state->mode = TYPE;

  0148b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01490	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 510  :                 break;

  01496	e9 ec 06 00 00	 jmp	 $LN341@inflateBac@3
$LN86@inflateBac@3:

; 511  :             }
; 512  : 
; 513  :             /* invalid code */
; 514  :             if (this.op & 64) {

  0149b	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  014a0	83 e0 40	 and	 eax, 64			; 00000040H
  014a3	85 c0		 test	 eax, eax
  014a5	74 23		 je	 SHORT $LN85@inflateBac@3

; 515  :                 strm->msg = (char *)"invalid literal/length code";

  014a7	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  014af	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  014b6	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 516  :                 state->mode = BAD;

  014ba	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014bf	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 517  :                 break;

  014c5	e9 bd 06 00 00	 jmp	 $LN341@inflateBac@3
$LN85@inflateBac@3:

; 518  :             }
; 519  : 
; 520  :             /* length code -- get extra bits, if any */
; 521  :             state->extra = (unsigned)(this.op) & 15;

  014ca	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR this$[rsp]
  014cf	83 e1 0f	 and	 ecx, 15
  014d2	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014d7	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 522  :             if (state->extra != 0) {

  014da	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014df	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  014e3	0f 84 05 01 00
	00		 je	 $LN84@inflateBac@3
$LN83@inflateBac@3:
$LN80@inflateBac@3:

; 523  :                 NEEDBITS(state->extra);

  014e9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  014ee	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  014f1	39 44 24 44	 cmp	 DWORD PTR bits$[rsp], eax
  014f5	0f 83 94 00 00
	00		 jae	 $LN79@inflateBac@3
$LN78@inflateBac@3:
$LN75@inflateBac@3:
  014fb	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01500	75 35		 jne	 SHORT $LN72@inflateBac@3
  01502	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01507	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0150f	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01516	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  0151a	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0151f	75 16		 jne	 SHORT $LN71@inflateBac@3
  01521	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  0152a	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01532	e9 55 06 00 00	 jmp	 $inf_leave$78193
$LN71@inflateBac@3:
$LN72@inflateBac@3:
  01537	33 c0		 xor	 eax, eax
  01539	85 c0		 test	 eax, eax
  0153b	75 be		 jne	 SHORT $LN75@inflateBac@3
  0153d	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01541	83 e8 01	 sub	 eax, 1
  01544	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01548	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0154d	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01550	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  01554	0f b6 c8	 movzx	 ecx, al
  01557	8b c2		 mov	 eax, edx
  01559	d3 e0		 shl	 eax, cl
  0155b	8b c8		 mov	 ecx, eax
  0155d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01561	03 c1		 add	 eax, ecx
  01563	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01567	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0156c	48 83 c0 01	 add	 rax, 1
  01570	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01575	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  01579	83 c0 08	 add	 eax, 8
  0157c	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  01580	33 c0		 xor	 eax, eax
  01582	85 c0		 test	 eax, eax
  01584	0f 85 71 ff ff
	ff		 jne	 $LN78@inflateBac@3
  0158a	e9 5a ff ff ff	 jmp	 $LN80@inflateBac@3
$LN79@inflateBac@3:
  0158f	33 c0		 xor	 eax, eax
  01591	85 c0		 test	 eax, eax
  01593	0f 85 50 ff ff
	ff		 jne	 $LN83@inflateBac@3

; 524  :                 state->length += BITS(state->extra);

  01599	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0159e	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  015a1	b8 01 00 00 00	 mov	 eax, 1
  015a6	d3 e0		 shl	 eax, cl
  015a8	83 e8 01	 sub	 eax, 1
  015ab	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  015af	23 c8		 and	 ecx, eax
  015b1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015b6	03 48 48	 add	 ecx, DWORD PTR [rax+72]
  015b9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015be	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN70@inflateBac@3:

; 525  :                 DROPBITS(state->extra);

  015c1	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015c6	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  015c9	0f b6 c8	 movzx	 ecx, al
  015cc	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  015d0	d3 e8		 shr	 eax, cl
  015d2	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  015d6	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015db	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  015de	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  015e2	2b c1		 sub	 eax, ecx
  015e4	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  015e8	33 c0		 xor	 eax, eax
  015ea	85 c0		 test	 eax, eax
  015ec	75 d3		 jne	 SHORT $LN70@inflateBac@3
$LN84@inflateBac@3:
$LN67@inflateBac@3:

; 526  :             }
; 527  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 528  : 
; 529  :             /* get distance code */
; 530  :             for (;;) {
; 531  :                 this = state->distcode[BITS(state->distbits)];

  015ee	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  015f3	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  015f6	b8 01 00 00 00	 mov	 eax, 1
  015fb	d3 e0		 shl	 eax, cl
  015fd	8b c8		 mov	 ecx, eax
  015ff	83 e9 01	 sub	 ecx, 1
  01602	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01606	23 c1		 and	 eax, ecx
  01608	8b c8		 mov	 ecx, eax
  0160a	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0160f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01613	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01616	89 44 24 60	 mov	 DWORD PTR this$[rsp], eax

; 532  :                 if ((unsigned)(this.bits) <= bits) break;

  0161a	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  0161f	3b 44 24 44	 cmp	 eax, DWORD PTR bits$[rsp]
  01623	77 05		 ja	 SHORT $LN65@inflateBac@3
  01625	e9 94 00 00 00	 jmp	 $LN66@inflateBac@3
$LN65@inflateBac@3:
$LN64@inflateBac@3:
$LN61@inflateBac@3:

; 533  :                 PULLBYTE();

  0162a	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0162f	75 35		 jne	 SHORT $LN58@inflateBac@3
  01631	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01636	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0163e	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01645	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01649	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0164e	75 16		 jne	 SHORT $LN57@inflateBac@3
  01650	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01659	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01661	e9 26 05 00 00	 jmp	 $inf_leave$78193
$LN57@inflateBac@3:
$LN58@inflateBac@3:
  01666	33 c0		 xor	 eax, eax
  01668	85 c0		 test	 eax, eax
  0166a	75 be		 jne	 SHORT $LN61@inflateBac@3
  0166c	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01670	83 e8 01	 sub	 eax, 1
  01673	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01677	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0167c	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0167f	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  01683	0f b6 c8	 movzx	 ecx, al
  01686	8b c2		 mov	 eax, edx
  01688	d3 e0		 shl	 eax, cl
  0168a	8b c8		 mov	 ecx, eax
  0168c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01690	03 c1		 add	 eax, ecx
  01692	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01696	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0169b	48 83 c0 01	 add	 rax, 1
  0169f	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  016a4	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  016a8	83 c0 08	 add	 eax, 8
  016ab	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  016af	33 c0		 xor	 eax, eax
  016b1	85 c0		 test	 eax, eax
  016b3	0f 85 71 ff ff
	ff		 jne	 $LN64@inflateBac@3

; 534  :             }

  016b9	e9 30 ff ff ff	 jmp	 $LN67@inflateBac@3
$LN66@inflateBac@3:

; 535  :             if ((this.op & 0xf0) == 0) {

  016be	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  016c3	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  016c8	85 c0		 test	 eax, eax
  016ca	0f 85 21 01 00
	00		 jne	 $LN56@inflateBac@3

; 536  :                 last = this;

  016d0	8b 44 24 60	 mov	 eax, DWORD PTR this$[rsp]
  016d4	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN55@inflateBac@3:

; 537  :                 for (;;) {
; 538  :                     this = state->distcode[last.val +
; 539  :                             (BITS(last.bits + last.op) >> last.bits)];

  016d8	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  016de	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  016e3	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  016e8	03 c8		 add	 ecx, eax
  016ea	b8 01 00 00 00	 mov	 eax, 1
  016ef	d3 e0		 shl	 eax, cl
  016f1	83 e8 01	 sub	 eax, 1
  016f4	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  016f8	23 d0		 and	 edx, eax
  016fa	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  016ff	0f b6 c8	 movzx	 ecx, al
  01702	8b c2		 mov	 eax, edx
  01704	d3 e8		 shr	 eax, cl
  01706	8b c8		 mov	 ecx, eax
  01708	41 8b c0	 mov	 eax, r8d
  0170b	03 c1		 add	 eax, ecx
  0170d	8b c8		 mov	 ecx, eax
  0170f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01714	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  01718	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0171b	89 44 24 60	 mov	 DWORD PTR this$[rsp], eax

; 540  :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  0171f	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  01724	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  01729	03 c1		 add	 eax, ecx
  0172b	3b 44 24 44	 cmp	 eax, DWORD PTR bits$[rsp]
  0172f	77 05		 ja	 SHORT $LN53@inflateBac@3
  01731	e9 94 00 00 00	 jmp	 $LN54@inflateBac@3
$LN53@inflateBac@3:
$LN52@inflateBac@3:
$LN49@inflateBac@3:

; 541  :                     PULLBYTE();

  01736	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0173b	75 35		 jne	 SHORT $LN46@inflateBac@3
  0173d	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01742	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  0174a	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  01751	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01755	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0175a	75 16		 jne	 SHORT $LN45@inflateBac@3
  0175c	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  01765	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  0176d	e9 1a 04 00 00	 jmp	 $inf_leave$78193
$LN45@inflateBac@3:
$LN46@inflateBac@3:
  01772	33 c0		 xor	 eax, eax
  01774	85 c0		 test	 eax, eax
  01776	75 be		 jne	 SHORT $LN49@inflateBac@3
  01778	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0177c	83 e8 01	 sub	 eax, 1
  0177f	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01783	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01788	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0178b	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0178f	0f b6 c8	 movzx	 ecx, al
  01792	8b c2		 mov	 eax, edx
  01794	d3 e0		 shl	 eax, cl
  01796	8b c8		 mov	 ecx, eax
  01798	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0179c	03 c1		 add	 eax, ecx
  0179e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  017a2	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  017a7	48 83 c0 01	 add	 rax, 1
  017ab	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  017b0	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  017b4	83 c0 08	 add	 eax, 8
  017b7	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  017bb	33 c0		 xor	 eax, eax
  017bd	85 c0		 test	 eax, eax
  017bf	0f 85 71 ff ff
	ff		 jne	 $LN52@inflateBac@3

; 542  :                 }

  017c5	e9 0e ff ff ff	 jmp	 $LN55@inflateBac@3
$LN54@inflateBac@3:
$LN44@inflateBac@3:

; 543  :                 DROPBITS(last.bits);

  017ca	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  017cf	0f b6 c8	 movzx	 ecx, al
  017d2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  017d6	d3 e8		 shr	 eax, cl
  017d8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  017dc	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  017e1	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  017e5	2b c1		 sub	 eax, ecx
  017e7	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  017eb	33 c0		 xor	 eax, eax
  017ed	85 c0		 test	 eax, eax
  017ef	75 d9		 jne	 SHORT $LN44@inflateBac@3
$LN56@inflateBac@3:
$LN41@inflateBac@3:

; 544  :             }
; 545  :             DROPBITS(this.bits);

  017f1	0f b6 44 24 61	 movzx	 eax, BYTE PTR this$[rsp+1]
  017f6	0f b6 c8	 movzx	 ecx, al
  017f9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  017fd	d3 e8		 shr	 eax, cl
  017ff	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01803	0f b6 4c 24 61	 movzx	 ecx, BYTE PTR this$[rsp+1]
  01808	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0180c	2b c1		 sub	 eax, ecx
  0180e	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  01812	33 c0		 xor	 eax, eax
  01814	85 c0		 test	 eax, eax
  01816	75 d9		 jne	 SHORT $LN41@inflateBac@3

; 546  :             if (this.op & 64) {

  01818	0f b6 44 24 60	 movzx	 eax, BYTE PTR this$[rsp]
  0181d	83 e0 40	 and	 eax, 64			; 00000040H
  01820	85 c0		 test	 eax, eax
  01822	74 23		 je	 SHORT $LN38@inflateBac@3

; 547  :                 strm->msg = (char *)"invalid distance code";

  01824	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0182c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  01833	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 548  :                 state->mode = BAD;

  01837	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  0183c	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 549  :                 break;

  01842	e9 40 03 00 00	 jmp	 $LN341@inflateBac@3
$LN38@inflateBac@3:

; 550  :             }
; 551  :             state->offset = (unsigned)this.val;

  01847	0f b7 4c 24 62	 movzx	 ecx, WORD PTR this$[rsp+2]
  0184c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01851	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 552  : 
; 553  :             /* get distance extra bits, if any */
; 554  :             state->extra = (unsigned)(this.op) & 15;

  01854	0f b6 4c 24 60	 movzx	 ecx, BYTE PTR this$[rsp]
  01859	83 e1 0f	 and	 ecx, 15
  0185c	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01861	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 555  :             if (state->extra != 0) {

  01864	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01869	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  0186d	0f 84 05 01 00
	00		 je	 $LN37@inflateBac@3
$LN36@inflateBac@3:
$LN33@inflateBac@3:

; 556  :                 NEEDBITS(state->extra);

  01873	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01878	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  0187b	39 44 24 44	 cmp	 DWORD PTR bits$[rsp], eax
  0187f	0f 83 94 00 00
	00		 jae	 $LN32@inflateBac@3
$LN31@inflateBac@3:
$LN28@inflateBac@3:
  01885	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0188a	75 35		 jne	 SHORT $LN25@inflateBac@3
  0188c	48 8d 54 24 50	 lea	 rdx, QWORD PTR next$[rsp]
  01891	48 8b 8c 24 b0
	00 00 00	 mov	 rcx, QWORD PTR in_desc$[rsp]
  01899	ff 94 24 a8 00
	00 00		 call	 QWORD PTR in$[rsp]
  018a0	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  018a4	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  018a9	75 16		 jne	 SHORT $LN24@inflateBac@3
  018ab	48 c7 44 24 50
	00 00 00 00	 mov	 QWORD PTR next$[rsp], 0
  018b4	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  018bc	e9 cb 02 00 00	 jmp	 $inf_leave$78193
$LN24@inflateBac@3:
$LN25@inflateBac@3:
  018c1	33 c0		 xor	 eax, eax
  018c3	85 c0		 test	 eax, eax
  018c5	75 be		 jne	 SHORT $LN28@inflateBac@3
  018c7	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  018cb	83 e8 01	 sub	 eax, 1
  018ce	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  018d2	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  018d7	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  018da	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  018de	0f b6 c8	 movzx	 ecx, al
  018e1	8b c2		 mov	 eax, edx
  018e3	d3 e0		 shl	 eax, cl
  018e5	8b c8		 mov	 ecx, eax
  018e7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  018eb	03 c1		 add	 eax, ecx
  018ed	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  018f1	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  018f6	48 83 c0 01	 add	 rax, 1
  018fa	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  018ff	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  01903	83 c0 08	 add	 eax, 8
  01906	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  0190a	33 c0		 xor	 eax, eax
  0190c	85 c0		 test	 eax, eax
  0190e	0f 85 71 ff ff
	ff		 jne	 $LN31@inflateBac@3
  01914	e9 5a ff ff ff	 jmp	 $LN33@inflateBac@3
$LN32@inflateBac@3:
  01919	33 c0		 xor	 eax, eax
  0191b	85 c0		 test	 eax, eax
  0191d	0f 85 50 ff ff
	ff		 jne	 $LN36@inflateBac@3

; 557  :                 state->offset += BITS(state->extra);

  01923	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01928	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0192b	b8 01 00 00 00	 mov	 eax, 1
  01930	d3 e0		 shl	 eax, cl
  01932	83 e8 01	 sub	 eax, 1
  01935	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01939	23 c8		 and	 ecx, eax
  0193b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01940	03 48 4c	 add	 ecx, DWORD PTR [rax+76]
  01943	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01948	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN23@inflateBac@3:

; 558  :                 DROPBITS(state->extra);

  0194b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01950	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  01953	0f b6 c8	 movzx	 ecx, al
  01956	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0195a	d3 e8		 shr	 eax, cl
  0195c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01960	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01965	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  01968	8b 44 24 44	 mov	 eax, DWORD PTR bits$[rsp]
  0196c	2b c1		 sub	 eax, ecx
  0196e	89 44 24 44	 mov	 DWORD PTR bits$[rsp], eax
  01972	33 c0		 xor	 eax, eax
  01974	85 c0		 test	 eax, eax
  01976	75 d3		 jne	 SHORT $LN23@inflateBac@3
$LN37@inflateBac@3:

; 559  :             }
; 560  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 561  :                                                 left : 0)) {

  01978	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  0197d	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01982	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01985	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  01988	73 0d		 jae	 SHORT $LN351@inflateBac@3
  0198a	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  0198e	89 84 24 84 00
	00 00		 mov	 DWORD PTR tv791[rsp], eax
  01995	eb 0b		 jmp	 SHORT $LN352@inflateBac@3
$LN351@inflateBac@3:
  01997	c7 84 24 84 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv791[rsp], 0
$LN352@inflateBac@3:
  019a2	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  019a7	8b 84 24 84 00
	00 00		 mov	 eax, DWORD PTR tv791[rsp]
  019ae	8b 49 2c	 mov	 ecx, DWORD PTR [rcx+44]
  019b1	2b c8		 sub	 ecx, eax
  019b3	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019b8	39 48 4c	 cmp	 DWORD PTR [rax+76], ecx
  019bb	76 23		 jbe	 SHORT $LN20@inflateBac@3

; 562  :                 strm->msg = (char *)"invalid distance too far back";

  019bd	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  019c5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  019cc	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 563  :                 state->mode = BAD;

  019d0	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019d5	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 564  :                 break;

  019db	e9 a7 01 00 00	 jmp	 $LN341@inflateBac@3
$LN20@inflateBac@3:
$LN19@inflateBac@3:
$LN16@inflateBac@3:

; 565  :             }
; 566  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 567  : 
; 568  :             /* copy match from window to output */
; 569  :             do {
; 570  :                 ROOM();

  019e0	83 7c 24 48 00	 cmp	 DWORD PTR left$[rsp], 0
  019e5	75 50		 jne	 SHORT $LN13@inflateBac@3
  019e7	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019ec	48 8b 40 38	 mov	 rax, QWORD PTR [rax+56]
  019f0	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  019f5	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  019fa	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  019fd	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax
  01a01	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01a06	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01a0a	89 41 30	 mov	 DWORD PTR [rcx+48], eax
  01a0d	44 8b 44 24 48	 mov	 r8d, DWORD PTR left$[rsp]
  01a12	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  01a17	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01a1f	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01a26	85 c0		 test	 eax, eax
  01a28	74 0d		 je	 SHORT $LN12@inflateBac@3
  01a2a	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
  01a32	e9 55 01 00 00	 jmp	 $inf_leave$78193
$LN12@inflateBac@3:
$LN13@inflateBac@3:
  01a37	33 c0		 xor	 eax, eax
  01a39	85 c0		 test	 eax, eax
  01a3b	75 a3		 jne	 SHORT $LN16@inflateBac@3

; 571  :                 copy = state->wsize - state->offset;

  01a3d	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  01a42	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a47	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  01a4a	8b 42 2c	 mov	 eax, DWORD PTR [rdx+44]
  01a4d	2b c1		 sub	 eax, ecx
  01a4f	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax

; 572  :                 if (copy < left) {

  01a53	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01a57	39 44 24 64	 cmp	 DWORD PTR copy$[rsp], eax
  01a5b	73 21		 jae	 SHORT $LN11@inflateBac@3

; 573  :                     from = put + copy;

  01a5d	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  01a61	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01a66	48 03 c1	 add	 rax, rcx
  01a69	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 574  :                     copy = left - copy;

  01a6e	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  01a72	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01a76	2b c1		 sub	 eax, ecx
  01a78	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax

; 575  :                 }
; 576  :                 else {

  01a7c	eb 1d		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 577  :                     from = put - state->offset;

  01a7e	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01a83	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  01a86	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01a8b	48 2b c1	 sub	 rax, rcx
  01a8e	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 578  :                     copy = left;

  01a93	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01a97	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN10@inflateBac@3:

; 579  :                 }
; 580  :                 if (copy > state->length) copy = state->length;

  01a9b	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01aa0	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01aa3	39 44 24 64	 cmp	 DWORD PTR copy$[rsp], eax
  01aa7	76 0c		 jbe	 SHORT $LN9@inflateBac@3
  01aa9	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01aae	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01ab1	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
$LN9@inflateBac@3:

; 581  :                 state->length -= copy;

  01ab5	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01aba	8b 44 24 64	 mov	 eax, DWORD PTR copy$[rsp]
  01abe	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01ac1	2b c8		 sub	 ecx, eax
  01ac3	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01ac8	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 582  :                 left -= copy;

  01acb	8b 4c 24 64	 mov	 ecx, DWORD PTR copy$[rsp]
  01acf	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01ad3	2b c1		 sub	 eax, ecx
  01ad5	89 44 24 48	 mov	 DWORD PTR left$[rsp], eax
$LN8@inflateBac@3:

; 583  :                 do {
; 584  :                     *put++ = *from++;

  01ad9	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  01ade	48 8b 44 24 68	 mov	 rax, QWORD PTR from$[rsp]
  01ae3	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  01ae6	88 01		 mov	 BYTE PTR [rcx], al
  01ae8	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01aed	48 83 c0 01	 add	 rax, 1
  01af1	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01af6	48 8b 44 24 68	 mov	 rax, QWORD PTR from$[rsp]
  01afb	48 83 c0 01	 add	 rax, 1
  01aff	48 89 44 24 68	 mov	 QWORD PTR from$[rsp], rax

; 585  :                 } while (--copy);

  01b04	8b 44 24 64	 mov	 eax, DWORD PTR copy$[rsp]
  01b08	83 e8 01	 sub	 eax, 1
  01b0b	89 44 24 64	 mov	 DWORD PTR copy$[rsp], eax
  01b0f	83 7c 24 64 00	 cmp	 DWORD PTR copy$[rsp], 0
  01b14	75 c3		 jne	 SHORT $LN8@inflateBac@3

; 586  :             } while (state->length != 0);

  01b16	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b1b	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  01b1f	0f 85 bb fe ff
	ff		 jne	 $LN19@inflateBac@3

; 587  :             break;

  01b25	eb 60		 jmp	 SHORT $LN341@inflateBac@3
$LN5@inflateBac@3:

; 588  : 
; 589  :         case DONE:
; 590  :             /* inflate stream terminated properly -- write leftover output */
; 591  :             ret = Z_STREAM_END;

  01b27	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR ret$[rsp], 1

; 592  :             if (left < state->wsize) {

  01b2f	48 8b 44 24 70	 mov	 rax, QWORD PTR state$[rsp]
  01b34	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  01b37	39 44 24 48	 cmp	 DWORD PTR left$[rsp], eax
  01b3b	73 34		 jae	 SHORT $LN4@inflateBac@3

; 593  :                 if (out(out_desc, state->window, state->wsize - left))

  01b3d	48 8b 4c 24 70	 mov	 rcx, QWORD PTR state$[rsp]
  01b42	8b 44 24 48	 mov	 eax, DWORD PTR left$[rsp]
  01b46	44 8b 41 2c	 mov	 r8d, DWORD PTR [rcx+44]
  01b4a	44 2b c0	 sub	 r8d, eax
  01b4d	48 8b 54 24 70	 mov	 rdx, QWORD PTR state$[rsp]
  01b52	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  01b56	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR out_desc$[rsp]
  01b5e	ff 94 24 b8 00
	00 00		 call	 QWORD PTR out$[rsp]
  01b65	85 c0		 test	 eax, eax
  01b67	74 08		 je	 SHORT $LN3@inflateBac@3

; 594  :                     ret = Z_BUF_ERROR;

  01b69	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
$LN3@inflateBac@3:
$LN4@inflateBac@3:

; 595  :             }
; 596  :             goto inf_leave;

  01b71	eb 19		 jmp	 SHORT $inf_leave$78193
$LN2@inflateBac@3:

; 597  : 
; 598  :         case BAD:
; 599  :             ret = Z_DATA_ERROR;

  01b73	c7 44 24 58 fd
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -3

; 600  :             goto inf_leave;

  01b7b	eb 0f		 jmp	 SHORT $inf_leave$78193
$LN1@inflateBac@3:

; 601  : 
; 602  :         default:                /* can't happen, but makes compilers happy */
; 603  :             ret = Z_STREAM_ERROR;

  01b7d	c7 44 24 58 fe
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -2
  01b85	eb 05		 jmp	 SHORT $inf_leave$78193
$LN341@inflateBac@3:

; 604  :             goto inf_leave;
; 605  :         }

  01b87	e9 5a e5 ff ff	 jmp	 $LN344@inflateBac@3
$inf_leave$78193:

; 606  : 
; 607  :     /* Return unused input */
; 608  :   inf_leave:
; 609  :     strm->next_in = next;

  01b8c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01b94	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01b99	48 89 01	 mov	 QWORD PTR [rcx], rax

; 610  :     strm->avail_in = have;

  01b9c	48 8b 8c 24 a0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01ba4	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01ba8	89 41 08	 mov	 DWORD PTR [rcx+8], eax

; 611  :     return ret;

  01bab	8b 44 24 58	 mov	 eax, DWORD PTR ret$[rsp]
$LN347@inflateBac@3:

; 612  : }

  01baf	48 81 c4 98 00
	00 00		 add	 rsp, 152		; 00000098H
  01bb6	c3		 ret	 0
  01bb7	90		 npad	 1
$LN353@inflateBac@3:
  01bb8	00 00 00 00	 DD	 $LN340@inflateBac@3
  01bbc	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bc0	00 00 00 00	 DD	 $LN310@inflateBac@3
  01bc4	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bc8	00 00 00 00	 DD	 $LN275@inflateBac@3
  01bcc	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bd0	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bd4	00 00 00 00	 DD	 $LN130@inflateBac@3
  01bd8	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bdc	00 00 00 00	 DD	 $LN1@inflateBac@3
  01be0	00 00 00 00	 DD	 $LN1@inflateBac@3
  01be4	00 00 00 00	 DD	 $LN1@inflateBac@3
  01be8	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bec	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bf0	00 00 00 00	 DD	 $LN1@inflateBac@3
  01bf4	00 00 00 00	 DD	 $LN5@inflateBac@3
  01bf8	00 00 00 00	 DD	 $LN2@inflateBac@3
inflateBack ENDP
END
