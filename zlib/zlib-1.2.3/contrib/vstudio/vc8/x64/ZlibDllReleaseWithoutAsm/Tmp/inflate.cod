; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

include listing.inc

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
PUBLIC	inflateCopy
;	COMDAT pdata
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\inflate.c
pdata	SEGMENT
$pdata$inflateCopy DD imagerel $LN10
	DD	imagerel $LN10+575
	DD	imagerel $unwind$inflateCopy
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateCopy DD 010e01H
	DD	0820eH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateCopy
_TEXT	SEGMENT
window$ = 32
wsize$ = 40
copy$ = 48
state$ = 56
dest$ = 80
source$ = 88
inflateCopy PROC					; COMDAT

; 1326 : {

$LN10:
  00000	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  00005	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000a	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1327 :     struct inflate_state FAR *state;
; 1328 :     struct inflate_state FAR *copy;
; 1329 :     unsigned char FAR *window;
; 1330 :     unsigned wsize;
; 1331 : 
; 1332 :     /* check input */
; 1333 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1334 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  0000e	48 83 7c 24 50
	00		 cmp	 QWORD PTR dest$[rsp], 0
  00014	74 2c		 je	 SHORT $LN6@inflateCop
  00016	48 83 7c 24 58
	00		 cmp	 QWORD PTR source$[rsp], 0
  0001c	74 24		 je	 SHORT $LN6@inflateCop
  0001e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 18		 je	 SHORT $LN6@inflateCop
  0002a	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  0002f	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00034	74 0c		 je	 SHORT $LN6@inflateCop
  00036	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  0003b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00040	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1335 :         return Z_STREAM_ERROR;

  00042	b8 fe ff ff ff	 mov	 eax, -2
  00047	e9 ee 01 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1336 :     state = (struct inflate_state FAR *)source->state;

  0004c	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00051	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00055	48 89 44 24 38	 mov	 QWORD PTR state$[rsp], rax

; 1337 : 
; 1338 :     /* allocate space */
; 1339 :     copy = (struct inflate_state FAR *)
; 1340 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  0005a	41 b8 48 25 00
	00		 mov	 r8d, 9544		; 00002548H
  00060	ba 01 00 00 00	 mov	 edx, 1
  00065	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  0006a	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0006e	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  00073	ff 50 30	 call	 QWORD PTR [rax+48]
  00076	48 89 44 24 30	 mov	 QWORD PTR copy$[rsp], rax

; 1341 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0007b	48 83 7c 24 30
	00		 cmp	 QWORD PTR copy$[rsp], 0
  00081	75 0a		 jne	 SHORT $LN5@inflateCop
  00083	b8 fc ff ff ff	 mov	 eax, -4
  00088	e9 ad 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1342 :     window = Z_NULL;

  0008d	48 c7 44 24 20
	00 00 00 00	 mov	 QWORD PTR window$[rsp], 0

; 1343 :     if (state->window != Z_NULL) {

  00096	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0009b	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  000a0	74 56		 je	 SHORT $LN4@inflateCop

; 1344 :         window = (unsigned char FAR *)
; 1345 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  000a2	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  000a7	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  000aa	ba 01 00 00 00	 mov	 edx, 1
  000af	0f b6 c8	 movzx	 ecx, al
  000b2	d3 e2		 shl	 edx, cl
  000b4	41 b8 01 00 00
	00		 mov	 r8d, 1
  000ba	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  000bf	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000c3	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  000c8	ff 50 30	 call	 QWORD PTR [rax+48]
  000cb	48 89 44 24 20	 mov	 QWORD PTR window$[rsp], rax

; 1346 :         if (window == Z_NULL) {

  000d0	48 83 7c 24 20
	00		 cmp	 QWORD PTR window$[rsp], 0
  000d6	75 20		 jne	 SHORT $LN3@inflateCop

; 1347 :             ZFREE(source, copy);

  000d8	48 8b 54 24 30	 mov	 rdx, QWORD PTR copy$[rsp]
  000dd	48 8b 4c 24 58	 mov	 rcx, QWORD PTR source$[rsp]
  000e2	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000e6	48 8b 44 24 58	 mov	 rax, QWORD PTR source$[rsp]
  000eb	ff 50 38	 call	 QWORD PTR [rax+56]

; 1348 :             return Z_MEM_ERROR;

  000ee	b8 fc ff ff ff	 mov	 eax, -4
  000f3	e9 42 01 00 00	 jmp	 $LN8@inflateCop
$LN3@inflateCop:
$LN4@inflateCop:

; 1349 :         }
; 1350 :     }
; 1351 : 
; 1352 :     /* copy state */
; 1353 :     zmemcpy(dest, source, sizeof(z_stream));

  000f8	41 b8 58 00 00
	00		 mov	 r8d, 88			; 00000058H
  000fe	48 8b 54 24 58	 mov	 rdx, QWORD PTR source$[rsp]
  00103	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  00108	e8 00 00 00 00	 call	 memcpy

; 1354 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  0010d	41 b8 48 25 00
	00		 mov	 r8d, 9544		; 00002548H
  00113	48 8b 54 24 38	 mov	 rdx, QWORD PTR state$[rsp]
  00118	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  0011d	e8 00 00 00 00	 call	 memcpy

; 1355 :     if (state->lencode >= state->codes &&
; 1356 :         state->lencode <= state->codes + ENOUGH - 1) {

  00122	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00127	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  0012e	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00133	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  00137	72 79		 jb	 SHORT $LN2@inflateCop
  00139	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  0013e	48 81 c1 44 25
	00 00		 add	 rcx, 9540		; 00002544H
  00145	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  0014a	48 39 48 58	 cmp	 QWORD PTR [rax+88], rcx
  0014e	77 62		 ja	 SHORT $LN2@inflateCop

; 1357 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  00150	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00155	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  0015b	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00160	48 8b 49 58	 mov	 rcx, QWORD PTR [rcx+88]
  00164	48 2b c8	 sub	 rcx, rax
  00167	48 c1 f9 02	 sar	 rcx, 2
  0016b	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  00170	48 8d 8c 88 48
	05 00 00	 lea	 rcx, QWORD PTR [rax+rcx*4+1352]
  00178	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  0017d	48 89 48 58	 mov	 QWORD PTR [rax+88], rcx

; 1358 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00181	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  00186	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  0018c	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  00191	48 8b 49 60	 mov	 rcx, QWORD PTR [rcx+96]
  00195	48 2b c8	 sub	 rcx, rax
  00198	48 c1 f9 02	 sar	 rcx, 2
  0019c	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001a1	48 8d 8c 88 48
	05 00 00	 lea	 rcx, QWORD PTR [rax+rcx*4+1352]
  001a9	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001ae	48 89 48 60	 mov	 QWORD PTR [rax+96], rcx
$LN2@inflateCop:

; 1359 :     }
; 1360 :     copy->next = copy->codes + (state->next - state->codes);

  001b2	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001b7	48 05 48 05 00
	00		 add	 rax, 1352		; 00000548H
  001bd	48 8b 4c 24 38	 mov	 rcx, QWORD PTR state$[rsp]
  001c2	48 8b 89 80 00
	00 00		 mov	 rcx, QWORD PTR [rcx+128]
  001c9	48 2b c8	 sub	 rcx, rax
  001cc	48 c1 f9 02	 sar	 rcx, 2
  001d0	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001d5	48 8d 8c 88 48
	05 00 00	 lea	 rcx, QWORD PTR [rax+rcx*4+1352]
  001dd	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  001e2	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 1361 :     if (window != Z_NULL) {

  001e9	48 83 7c 24 20
	00		 cmp	 QWORD PTR window$[rsp], 0
  001ef	74 2b		 je	 SHORT $LN1@inflateCop

; 1362 :         wsize = 1U << state->wbits;

  001f1	48 8b 44 24 38	 mov	 rax, QWORD PTR state$[rsp]
  001f6	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  001f9	b8 01 00 00 00	 mov	 eax, 1
  001fe	d3 e0		 shl	 eax, cl
  00200	89 44 24 28	 mov	 DWORD PTR wsize$[rsp], eax

; 1363 :         zmemcpy(window, state->window, wsize);

  00204	44 8b 44 24 28	 mov	 r8d, DWORD PTR wsize$[rsp]
  00209	48 8b 54 24 38	 mov	 rdx, QWORD PTR state$[rsp]
  0020e	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00212	48 8b 4c 24 20	 mov	 rcx, QWORD PTR window$[rsp]
  00217	e8 00 00 00 00	 call	 memcpy
$LN1@inflateCop:

; 1364 :     }
; 1365 :     copy->window = window;

  0021c	48 8b 4c 24 30	 mov	 rcx, QWORD PTR copy$[rsp]
  00221	48 8b 44 24 20	 mov	 rax, QWORD PTR window$[rsp]
  00226	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax

; 1366 :     dest->state = (struct internal_state FAR *)copy;

  0022a	48 8b 4c 24 50	 mov	 rcx, QWORD PTR dest$[rsp]
  0022f	48 8b 44 24 30	 mov	 rax, QWORD PTR copy$[rsp]
  00234	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 1367 :     return Z_OK;

  00238	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1368 : }

  0023a	48 83 c4 48	 add	 rsp, 72			; 00000048H
  0023e	c3		 ret	 0
inflateCopy ENDP
_TEXT	ENDS
PUBLIC	inflateSyncPoint
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSyncPoint DD imagerel $LN7
	DD	imagerel $LN7+95
	DD	imagerel $unwind$inflateSyncPoint
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSyncPoint DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSyncPoint
_TEXT	SEGMENT
state$ = 0
tv71 = 8
strm$ = 32
inflateSyncPoint PROC					; COMDAT

; 1315 : {

$LN7:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 1316 :     struct inflate_state FAR *state;
; 1317 : 
; 1318 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateSyn
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 07		 jne	 SHORT $LN2@inflateSyn
$LN1@inflateSyn:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	eb 36		 jmp	 SHORT $LN3@inflateSyn
$LN2@inflateSyn:

; 1319 :     state = (struct inflate_state FAR *)strm->state;

  00024	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00029	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0002d	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 1320 :     return state->mode == STORED && state->bits == 0;

  00031	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00035	83 38 0d	 cmp	 DWORD PTR [rax], 13
  00038	75 14		 jne	 SHORT $LN5@inflateSyn
  0003a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0003e	83 78 44 00	 cmp	 DWORD PTR [rax+68], 0
  00042	75 0a		 jne	 SHORT $LN5@inflateSyn
  00044	c7 44 24 08 01
	00 00 00	 mov	 DWORD PTR tv71[rsp], 1
  0004c	eb 08		 jmp	 SHORT $LN6@inflateSyn
$LN5@inflateSyn:
  0004e	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv71[rsp], 0
$LN6@inflateSyn:
  00056	8b 44 24 08	 mov	 eax, DWORD PTR tv71[rsp]
$LN3@inflateSyn:

; 1321 : }

  0005a	48 83 c4 18	 add	 rsp, 24
  0005e	c3		 ret	 0
inflateSyncPoint ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$syncsearch DD imagerel syncsearch
	DD	imagerel syncsearch+178
	DD	imagerel $unwind$syncsearch
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$syncsearch DD 011301H
	DD	02213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT syncsearch
_TEXT	SEGMENT
next$ = 0
got$ = 4
tv70 = 8
have$ = 32
buf$ = 40
len$ = 48
syncsearch PROC						; COMDAT

; 1243 : {

  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 18	 sub	 rsp, 24

; 1244 :     unsigned got;
; 1245 :     unsigned next;
; 1246 : 
; 1247 :     got = *have;

  00013	48 8b 44 24 20	 mov	 rax, QWORD PTR have$[rsp]
  00018	8b 00		 mov	 eax, DWORD PTR [rax]
  0001a	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax

; 1248 :     next = 0;

  0001e	c7 04 24 00 00
	00 00		 mov	 DWORD PTR next$[rsp], 0
$LN6@syncsearch:

; 1249 :     while (next < len && got < 4) {

  00025	8b 44 24 30	 mov	 eax, DWORD PTR len$[rsp]
  00029	39 04 24	 cmp	 DWORD PTR next$[rsp], eax
  0002c	73 71		 jae	 SHORT $LN5@syncsearch
  0002e	83 7c 24 04 04	 cmp	 DWORD PTR got$[rsp], 4
  00033	73 6a		 jae	 SHORT $LN5@syncsearch

; 1250 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00035	83 7c 24 04 02	 cmp	 DWORD PTR got$[rsp], 2
  0003a	73 0a		 jae	 SHORT $LN9@syncsearch
  0003c	c7 44 24 08 00
	00 00 00	 mov	 DWORD PTR tv70[rsp], 0
  00044	eb 08		 jmp	 SHORT $LN10@syncsearch
$LN9@syncsearch:
  00046	c7 44 24 08 ff
	00 00 00	 mov	 DWORD PTR tv70[rsp], 255 ; 000000ffH
$LN10@syncsearch:
  0004e	8b 0c 24	 mov	 ecx, DWORD PTR next$[rsp]
  00051	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00056	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  0005a	3b 44 24 08	 cmp	 eax, DWORD PTR tv70[rsp]
  0005e	75 0d		 jne	 SHORT $LN4@syncsearch

; 1251 :             got++;

  00060	8b 44 24 04	 mov	 eax, DWORD PTR got$[rsp]
  00064	83 c0 01	 add	 eax, 1
  00067	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax
  0006b	eb 27		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1252 :         else if (buf[next])

  0006d	8b 0c 24	 mov	 ecx, DWORD PTR next$[rsp]
  00070	48 8b 44 24 28	 mov	 rax, QWORD PTR buf$[rsp]
  00075	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00079	85 c0		 test	 eax, eax
  0007b	74 0a		 je	 SHORT $LN2@syncsearch

; 1253 :             got = 0;

  0007d	c7 44 24 04 00
	00 00 00	 mov	 DWORD PTR got$[rsp], 0

; 1254 :         else

  00085	eb 0d		 jmp	 SHORT $LN1@syncsearch
$LN2@syncsearch:

; 1255 :             got = 4 - got;

  00087	b8 04 00 00 00	 mov	 eax, 4
  0008c	2b 44 24 04	 sub	 eax, DWORD PTR got$[rsp]
  00090	89 44 24 04	 mov	 DWORD PTR got$[rsp], eax
$LN1@syncsearch:
$LN3@syncsearch:

; 1256 :         next++;

  00094	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]
  00097	83 c0 01	 add	 eax, 1
  0009a	89 04 24	 mov	 DWORD PTR next$[rsp], eax

; 1257 :     }

  0009d	eb 86		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1258 :     *have = got;

  0009f	48 8b 4c 24 20	 mov	 rcx, QWORD PTR have$[rsp]
  000a4	8b 44 24 04	 mov	 eax, DWORD PTR got$[rsp]
  000a8	89 01		 mov	 DWORD PTR [rcx], eax

; 1259 :     return next;

  000aa	8b 04 24	 mov	 eax, DWORD PTR next$[rsp]

; 1260 : }

  000ad	48 83 c4 18	 add	 rsp, 24
  000b1	c3		 ret	 0
syncsearch ENDP
_TEXT	ENDS
PUBLIC	inflateEnd
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateEnd DD imagerel $LN6
	DD	imagerel $LN6+146
	DD	imagerel $unwind$inflateEnd
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateEnd DD 010901H
	DD	06209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateEnd
_TEXT	SEGMENT
state$ = 32
strm$ = 64
inflateEnd PROC						; COMDAT

; 1157 : {

$LN6:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1158 :     struct inflate_state FAR *state;
; 1159 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00009	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 18		 je	 SHORT $LN2@inflateEnd
  00011	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	74 0c		 je	 SHORT $LN2@inflateEnd
  0001d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00022	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00027	75 07		 jne	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1160 :         return Z_STREAM_ERROR;

  00029	b8 fe ff ff ff	 mov	 eax, -2
  0002e	eb 5d		 jmp	 SHORT $LN4@inflateEnd
$LN3@inflateEnd:

; 1161 :     state = (struct inflate_state FAR *)strm->state;

  00030	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00035	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00039	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 1162 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0003e	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00043	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00048	74 1a		 je	 SHORT $LN1@inflateEnd
  0004a	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  0004f	48 8b 52 38	 mov	 rdx, QWORD PTR [rdx+56]
  00053	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00058	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  0005c	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00061	ff 50 38	 call	 QWORD PTR [rax+56]
$LN1@inflateEnd:

; 1163 :     ZFREE(strm, strm->state);

  00064	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00069	48 8b 52 28	 mov	 rdx, QWORD PTR [rdx+40]
  0006d	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00072	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00076	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0007b	ff 50 38	 call	 QWORD PTR [rax+56]

; 1164 :     strm->state = Z_NULL;

  0007e	4c 8b 5c 24 40	 mov	 r11, QWORD PTR strm$[rsp]
  00083	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 1165 :     Tracev((stderr, "inflate: end\n"));
; 1166 :     return Z_OK;

  0008b	33 c0		 xor	 eax, eax
$LN4@inflateEnd:

; 1167 : }

  0008d	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00091	c3		 ret	 0
inflateEnd ENDP
_TEXT	ENDS
;	COMDAT pdata
pdata	SEGMENT
$pdata$updatewindow DD imagerel updatewindow
	DD	imagerel updatewindow+550
	DD	imagerel $unwind$updatewindow
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$updatewindow DD 010d01H
	DD	0620dH
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT updatewindow
_TEXT	SEGMENT
dist$ = 32
copy$ = 36
state$ = 40
strm$ = 64
out$ = 72
updatewindow PROC					; COMDAT

; 326  : {

  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 327  :     struct inflate_state FAR *state;
; 328  :     unsigned copy, dist;
; 329  : 
; 330  :     state = (struct inflate_state FAR *)strm->state;

  0000d	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00012	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00016	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 331  : 
; 332  :     /* if it hasn't been done already, allocate space for the window */
; 333  :     if (state->window == Z_NULL) {

  0001b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00020	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00025	75 4b		 jne	 SHORT $LN10@updatewind

; 334  :         state->window = (unsigned char FAR *)
; 335  :                         ZALLOC(strm, 1U << state->wbits,
; 336  :                                sizeof(unsigned char));

  00027	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0002c	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  0002f	ba 01 00 00 00	 mov	 edx, 1
  00034	0f b6 c8	 movzx	 ecx, al
  00037	d3 e2		 shl	 edx, cl
  00039	41 b8 01 00 00
	00		 mov	 r8d, 1
  0003f	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00044	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00048	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0004d	ff 50 30	 call	 QWORD PTR [rax+48]
  00050	4c 8b d8	 mov	 r11, rax
  00053	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00058	4c 89 58 38	 mov	 QWORD PTR [rax+56], r11

; 337  :         if (state->window == Z_NULL) return 1;

  0005c	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00061	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00066	75 0a		 jne	 SHORT $LN9@updatewind
  00068	b8 01 00 00 00	 mov	 eax, 1
  0006d	e9 af 01 00 00	 jmp	 $LN11@updatewind
$LN9@updatewind:
$LN10@updatewind:

; 338  :     }
; 339  : 
; 340  :     /* if window not in use yet, initialize */
; 341  :     if (state->wsize == 0) {

  00072	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00077	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  0007b	75 31		 jne	 SHORT $LN8@updatewind

; 342  :         state->wsize = 1U << state->wbits;

  0007d	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00082	8b 48 28	 mov	 ecx, DWORD PTR [rax+40]
  00085	b8 01 00 00 00	 mov	 eax, 1
  0008a	d3 e0		 shl	 eax, cl
  0008c	8b c8		 mov	 ecx, eax
  0008e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00093	89 48 2c	 mov	 DWORD PTR [rax+44], ecx

; 343  :         state->write = 0;

  00096	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0009b	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 344  :         state->whave = 0;

  000a2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000a7	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0
$LN8@updatewind:

; 345  :     }
; 346  : 
; 347  :     /* copy state->wsize or less output bytes into the circular window */
; 348  :     copy = out - strm->avail_out;

  000ae	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000b3	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  000b6	8b 44 24 48	 mov	 eax, DWORD PTR out$[rsp]
  000ba	2b c1		 sub	 eax, ecx
  000bc	89 44 24 24	 mov	 DWORD PTR copy$[rsp], eax

; 349  :     if (copy >= state->wsize) {

  000c0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000c8	39 44 24 24	 cmp	 DWORD PTR copy$[rsp], eax
  000cc	72 4d		 jb	 SHORT $LN7@updatewind

; 350  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  000ce	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d3	44 8b 40 2c	 mov	 r8d, DWORD PTR [rax+44]
  000d7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000dc	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000df	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  000e4	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  000e8	48 2b d0	 sub	 rdx, rax
  000eb	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  000f0	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  000f4	e8 00 00 00 00	 call	 memcpy

; 351  :         state->write = 0;

  000f9	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  000fe	41 c7 43 34 00
	00 00 00	 mov	 DWORD PTR [r11+52], 0

; 352  :         state->whave = state->wsize;

  00106	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0010b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00110	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00113	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 353  :     }
; 354  :     else {

  00116	e9 04 01 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 355  :         dist = state->wsize - state->write;

  0011b	48 8b 54 24 28	 mov	 rdx, QWORD PTR state$[rsp]
  00120	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00125	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00128	8b 42 2c	 mov	 eax, DWORD PTR [rdx+44]
  0012b	2b c1		 sub	 eax, ecx
  0012d	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax

; 356  :         if (dist > copy) dist = copy;

  00131	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  00135	39 44 24 20	 cmp	 DWORD PTR dist$[rsp], eax
  00139	76 08		 jbe	 SHORT $LN5@updatewind
  0013b	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0013f	89 44 24 20	 mov	 DWORD PTR dist$[rsp], eax
$LN5@updatewind:

; 357  :         zmemcpy(state->window + state->write, strm->next_out - copy, dist);

  00143	44 8b 44 24 20	 mov	 r8d, DWORD PTR dist$[rsp]
  00148	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0014c	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00151	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00155	48 2b d0	 sub	 rdx, rax
  00158	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0015d	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  00160	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00165	48 03 48 38	 add	 rcx, QWORD PTR [rax+56]
  00169	e8 00 00 00 00	 call	 memcpy

; 358  :         copy -= dist;

  0016e	44 8b 5c 24 20	 mov	 r11d, DWORD PTR dist$[rsp]
  00173	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  00177	41 2b c3	 sub	 eax, r11d
  0017a	89 44 24 24	 mov	 DWORD PTR copy$[rsp], eax

; 359  :         if (copy) {

  0017e	83 7c 24 24 00	 cmp	 DWORD PTR copy$[rsp], 0
  00183	74 42		 je	 SHORT $LN4@updatewind

; 360  :             zmemcpy(state->window, strm->next_out - copy, copy);

  00185	44 8b 44 24 24	 mov	 r8d, DWORD PTR copy$[rsp]
  0018a	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  0018e	48 8b 54 24 40	 mov	 rdx, QWORD PTR strm$[rsp]
  00193	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  00197	48 2b d0	 sub	 rdx, rax
  0019a	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  0019f	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  001a3	e8 00 00 00 00	 call	 memcpy

; 361  :             state->write = copy;

  001a8	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  001ad	8b 44 24 24	 mov	 eax, DWORD PTR copy$[rsp]
  001b1	41 89 43 34	 mov	 DWORD PTR [r11+52], eax

; 362  :             state->whave = state->wsize;

  001b5	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001ba	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001bf	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  001c2	89 41 30	 mov	 DWORD PTR [rcx+48], eax

; 363  :         }
; 364  :         else {

  001c5	eb 58		 jmp	 SHORT $LN3@updatewind
$LN4@updatewind:

; 365  :             state->write += dist;

  001c7	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001cc	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  001cf	03 4c 24 20	 add	 ecx, DWORD PTR dist$[rsp]
  001d3	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001d8	89 48 34	 mov	 DWORD PTR [rax+52], ecx

; 366  :             if (state->write == state->wsize) state->write = 0;

  001db	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001e5	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  001e8	39 41 34	 cmp	 DWORD PTR [rcx+52], eax
  001eb	75 0c		 jne	 SHORT $LN2@updatewind
  001ed	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  001f2	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0
$LN2@updatewind:

; 367  :             if (state->whave < state->wsize) state->whave += dist;

  001f9	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  001fe	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00203	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  00206	39 41 30	 cmp	 DWORD PTR [rcx+48], eax
  00209	73 14		 jae	 SHORT $LN1@updatewind
  0020b	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00210	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  00213	03 4c 24 20	 add	 ecx, DWORD PTR dist$[rsp]
  00217	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0021c	89 48 30	 mov	 DWORD PTR [rax+48], ecx
$LN1@updatewind:
$LN3@updatewind:
$LN6@updatewind:

; 368  :         }
; 369  :     }
; 370  :     return 0;

  0021f	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 371  : }

  00221	48 83 c4 38	 add	 rsp, 56			; 00000038H
  00225	c3		 ret	 0
updatewindow ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT fixedtables
_TEXT	SEGMENT
state$ = 8
fixedtables PROC					; COMDAT

; 207  : {

  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx

; 208  : #ifdef BUILDFIXED
; 209  :     static int virgin = 1;
; 210  :     static code *lenfix, *distfix;
; 211  :     static code fixed[544];
; 212  : 
; 213  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 214  :     if (virgin) {
; 215  :         unsigned sym, bits;
; 216  :         static code *next;
; 217  : 
; 218  :         /* literal/length table */
; 219  :         sym = 0;
; 220  :         while (sym < 144) state->lens[sym++] = 8;
; 221  :         while (sym < 256) state->lens[sym++] = 9;
; 222  :         while (sym < 280) state->lens[sym++] = 7;
; 223  :         while (sym < 288) state->lens[sym++] = 8;
; 224  :         next = fixed;
; 225  :         lenfix = next;
; 226  :         bits = 9;
; 227  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 228  : 
; 229  :         /* distance table */
; 230  :         sym = 0;
; 231  :         while (sym < 32) state->lens[sym++] = 5;
; 232  :         distfix = next;
; 233  :         bits = 5;
; 234  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 235  : 
; 236  :         /* do this just once */
; 237  :         virgin = 0;
; 238  :     }
; 239  : #else /* !BUILDFIXED */
; 240  : #   include "inffixed.h"
; 241  : #endif /* BUILDFIXED */
; 242  :     state->lencode = lenfix;

  00005	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  0000a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?lenfix@?1??fixedtables@@9@9
  00011	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 243  :     state->lenbits = 9;

  00015	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  0001a	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 244  :     state->distcode = distfix;

  00021	48 8b 4c 24 08	 mov	 rcx, QWORD PTR state$[rsp]
  00026	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?distfix@?1??fixedtables@@9@9
  0002d	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 245  :     state->distbits = 5;

  00031	48 8b 44 24 08	 mov	 rax, QWORD PTR state$[rsp]
  00036	c7 40 6c 05 00
	00 00		 mov	 DWORD PTR [rax+108], 5

; 246  : }

  0003d	c3		 ret	 0
fixedtables ENDP
_TEXT	ENDS
PUBLIC	inflateReset
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateReset DD imagerel $LN5
	DD	imagerel $LN5+286
	DD	imagerel $unwind$inflateReset
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateReset DD 010901H
	DD	02209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateReset
_TEXT	SEGMENT
state$ = 0
strm$ = 32
inflateReset PROC					; COMDAT

; 105  : {

$LN5:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 18	 sub	 rsp, 24

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 20
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN1@inflateRes
  00011	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN2@inflateRes
$LN1@inflateRes:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 f2 00 00 00	 jmp	 $LN3@inflateRes
$LN2@inflateRes:

; 109  :     state = (struct inflate_state FAR *)strm->state;

  00027	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	48 89 04 24	 mov	 QWORD PTR state$[rsp], rax

; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00034	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00038	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0003f	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00044	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [rax+28], 0
  0004b	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00050	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 111  :     strm->msg = Z_NULL;

  00057	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  0005c	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  00064	48 8b 44 24 20	 mov	 rax, QWORD PTR strm$[rsp]
  00069	c7 40 4c 01 00
	00 00		 mov	 DWORD PTR [rax+76], 1

; 113  :     state->mode = HEAD;

  00070	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00074	c7 00 00 00 00
	00		 mov	 DWORD PTR [rax], 0

; 114  :     state->last = 0;

  0007a	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0007e	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [rax+4], 0

; 115  :     state->havedict = 0;

  00085	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00089	c7 40 0c 00 00
	00 00		 mov	 DWORD PTR [rax+12], 0

; 116  :     state->dmax = 32768U;

  00090	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  00094	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [rax+20], 32768 ; 00008000H

; 117  :     state->head = Z_NULL;

  0009b	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0009f	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 118  :     state->wsize = 0;

  000a7	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ab	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [rax+44], 0

; 119  :     state->whave = 0;

  000b2	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000b6	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [rax+48], 0

; 120  :     state->write = 0;

  000bd	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000c1	c7 40 34 00 00
	00 00		 mov	 DWORD PTR [rax+52], 0

; 121  :     state->hold = 0;

  000c8	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000cc	c7 40 40 00 00
	00 00		 mov	 DWORD PTR [rax+64], 0

; 122  :     state->bits = 0;

  000d3	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000d7	c7 40 44 00 00
	00 00		 mov	 DWORD PTR [rax+68], 0

; 123  :     state->lencode = state->distcode = state->next = state->codes;

  000de	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000e2	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  000e9	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000ed	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx
  000f4	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  000f8	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  000fc	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  00103	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax
  00107	48 8b 0c 24	 mov	 rcx, QWORD PTR state$[rsp]
  0010b	48 8b 04 24	 mov	 rax, QWORD PTR state$[rsp]
  0010f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  00113	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 124  :     Tracev((stderr, "inflate: reset\n"));
; 125  :     return Z_OK;

  00117	33 c0		 xor	 eax, eax
$LN3@inflateRes:

; 126  : }

  00119	48 83 c4 18	 add	 rsp, 24
  0011d	c3		 ret	 0
inflateReset ENDP
PUBLIC	inflateSync
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSync DD imagerel $LN10
	DD	imagerel $LN10+485
	DD	imagerel $unwind$inflateSync
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSync DD 010901H
	DD	08209H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSync
_TEXT	SEGMENT
in$ = 32
len$ = 36
buf$ = 40
out$ = 44
state$ = 48
strm$ = 80
inflateSync PROC					; COMDAT

; 1264 : {

$LN10:
  00000	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00005	48 83 ec 48	 sub	 rsp, 72			; 00000048H

; 1265 :     unsigned len;               /* number of bytes to look at or looked at */
; 1266 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1267 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1268 :     struct inflate_state FAR *state;
; 1269 : 
; 1270 :     /* check parameters */
; 1271 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00009	48 83 7c 24 50
	00		 cmp	 QWORD PTR strm$[rsp], 0
  0000f	74 0c		 je	 SHORT $LN6@inflateSyn@2
  00011	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00016	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  0001b	75 0a		 jne	 SHORT $LN7@inflateSyn@2
$LN6@inflateSyn@2:
  0001d	b8 fe ff ff ff	 mov	 eax, -2
  00022	e9 b9 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN7@inflateSyn@2:

; 1272 :     state = (struct inflate_state FAR *)strm->state;

  00027	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0002c	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  00030	48 89 44 24 30	 mov	 QWORD PTR state$[rsp], rax

; 1273 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00035	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0003a	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0003e	75 15		 jne	 SHORT $LN5@inflateSyn@2
  00040	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00045	83 78 44 08	 cmp	 DWORD PTR [rax+68], 8
  00049	73 0a		 jae	 SHORT $LN5@inflateSyn@2
  0004b	b8 fb ff ff ff	 mov	 eax, -5
  00050	e9 8b 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN5@inflateSyn@2:

; 1274 : 
; 1275 :     /* if first time, start search in bit buffer */
; 1276 :     if (state->mode != SYNC) {

  00055	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0005a	83 38 1d	 cmp	 DWORD PTR [rax], 29
  0005d	0f 84 c2 00 00
	00		 je	 $LN4@inflateSyn@2

; 1277 :         state->mode = SYNC;

  00063	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00068	c7 00 1d 00 00
	00		 mov	 DWORD PTR [rax], 29

; 1278 :         state->hold <<= state->bits & 7;

  0006e	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00073	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  00076	83 e1 07	 and	 ecx, 7
  00079	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0007e	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  00081	d3 e0		 shl	 eax, cl
  00083	8b c8		 mov	 ecx, eax
  00085	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0008a	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 1279 :         state->bits -= state->bits & 7;

  0008d	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00092	8b 50 44	 mov	 edx, DWORD PTR [rax+68]
  00095	83 e2 07	 and	 edx, 7
  00098	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0009d	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  000a0	2b ca		 sub	 ecx, edx
  000a2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000a7	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 1280 :         len = 0;

  000aa	c7 44 24 24 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0
$LN3@inflateSyn@2:

; 1281 :         while (state->bits >= 8) {

  000b2	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000b7	83 78 44 08	 cmp	 DWORD PTR [rax+68], 8
  000bb	72 44		 jb	 SHORT $LN2@inflateSyn@2

; 1282 :             buf[len++] = (unsigned char)(state->hold);

  000bd	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  000c1	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000c6	0f b6 40 40	 movzx	 eax, BYTE PTR [rax+64]
  000ca	88 44 0c 28	 mov	 BYTE PTR buf$[rsp+rcx], al
  000ce	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  000d2	83 c0 01	 add	 eax, 1
  000d5	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1283 :             state->hold >>= 8;

  000d9	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000de	8b 48 40	 mov	 ecx, DWORD PTR [rax+64]
  000e1	c1 e9 08	 shr	 ecx, 8
  000e4	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000e9	89 48 40	 mov	 DWORD PTR [rax+64], ecx

; 1284 :             state->bits -= 8;

  000ec	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000f1	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  000f4	83 e9 08	 sub	 ecx, 8
  000f7	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  000fc	89 48 44	 mov	 DWORD PTR [rax+68], ecx

; 1285 :         }

  000ff	eb b1		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1286 :         state->have = 0;

  00101	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  00106	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 1287 :         syncsearch(&(state->have), buf, len);

  0010d	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  00112	48 83 c1 7c	 add	 rcx, 124		; 0000007cH
  00116	44 8b 44 24 24	 mov	 r8d, DWORD PTR len$[rsp]
  0011b	48 8d 54 24 28	 lea	 rdx, QWORD PTR buf$[rsp]
  00120	e8 00 00 00 00	 call	 syncsearch
$LN4@inflateSyn@2:

; 1288 :     }
; 1289 : 
; 1290 :     /* search available input */
; 1291 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  00125	48 8b 4c 24 30	 mov	 rcx, QWORD PTR state$[rsp]
  0012a	48 83 c1 7c	 add	 rcx, 124		; 0000007cH
  0012e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00133	44 8b 40 08	 mov	 r8d, DWORD PTR [rax+8]
  00137	48 8b 54 24 50	 mov	 rdx, QWORD PTR strm$[rsp]
  0013c	48 8b 12	 mov	 rdx, QWORD PTR [rdx]
  0013f	e8 00 00 00 00	 call	 syncsearch
  00144	89 44 24 24	 mov	 DWORD PTR len$[rsp], eax

; 1292 :     strm->avail_in -= len;

  00148	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  0014d	8b 44 24 24	 mov	 eax, DWORD PTR len$[rsp]
  00151	8b 49 08	 mov	 ecx, DWORD PTR [rcx+8]
  00154	2b c8		 sub	 ecx, eax
  00156	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0015b	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 1293 :     strm->next_in += len;

  0015e	8b 4c 24 24	 mov	 ecx, DWORD PTR len$[rsp]
  00162	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00167	48 03 08	 add	 rcx, QWORD PTR [rax]
  0016a	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0016f	48 89 08	 mov	 QWORD PTR [rax], rcx

; 1294 :     strm->total_in += len;

  00172	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00177	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  0017a	03 4c 24 24	 add	 ecx, DWORD PTR len$[rsp]
  0017e	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  00183	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1295 : 
; 1296 :     /* return no joy or set up to restart inflate() on a new block */
; 1297 :     if (state->have != 4) return Z_DATA_ERROR;

  00186	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  0018b	83 78 7c 04	 cmp	 DWORD PTR [rax+124], 4
  0018f	74 07		 je	 SHORT $LN1@inflateSyn@2
  00191	b8 fd ff ff ff	 mov	 eax, -3
  00196	eb 48		 jmp	 SHORT $LN8@inflateSyn@2
$LN1@inflateSyn@2:

; 1298 :     in = strm->total_in;  out = strm->total_out;

  00198	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  0019d	8b 40 0c	 mov	 eax, DWORD PTR [rax+12]
  001a0	89 44 24 20	 mov	 DWORD PTR in$[rsp], eax
  001a4	48 8b 44 24 50	 mov	 rax, QWORD PTR strm$[rsp]
  001a9	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  001ac	89 44 24 2c	 mov	 DWORD PTR out$[rsp], eax

; 1299 :     inflateReset(strm);

  001b0	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  001b5	e8 00 00 00 00	 call	 inflateReset

; 1300 :     strm->total_in = in;  strm->total_out = out;

  001ba	4c 8b 5c 24 50	 mov	 r11, QWORD PTR strm$[rsp]
  001bf	8b 44 24 20	 mov	 eax, DWORD PTR in$[rsp]
  001c3	41 89 43 0c	 mov	 DWORD PTR [r11+12], eax
  001c7	48 8b 4c 24 50	 mov	 rcx, QWORD PTR strm$[rsp]
  001cc	8b 44 24 2c	 mov	 eax, DWORD PTR out$[rsp]
  001d0	89 41 1c	 mov	 DWORD PTR [rcx+28], eax

; 1301 :     state->mode = TYPE;

  001d3	48 8b 44 24 30	 mov	 rax, QWORD PTR state$[rsp]
  001d8	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 1302 :     return Z_OK;

  001de	33 c0		 xor	 eax, eax
$LN8@inflateSyn@2:

; 1303 : }

  001e0	48 83 c4 48	 add	 rsp, 72			; 00000048H
  001e4	c3		 ret	 0
inflateSync ENDP
_TEXT	ENDS
PUBLIC	inflateSetDictionary
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateSetDictionary DD imagerel $LN11
	DD	imagerel $LN11+363
	DD	imagerel $unwind$inflateSetDictionary
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateSetDictionary DD 011301H
	DD	06213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateSetDictionary
_TEXT	SEGMENT
id$ = 32
state$ = 40
strm$ = 64
dictionary$ = 72
dictLength$ = 80
inflateSetDictionary PROC				; COMDAT

; 1173 : {

$LN11:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 1174 :     struct inflate_state FAR *state;
; 1175 :     unsigned long id;
; 1176 : 
; 1177 :     /* check state */
; 1178 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00013	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 0c		 je	 SHORT $LN7@inflateSet
  0001b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00020	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00025	75 0a		 jne	 SHORT $LN8@inflateSet
$LN7@inflateSet:
  00027	b8 fe ff ff ff	 mov	 eax, -2
  0002c	e9 35 01 00 00	 jmp	 $LN9@inflateSet
$LN8@inflateSet:

; 1179 :     state = (struct inflate_state FAR *)strm->state;

  00031	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00036	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0003a	48 89 44 24 28	 mov	 QWORD PTR state$[rsp], rax

; 1180 :     if (state->wrap != 0 && state->mode != DICT)

  0003f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00044	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00048	74 14		 je	 SHORT $LN6@inflateSet
  0004a	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0004f	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00052	74 0a		 je	 SHORT $LN6@inflateSet

; 1181 :         return Z_STREAM_ERROR;

  00054	b8 fe ff ff ff	 mov	 eax, -2
  00059	e9 08 01 00 00	 jmp	 $LN9@inflateSet
$LN6@inflateSet:

; 1182 : 
; 1183 :     /* check for correct dictionary id */
; 1184 :     if (state->mode == DICT) {

  0005e	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00063	83 38 0a	 cmp	 DWORD PTR [rax], 10
  00066	75 3f		 jne	 SHORT $LN5@inflateSet

; 1185 :         id = adler32(0L, Z_NULL, 0);

  00068	45 33 c0	 xor	 r8d, r8d
  0006b	33 d2		 xor	 edx, edx
  0006d	33 c9		 xor	 ecx, ecx
  0006f	e8 00 00 00 00	 call	 adler32
  00074	89 44 24 20	 mov	 DWORD PTR id$[rsp], eax

; 1186 :         id = adler32(id, dictionary, dictLength);

  00078	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  0007d	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00082	8b 4c 24 20	 mov	 ecx, DWORD PTR id$[rsp]
  00086	e8 00 00 00 00	 call	 adler32
  0008b	89 44 24 20	 mov	 DWORD PTR id$[rsp], eax

; 1187 :         if (id != state->check)

  0008f	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00094	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00097	39 44 24 20	 cmp	 DWORD PTR id$[rsp], eax
  0009b	74 0a		 je	 SHORT $LN4@inflateSet

; 1188 :             return Z_DATA_ERROR;

  0009d	b8 fd ff ff ff	 mov	 eax, -3
  000a2	e9 bf 00 00 00	 jmp	 $LN9@inflateSet
$LN4@inflateSet:
$LN5@inflateSet:

; 1189 :     }
; 1190 : 
; 1191 :     /* copy dictionary to window */
; 1192 :     if (updatewindow(strm, strm->avail_out)) {

  000a7	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000ac	8b 50 18	 mov	 edx, DWORD PTR [rax+24]
  000af	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b4	e8 00 00 00 00	 call	 updatewindow
  000b9	85 c0		 test	 eax, eax
  000bb	74 15		 je	 SHORT $LN3@inflateSet

; 1193 :         state->mode = MEM;

  000bd	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000c2	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 1194 :         return Z_MEM_ERROR;

  000c8	b8 fc ff ff ff	 mov	 eax, -4
  000cd	e9 94 00 00 00	 jmp	 $LN9@inflateSet
$LN3@inflateSet:

; 1195 :     }
; 1196 :     if (dictLength > state->wsize) {

  000d2	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000d7	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000da	39 44 24 50	 cmp	 DWORD PTR dictLength$[rsp], eax
  000de	76 41		 jbe	 SHORT $LN2@inflateSet

; 1197 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1198 :                 state->wsize);

  000e0	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000e5	44 8b 40 2c	 mov	 r8d, DWORD PTR [rax+44]
  000e9	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  000ed	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  000f2	48 03 d0	 add	 rdx, rax
  000f5	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  000fa	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  000fd	48 2b d0	 sub	 rdx, rax
  00100	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00105	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00109	e8 00 00 00 00	 call	 memcpy

; 1199 :         state->whave = state->wsize;

  0010e	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  00113	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  00118	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0011b	41 89 43 30	 mov	 DWORD PTR [r11+48], eax

; 1200 :     }
; 1201 :     else {

  0011f	eb 37		 jmp	 SHORT $LN1@inflateSet
$LN2@inflateSet:

; 1202 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1203 :                 dictLength);

  00121	44 8b 44 24 50	 mov	 r8d, DWORD PTR dictLength$[rsp]
  00126	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0012b	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0012e	48 8b 4c 24 28	 mov	 rcx, QWORD PTR state$[rsp]
  00133	48 8b 49 38	 mov	 rcx, QWORD PTR [rcx+56]
  00137	48 03 c8	 add	 rcx, rax
  0013a	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  0013e	48 2b c8	 sub	 rcx, rax
  00141	48 8b 54 24 48	 mov	 rdx, QWORD PTR dictionary$[rsp]
  00146	e8 00 00 00 00	 call	 memcpy

; 1204 :         state->whave = dictLength;

  0014b	4c 8b 5c 24 28	 mov	 r11, QWORD PTR state$[rsp]
  00150	8b 44 24 50	 mov	 eax, DWORD PTR dictLength$[rsp]
  00154	41 89 43 30	 mov	 DWORD PTR [r11+48], eax
$LN1@inflateSet:

; 1205 :     }
; 1206 :     state->havedict = 1;

  00158	48 8b 44 24 28	 mov	 rax, QWORD PTR state$[rsp]
  0015d	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [rax+12], 1

; 1207 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1208 :     return Z_OK;

  00164	33 c0		 xor	 eax, eax
$LN9@inflateSet:

; 1209 : }

  00166	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0016a	c3		 ret	 0
inflateSetDictionary ENDP
_TEXT	ENDS
PUBLIC	inflate
EXTRN	__ImageBase:BYTE
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflate DD imagerel $LN511
	DD	imagerel $LN511+11764
	DD	imagerel $unwind$inflate
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflate DD 021001H
	DD	0170110H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflate
_TEXT	SEGMENT
put$ = 48
last$ = 56
have$ = 60
in$ = 64
len$ = 68
bits$ = 72
left$ = 76
next$ = 80
ret$ = 88
hold$ = 92
hbuf$ = 96
this$ = 100
copy$ = 104
from$ = 112
out$ = 120
state$ = 128
tv80 = 136
tv182 = 140
tv348 = 144
tv561 = 148
tv1222 = 152
tv1236 = 156
tv1311 = 160
tv1316 = 164
tv1319 = 168
strm$ = 192
flush$ = 200
inflate	PROC						; COMDAT

; 557  : {

$LN511:
  00000	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  00004	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00009	48 81 ec b8 00
	00 00		 sub	 rsp, 184		; 000000b8H

; 558  :     struct inflate_state FAR *state;
; 559  :     unsigned char FAR *next;    /* next input */
; 560  :     unsigned char FAR *put;     /* next output */
; 561  :     unsigned have, left;        /* available input and output */
; 562  :     unsigned long hold;         /* bit buffer */
; 563  :     unsigned bits;              /* bits in bit buffer */
; 564  :     unsigned in, out;           /* save starting available input and output */
; 565  :     unsigned copy;              /* number of stored or match bytes to copy */
; 566  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 567  :     code this;                  /* current decoding table entry */
; 568  :     code last;                  /* parent table entry */
; 569  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 570  :     int ret;                    /* return code */
; 571  : #ifdef GUNZIP
; 572  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 573  : #endif
; 574  :     static const unsigned short order[19] = /* permutation of code lengths */
; 575  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 576  : 
; 577  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 578  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00010	48 83 bc 24 c0
	00 00 00 00	 cmp	 QWORD PTR strm$[rsp], 0
  00019	74 3a		 je	 SHORT $LN492@inflate
  0001b	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00023	48 83 78 28 00	 cmp	 QWORD PTR [rax+40], 0
  00028	74 2b		 je	 SHORT $LN492@inflate
  0002a	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00032	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  00037	74 1c		 je	 SHORT $LN492@inflate
  00039	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00041	48 83 38 00	 cmp	 QWORD PTR [rax], 0
  00045	75 18		 jne	 SHORT $LN493@inflate
  00047	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0004f	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  00053	74 0a		 je	 SHORT $LN493@inflate
$LN492@inflate:

; 579  :         return Z_STREAM_ERROR;

  00055	b8 fe ff ff ff	 mov	 eax, -2
  0005a	e9 16 2d 00 00	 jmp	 $LN494@inflate
$LN493@inflate:

; 580  : 
; 581  :     state = (struct inflate_state FAR *)strm->state;

  0005f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 8b 40 28	 mov	 rax, QWORD PTR [rax+40]
  0006b	48 89 84 24 80
	00 00 00	 mov	 QWORD PTR state$[rsp], rax

; 582  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00073	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0007b	83 38 0b	 cmp	 DWORD PTR [rax], 11
  0007e	75 0e		 jne	 SHORT $LN491@inflate
  00080	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00088	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12
$LN491@inflate:
$LN490@inflate:

; 583  :     LOAD();

  0008e	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  00096	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  0009a	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  0009f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000a7	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  000aa	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  000ae	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000b6	48 8b 00	 mov	 rax, QWORD PTR [rax]
  000b9	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  000be	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  000c6	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  000c9	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  000cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000d5	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  000d8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  000dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  000e4	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  000e7	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  000eb	33 c0		 xor	 eax, eax
  000ed	85 c0		 test	 eax, eax
  000ef	75 9d		 jne	 SHORT $LN490@inflate

; 584  :     in = have;

  000f1	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  000f5	89 44 24 40	 mov	 DWORD PTR in$[rsp], eax

; 585  :     out = left;

  000f9	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  000fd	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 586  :     ret = Z_OK;

  00101	c7 44 24 58 00
	00 00 00	 mov	 DWORD PTR ret$[rsp], 0
$LN487@inflate:

; 587  :     for (;;)
; 588  :         switch (state->mode) {

  00109	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00111	8b 00		 mov	 eax, DWORD PTR [rax]
  00113	89 84 24 88 00
	00 00		 mov	 DWORD PTR tv80[rsp], eax
  0011a	83 bc 24 88 00
	00 00 1c	 cmp	 DWORD PTR tv80[rsp], 28
  00122	0f 87 c1 29 00
	00		 ja	 $LN11@inflate
  00128	48 63 84 24 88
	00 00 00	 movsxd	 rax, DWORD PTR tv80[rsp]
  00130	48 8d 0d 00 00
	00 00		 lea	 rcx, OFFSET FLAT:__ImageBase
  00137	8b 84 81 00 00
	00 00		 mov	 eax, DWORD PTR $LN510@inflate[rcx+rax*4]
  0013e	48 03 c1	 add	 rax, rcx
  00141	ff e0		 jmp	 rax
$LN483@inflate:

; 589  :         case HEAD:
; 590  :             if (state->wrap == 0) {

  00143	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0014b	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  0014f	75 13		 jne	 SHORT $LN482@inflate

; 591  :                 state->mode = TYPEDO;

  00151	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00159	c7 00 0c 00 00
	00		 mov	 DWORD PTR [rax], 12

; 592  :                 break;

  0015f	e9 8f 29 00 00	 jmp	 $LN484@inflate
$LN482@inflate:
$LN481@inflate:
$LN478@inflate:

; 593  :             }
; 594  :             NEEDBITS(16);

  00164	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  00169	73 57		 jae	 SHORT $LN477@inflate
$LN476@inflate:
  0016b	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00170	75 05		 jne	 SHORT $LN473@inflate
  00172	e9 81 29 00 00	 jmp	 $inf_leave$78250
$LN473@inflate:
  00177	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0017b	83 e8 01	 sub	 eax, 1
  0017e	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00182	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00187	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0018a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0018e	0f b6 c8	 movzx	 ecx, al
  00191	8b c2		 mov	 eax, edx
  00193	d3 e0		 shl	 eax, cl
  00195	8b c8		 mov	 ecx, eax
  00197	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0019b	03 c1		 add	 eax, ecx
  0019d	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  001a1	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  001a6	48 83 c0 01	 add	 rax, 1
  001aa	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  001af	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  001b3	83 c0 08	 add	 eax, 8
  001b6	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  001ba	33 c0		 xor	 eax, eax
  001bc	85 c0		 test	 eax, eax
  001be	75 ab		 jne	 SHORT $LN476@inflate
  001c0	eb a2		 jmp	 SHORT $LN478@inflate
$LN477@inflate:
  001c2	33 c0		 xor	 eax, eax
  001c4	85 c0		 test	 eax, eax
  001c6	75 9c		 jne	 SHORT $LN481@inflate

; 595  : #ifdef GUNZIP
; 596  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  001c8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  001d0	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  001d3	83 e0 02	 and	 eax, 2
  001d6	85 c0		 test	 eax, eax
  001d8	0f 84 96 00 00
	00		 je	 $LN472@inflate
  001de	81 7c 24 5c 1f
	8b 00 00	 cmp	 DWORD PTR hold$[rsp], 35615 ; 00008b1fH
  001e6	0f 85 88 00 00
	00		 jne	 $LN472@inflate

; 597  :                 state->check = crc32(0L, Z_NULL, 0);

  001ec	45 33 c0	 xor	 r8d, r8d
  001ef	33 d2		 xor	 edx, edx
  001f1	33 c9		 xor	 ecx, ecx
  001f3	e8 00 00 00 00	 call	 crc32
  001f8	44 8b d8	 mov	 r11d, eax
  001fb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00203	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN471@inflate:

; 598  :                 CRC2(state->check, hold);

  00207	0f b6 44 24 5c	 movzx	 eax, BYTE PTR hold$[rsp]
  0020c	88 44 24 60	 mov	 BYTE PTR hbuf$[rsp], al
  00210	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00214	c1 e8 08	 shr	 eax, 8
  00217	88 44 24 61	 mov	 BYTE PTR hbuf$[rsp+1], al
  0021b	41 b8 02 00 00
	00		 mov	 r8d, 2
  00221	48 8d 54 24 60	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00226	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0022e	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00231	e8 00 00 00 00	 call	 crc32
  00236	44 8b d8	 mov	 r11d, eax
  00239	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00241	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  00245	33 c0		 xor	 eax, eax
  00247	85 c0		 test	 eax, eax
  00249	75 bc		 jne	 SHORT $LN471@inflate
$LN468@inflate:

; 599  :                 INITBITS();

  0024b	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00253	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  0025b	33 c0		 xor	 eax, eax
  0025d	85 c0		 test	 eax, eax
  0025f	75 ea		 jne	 SHORT $LN468@inflate

; 600  :                 state->mode = FLAGS;

  00261	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00269	c7 00 01 00 00
	00		 mov	 DWORD PTR [rax], 1

; 601  :                 break;

  0026f	e9 7f 28 00 00	 jmp	 $LN484@inflate
$LN472@inflate:

; 602  :             }
; 603  :             state->flags = 0;           /* expect zlib header */

  00274	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0027c	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [rax+16], 0

; 604  :             if (state->head != Z_NULL)

  00283	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0028b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00290	74 13		 je	 SHORT $LN465@inflate

; 605  :                 state->head->done = -1;

  00292	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0029a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0029e	c7 40 40 ff ff
	ff ff		 mov	 DWORD PTR [rax+64], -1
$LN465@inflate:

; 606  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 607  : #else
; 608  :             if (
; 609  : #endif
; 610  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  002a5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002ad	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  002b0	83 e0 01	 and	 eax, 1
  002b3	85 c0		 test	 eax, eax
  002b5	74 22		 je	 SHORT $LN463@inflate
  002b7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  002bb	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  002c0	c1 e0 08	 shl	 eax, 8
  002c3	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  002c7	c1 e9 08	 shr	 ecx, 8
  002ca	03 c1		 add	 eax, ecx
  002cc	33 d2		 xor	 edx, edx
  002ce	b9 1f 00 00 00	 mov	 ecx, 31
  002d3	f7 f1		 div	 ecx
  002d5	85 d2		 test	 edx, edx
  002d7	74 26		 je	 SHORT $LN464@inflate
$LN463@inflate:

; 611  :                 strm->msg = (char *)"incorrect header check";

  002d9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  002e1	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
  002e8	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 612  :                 state->mode = BAD;

  002ec	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  002f4	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 613  :                 break;

  002fa	e9 f4 27 00 00	 jmp	 $LN484@inflate
$LN464@inflate:

; 614  :             }
; 615  :             if (BITS(4) != Z_DEFLATED) {

  002ff	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00303	83 e0 0f	 and	 eax, 15
  00306	83 f8 08	 cmp	 eax, 8
  00309	74 26		 je	 SHORT $LN462@inflate

; 616  :                 strm->msg = (char *)"unknown compression method";

  0030b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00313	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  0031a	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 617  :                 state->mode = BAD;

  0031e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00326	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 618  :                 break;

  0032c	e9 c2 27 00 00	 jmp	 $LN484@inflate
$LN462@inflate:
$LN461@inflate:

; 619  :             }
; 620  :             DROPBITS(4);

  00331	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00335	c1 e8 04	 shr	 eax, 4
  00338	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0033c	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00340	83 e8 04	 sub	 eax, 4
  00343	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00347	33 c0		 xor	 eax, eax
  00349	85 c0		 test	 eax, eax
  0034b	75 e4		 jne	 SHORT $LN461@inflate

; 621  :             len = BITS(4) + 8;

  0034d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00351	83 e0 0f	 and	 eax, 15
  00354	83 c0 08	 add	 eax, 8
  00357	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 622  :             if (len > state->wbits) {

  0035b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00363	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00366	39 44 24 44	 cmp	 DWORD PTR len$[rsp], eax
  0036a	76 26		 jbe	 SHORT $LN458@inflate

; 623  :                 strm->msg = (char *)"invalid window size";

  0036c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00374	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
  0037b	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 624  :                 state->mode = BAD;

  0037f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00387	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 625  :                 break;

  0038d	e9 61 27 00 00	 jmp	 $LN484@inflate
$LN458@inflate:

; 626  :             }
; 627  :             state->dmax = 1U << len;

  00392	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00396	b8 01 00 00 00	 mov	 eax, 1
  0039b	d3 e0		 shl	 eax, cl
  0039d	8b c8		 mov	 ecx, eax
  0039f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003a7	89 48 14	 mov	 DWORD PTR [rax+20], ecx

; 628  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 629  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  003aa	45 33 c0	 xor	 r8d, r8d
  003ad	33 d2		 xor	 edx, edx
  003af	33 c9		 xor	 ecx, ecx
  003b1	e8 00 00 00 00	 call	 adler32
  003b6	44 8b d8	 mov	 r11d, eax
  003b9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003c1	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  003c5	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  003cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  003d5	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  003d8	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 630  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  003db	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  003df	25 00 02 00 00	 and	 eax, 512		; 00000200H
  003e4	85 c0		 test	 eax, eax
  003e6	74 0d		 je	 SHORT $LN496@inflate
  003e8	c7 84 24 8c 00
	00 00 09 00 00
	00		 mov	 DWORD PTR tv182[rsp], 9
  003f3	eb 0b		 jmp	 SHORT $LN497@inflate
$LN496@inflate:
  003f5	c7 84 24 8c 00
	00 00 0b 00 00
	00		 mov	 DWORD PTR tv182[rsp], 11
$LN497@inflate:
  00400	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00408	8b 84 24 8c 00
	00 00		 mov	 eax, DWORD PTR tv182[rsp]
  0040f	89 01		 mov	 DWORD PTR [rcx], eax
$LN457@inflate:

; 631  :             INITBITS();

  00411	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00419	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00421	33 c0		 xor	 eax, eax
  00423	85 c0		 test	 eax, eax
  00425	75 ea		 jne	 SHORT $LN457@inflate

; 632  :             break;

  00427	e9 c7 26 00 00	 jmp	 $LN484@inflate
$LN454@inflate:
$LN453@inflate:
$LN450@inflate:

; 633  : #ifdef GUNZIP
; 634  :         case FLAGS:
; 635  :             NEEDBITS(16);

  0042c	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  00431	73 57		 jae	 SHORT $LN449@inflate
$LN448@inflate:
  00433	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00438	75 05		 jne	 SHORT $LN445@inflate
  0043a	e9 b9 26 00 00	 jmp	 $inf_leave$78250
$LN445@inflate:
  0043f	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00443	83 e8 01	 sub	 eax, 1
  00446	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  0044a	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0044f	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00452	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00456	0f b6 c8	 movzx	 ecx, al
  00459	8b c2		 mov	 eax, edx
  0045b	d3 e0		 shl	 eax, cl
  0045d	8b c8		 mov	 ecx, eax
  0045f	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00463	03 c1		 add	 eax, ecx
  00465	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00469	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0046e	48 83 c0 01	 add	 rax, 1
  00472	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00477	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0047b	83 c0 08	 add	 eax, 8
  0047e	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00482	33 c0		 xor	 eax, eax
  00484	85 c0		 test	 eax, eax
  00486	75 ab		 jne	 SHORT $LN448@inflate
  00488	eb a2		 jmp	 SHORT $LN450@inflate
$LN449@inflate:
  0048a	33 c0		 xor	 eax, eax
  0048c	85 c0		 test	 eax, eax
  0048e	75 9c		 jne	 SHORT $LN453@inflate

; 636  :             state->flags = (int)(hold);

  00490	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00498	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0049c	89 41 10	 mov	 DWORD PTR [rcx+16], eax

; 637  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  0049f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004a7	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  004aa	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  004af	83 f8 08	 cmp	 eax, 8
  004b2	74 26		 je	 SHORT $LN444@inflate

; 638  :                 strm->msg = (char *)"unknown compression method";

  004b4	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  004bc	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
  004c3	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 639  :                 state->mode = BAD;

  004c7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004cf	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 640  :                 break;

  004d5	e9 19 26 00 00	 jmp	 $LN484@inflate
$LN444@inflate:

; 641  :             }
; 642  :             if (state->flags & 0xe000) {

  004da	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  004e2	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  004e5	25 00 e0 00 00	 and	 eax, 57344		; 0000e000H
  004ea	85 c0		 test	 eax, eax
  004ec	74 26		 je	 SHORT $LN443@inflate

; 643  :                 strm->msg = (char *)"unknown header flags set";

  004ee	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  004f6	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
  004fd	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 644  :                 state->mode = BAD;

  00501	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00509	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 645  :                 break;

  0050f	e9 df 25 00 00	 jmp	 $LN484@inflate
$LN443@inflate:

; 646  :             }
; 647  :             if (state->head != Z_NULL)

  00514	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0051c	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00521	74 18		 je	 SHORT $LN442@inflate

; 648  :                 state->head->text = (int)((hold >> 8) & 1);

  00523	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00527	c1 e9 08	 shr	 ecx, 8
  0052a	83 e1 01	 and	 ecx, 1
  0052d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00535	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00539	89 08		 mov	 DWORD PTR [rax], ecx
$LN442@inflate:

; 649  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  0053b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00543	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00546	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0054b	85 c0		 test	 eax, eax
  0054d	74 44		 je	 SHORT $LN441@inflate
$LN440@inflate:
  0054f	0f b6 44 24 5c	 movzx	 eax, BYTE PTR hold$[rsp]
  00554	88 44 24 60	 mov	 BYTE PTR hbuf$[rsp], al
  00558	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0055c	c1 e8 08	 shr	 eax, 8
  0055f	88 44 24 61	 mov	 BYTE PTR hbuf$[rsp+1], al
  00563	41 b8 02 00 00
	00		 mov	 r8d, 2
  00569	48 8d 54 24 60	 lea	 rdx, QWORD PTR hbuf$[rsp]
  0056e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00576	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00579	e8 00 00 00 00	 call	 crc32
  0057e	44 8b d8	 mov	 r11d, eax
  00581	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00589	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  0058d	33 c0		 xor	 eax, eax
  0058f	85 c0		 test	 eax, eax
  00591	75 bc		 jne	 SHORT $LN440@inflate
$LN441@inflate:
$LN437@inflate:

; 650  :             INITBITS();

  00593	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0059b	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  005a3	33 c0		 xor	 eax, eax
  005a5	85 c0		 test	 eax, eax
  005a7	75 ea		 jne	 SHORT $LN437@inflate

; 651  :             state->mode = TIME;

  005a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  005b1	c7 00 02 00 00
	00		 mov	 DWORD PTR [rax], 2
$LN434@inflate:
$LN433@inflate:
$LN430@inflate:

; 652  :         case TIME:
; 653  :             NEEDBITS(32);

  005b7	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  005bc	73 57		 jae	 SHORT $LN429@inflate
$LN428@inflate:
  005be	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  005c3	75 05		 jne	 SHORT $LN425@inflate
  005c5	e9 2e 25 00 00	 jmp	 $inf_leave$78250
$LN425@inflate:
  005ca	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  005ce	83 e8 01	 sub	 eax, 1
  005d1	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  005d5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005da	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  005dd	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  005e1	0f b6 c8	 movzx	 ecx, al
  005e4	8b c2		 mov	 eax, edx
  005e6	d3 e0		 shl	 eax, cl
  005e8	8b c8		 mov	 ecx, eax
  005ea	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  005ee	03 c1		 add	 eax, ecx
  005f0	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  005f4	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  005f9	48 83 c0 01	 add	 rax, 1
  005fd	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00602	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00606	83 c0 08	 add	 eax, 8
  00609	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0060d	33 c0		 xor	 eax, eax
  0060f	85 c0		 test	 eax, eax
  00611	75 ab		 jne	 SHORT $LN428@inflate
  00613	eb a2		 jmp	 SHORT $LN430@inflate
$LN429@inflate:
  00615	33 c0		 xor	 eax, eax
  00617	85 c0		 test	 eax, eax
  00619	75 9c		 jne	 SHORT $LN433@inflate

; 654  :             if (state->head != Z_NULL)

  0061b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00623	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00628	74 13		 je	 SHORT $LN424@inflate

; 655  :                 state->head->time = hold;

  0062a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00632	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00636	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0063a	89 41 04	 mov	 DWORD PTR [rcx+4], eax
$LN424@inflate:

; 656  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  0063d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00645	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00648	25 00 02 00 00	 and	 eax, 512		; 00000200H
  0064d	85 c0		 test	 eax, eax
  0064f	74 5a		 je	 SHORT $LN423@inflate
$LN422@inflate:
  00651	0f b6 44 24 5c	 movzx	 eax, BYTE PTR hold$[rsp]
  00656	88 44 24 60	 mov	 BYTE PTR hbuf$[rsp], al
  0065a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0065e	c1 e8 08	 shr	 eax, 8
  00661	88 44 24 61	 mov	 BYTE PTR hbuf$[rsp+1], al
  00665	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00669	c1 e8 10	 shr	 eax, 16
  0066c	88 44 24 62	 mov	 BYTE PTR hbuf$[rsp+2], al
  00670	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00674	c1 e8 18	 shr	 eax, 24
  00677	88 44 24 63	 mov	 BYTE PTR hbuf$[rsp+3], al
  0067b	41 b8 04 00 00
	00		 mov	 r8d, 4
  00681	48 8d 54 24 60	 lea	 rdx, QWORD PTR hbuf$[rsp]
  00686	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0068e	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00691	e8 00 00 00 00	 call	 crc32
  00696	44 8b d8	 mov	 r11d, eax
  00699	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006a1	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  006a5	33 c0		 xor	 eax, eax
  006a7	85 c0		 test	 eax, eax
  006a9	75 a6		 jne	 SHORT $LN422@inflate
$LN423@inflate:
$LN419@inflate:

; 657  :             INITBITS();

  006ab	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  006b3	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  006bb	33 c0		 xor	 eax, eax
  006bd	85 c0		 test	 eax, eax
  006bf	75 ea		 jne	 SHORT $LN419@inflate

; 658  :             state->mode = OS;

  006c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  006c9	c7 00 03 00 00
	00		 mov	 DWORD PTR [rax], 3
$LN416@inflate:
$LN415@inflate:
$LN412@inflate:

; 659  :         case OS:
; 660  :             NEEDBITS(16);

  006cf	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  006d4	73 57		 jae	 SHORT $LN411@inflate
$LN410@inflate:
  006d6	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  006db	75 05		 jne	 SHORT $LN407@inflate
  006dd	e9 16 24 00 00	 jmp	 $inf_leave$78250
$LN407@inflate:
  006e2	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  006e6	83 e8 01	 sub	 eax, 1
  006e9	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  006ed	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  006f2	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  006f5	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  006f9	0f b6 c8	 movzx	 ecx, al
  006fc	8b c2		 mov	 eax, edx
  006fe	d3 e0		 shl	 eax, cl
  00700	8b c8		 mov	 ecx, eax
  00702	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00706	03 c1		 add	 eax, ecx
  00708	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0070c	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00711	48 83 c0 01	 add	 rax, 1
  00715	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  0071a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0071e	83 c0 08	 add	 eax, 8
  00721	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00725	33 c0		 xor	 eax, eax
  00727	85 c0		 test	 eax, eax
  00729	75 ab		 jne	 SHORT $LN410@inflate
  0072b	eb a2		 jmp	 SHORT $LN412@inflate
$LN411@inflate:
  0072d	33 c0		 xor	 eax, eax
  0072f	85 c0		 test	 eax, eax
  00731	75 9c		 jne	 SHORT $LN415@inflate

; 661  :             if (state->head != Z_NULL) {

  00733	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0073b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00740	74 2f		 je	 SHORT $LN406@inflate

; 662  :                 state->head->xflags = (int)(hold & 0xff);

  00742	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00746	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0074c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00754	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00758	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 663  :                 state->head->os = (int)(hold >> 8);

  0075b	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0075f	c1 e9 08	 shr	 ecx, 8
  00762	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0076a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0076e	89 48 0c	 mov	 DWORD PTR [rax+12], ecx
$LN406@inflate:

; 664  :             }
; 665  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00771	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00779	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  0077c	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00781	85 c0		 test	 eax, eax
  00783	74 44		 je	 SHORT $LN405@inflate
$LN404@inflate:
  00785	0f b6 44 24 5c	 movzx	 eax, BYTE PTR hold$[rsp]
  0078a	88 44 24 60	 mov	 BYTE PTR hbuf$[rsp], al
  0078e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00792	c1 e8 08	 shr	 eax, 8
  00795	88 44 24 61	 mov	 BYTE PTR hbuf$[rsp+1], al
  00799	41 b8 02 00 00
	00		 mov	 r8d, 2
  0079f	48 8d 54 24 60	 lea	 rdx, QWORD PTR hbuf$[rsp]
  007a4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007ac	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  007af	e8 00 00 00 00	 call	 crc32
  007b4	44 8b d8	 mov	 r11d, eax
  007b7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007bf	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  007c3	33 c0		 xor	 eax, eax
  007c5	85 c0		 test	 eax, eax
  007c7	75 bc		 jne	 SHORT $LN404@inflate
$LN405@inflate:
$LN401@inflate:

; 666  :             INITBITS();

  007c9	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  007d1	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  007d9	33 c0		 xor	 eax, eax
  007db	85 c0		 test	 eax, eax
  007dd	75 ea		 jne	 SHORT $LN401@inflate

; 667  :             state->mode = EXLEN;

  007df	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007e7	c7 00 04 00 00
	00		 mov	 DWORD PTR [rax], 4
$LN398@inflate:

; 668  :         case EXLEN:
; 669  :             if (state->flags & 0x0400) {

  007ed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  007f5	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  007f8	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  007fd	85 c0		 test	 eax, eax
  007ff	0f 84 05 01 00
	00		 je	 $LN397@inflate
$LN396@inflate:
$LN393@inflate:

; 670  :                 NEEDBITS(16);

  00805	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  0080a	73 57		 jae	 SHORT $LN392@inflate
$LN391@inflate:
  0080c	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00811	75 05		 jne	 SHORT $LN388@inflate
  00813	e9 e0 22 00 00	 jmp	 $inf_leave$78250
$LN388@inflate:
  00818	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0081c	83 e8 01	 sub	 eax, 1
  0081f	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00823	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00828	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0082b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0082f	0f b6 c8	 movzx	 ecx, al
  00832	8b c2		 mov	 eax, edx
  00834	d3 e0		 shl	 eax, cl
  00836	8b c8		 mov	 ecx, eax
  00838	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0083c	03 c1		 add	 eax, ecx
  0083e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00842	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00847	48 83 c0 01	 add	 rax, 1
  0084b	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00850	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00854	83 c0 08	 add	 eax, 8
  00857	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0085b	33 c0		 xor	 eax, eax
  0085d	85 c0		 test	 eax, eax
  0085f	75 ab		 jne	 SHORT $LN391@inflate
  00861	eb a2		 jmp	 SHORT $LN393@inflate
$LN392@inflate:
  00863	33 c0		 xor	 eax, eax
  00865	85 c0		 test	 eax, eax
  00867	75 9c		 jne	 SHORT $LN396@inflate

; 671  :                 state->length = (unsigned)(hold);

  00869	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00871	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00875	89 41 48	 mov	 DWORD PTR [rcx+72], eax

; 672  :                 if (state->head != Z_NULL)

  00878	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00880	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00885	74 13		 je	 SHORT $LN387@inflate

; 673  :                     state->head->extra_len = (unsigned)hold;

  00887	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0088f	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00893	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00897	89 41 18	 mov	 DWORD PTR [rcx+24], eax
$LN387@inflate:

; 674  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  0089a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008a2	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  008a5	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008aa	85 c0		 test	 eax, eax
  008ac	74 44		 je	 SHORT $LN386@inflate
$LN385@inflate:
  008ae	0f b6 44 24 5c	 movzx	 eax, BYTE PTR hold$[rsp]
  008b3	88 44 24 60	 mov	 BYTE PTR hbuf$[rsp], al
  008b7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  008bb	c1 e8 08	 shr	 eax, 8
  008be	88 44 24 61	 mov	 BYTE PTR hbuf$[rsp+1], al
  008c2	41 b8 02 00 00
	00		 mov	 r8d, 2
  008c8	48 8d 54 24 60	 lea	 rdx, QWORD PTR hbuf$[rsp]
  008cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008d5	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  008d8	e8 00 00 00 00	 call	 crc32
  008dd	44 8b d8	 mov	 r11d, eax
  008e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  008e8	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  008ec	33 c0		 xor	 eax, eax
  008ee	85 c0		 test	 eax, eax
  008f0	75 bc		 jne	 SHORT $LN385@inflate
$LN386@inflate:
$LN382@inflate:

; 675  :                 INITBITS();

  008f2	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  008fa	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00902	33 c0		 xor	 eax, eax
  00904	85 c0		 test	 eax, eax
  00906	75 ea		 jne	 SHORT $LN382@inflate

; 676  :             }
; 677  :             else if (state->head != Z_NULL)

  00908	eb 23		 jmp	 SHORT $LN379@inflate
$LN397@inflate:
  0090a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00912	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00917	74 14		 je	 SHORT $LN378@inflate

; 678  :                 state->head->extra = Z_NULL;

  00919	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00921	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00925	48 c7 40 10 00
	00 00 00	 mov	 QWORD PTR [rax+16], 0
$LN378@inflate:
$LN379@inflate:

; 679  :             state->mode = EXTRA;

  0092d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00935	c7 00 05 00 00
	00		 mov	 DWORD PTR [rax], 5
$LN377@inflate:

; 680  :         case EXTRA:
; 681  :             if (state->flags & 0x0400) {

  0093b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00943	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00946	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0094b	85 c0		 test	 eax, eax
  0094d	0f 84 6b 01 00
	00		 je	 $LN376@inflate

; 682  :                 copy = state->length;

  00953	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0095b	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  0095e	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 683  :                 if (copy > have) copy = have;

  00962	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00966	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  0096a	76 08		 jbe	 SHORT $LN375@inflate
  0096c	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00970	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN375@inflate:

; 684  :                 if (copy) {

  00974	83 7c 24 68 00	 cmp	 DWORD PTR copy$[rsp], 0
  00979	0f 84 2c 01 00
	00		 je	 $LN374@inflate

; 685  :                     if (state->head != Z_NULL &&
; 686  :                         state->head->extra != Z_NULL) {

  0097f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00987	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  0098c	0f 84 a1 00 00
	00		 je	 $LN373@inflate
  00992	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0099a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  0099e	48 83 78 10 00	 cmp	 QWORD PTR [rax+16], 0
  009a3	0f 84 8a 00 00
	00		 je	 $LN373@inflate

; 687  :                         len = state->head->extra_len - state->length;

  009a9	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  009b1	48 8b 52 20	 mov	 rdx, QWORD PTR [rdx+32]
  009b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009bd	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  009c0	8b 42 18	 mov	 eax, DWORD PTR [rdx+24]
  009c3	2b c1		 sub	 eax, ecx
  009c5	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 688  :                         zmemcpy(state->head->extra + len, next,
; 689  :                                 len + copy > state->head->extra_max ?
; 690  :                                 state->head->extra_max - len : copy);

  009c9	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  009cd	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  009d1	03 c8		 add	 ecx, eax
  009d3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009db	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009df	3b 48 1c	 cmp	 ecx, DWORD PTR [rax+28]
  009e2	76 1e		 jbe	 SHORT $LN498@inflate
  009e4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  009ec	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  009f0	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  009f4	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  009f7	2b c1		 sub	 eax, ecx
  009f9	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv348[rsp], eax
  00a00	eb 0b		 jmp	 SHORT $LN499@inflate
$LN498@inflate:
  00a02	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  00a06	89 84 24 90 00
	00 00		 mov	 DWORD PTR tv348[rsp], eax
$LN499@inflate:
  00a0d	44 8b 84 24 90
	00 00 00	 mov	 r8d, DWORD PTR tv348[rsp]
  00a15	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a1d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00a21	8b 4c 24 44	 mov	 ecx, DWORD PTR len$[rsp]
  00a25	48 03 48 10	 add	 rcx, QWORD PTR [rax+16]
  00a29	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  00a2e	e8 00 00 00 00	 call	 memcpy
$LN373@inflate:

; 691  :                     }
; 692  :                     if (state->flags & 0x0200)

  00a33	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a3b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00a3e	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00a43	85 c0		 test	 eax, eax
  00a45	74 29		 je	 SHORT $LN372@inflate

; 693  :                         state->check = crc32(state->check, next, copy);

  00a47	44 8b 44 24 68	 mov	 r8d, DWORD PTR copy$[rsp]
  00a4c	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  00a51	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a59	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00a5c	e8 00 00 00 00	 call	 crc32
  00a61	44 8b d8	 mov	 r11d, eax
  00a64	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00a6c	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN372@inflate:

; 694  :                     have -= copy;

  00a70	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00a74	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00a78	2b c1		 sub	 eax, ecx
  00a7a	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax

; 695  :                     next += copy;

  00a7e	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00a82	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00a87	48 03 c1	 add	 rax, rcx
  00a8a	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 696  :                     state->length -= copy;

  00a8f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00a97	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  00a9b	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  00a9e	2b c8		 sub	 ecx, eax
  00aa0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00aa8	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN374@inflate:

; 697  :                 }
; 698  :                 if (state->length) goto inf_leave;

  00aab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ab3	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  00ab7	74 05		 je	 SHORT $LN371@inflate
  00ab9	e9 3a 20 00 00	 jmp	 $inf_leave$78250
$LN371@inflate:
$LN376@inflate:

; 699  :             }
; 700  :             state->length = 0;

  00abe	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ac6	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 701  :             state->mode = NAME;

  00acd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ad5	c7 00 06 00 00
	00		 mov	 DWORD PTR [rax], 6
$LN370@inflate:

; 702  :         case NAME:
; 703  :             if (state->flags & 0x0800) {

  00adb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ae3	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00ae6	25 00 08 00 00	 and	 eax, 2048		; 00000800H
  00aeb	85 c0		 test	 eax, eax
  00aed	0f 84 29 01 00
	00		 je	 $LN369@inflate

; 704  :                 if (have == 0) goto inf_leave;

  00af3	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00af8	75 05		 jne	 SHORT $LN368@inflate
  00afa	e9 f9 1f 00 00	 jmp	 $inf_leave$78250
$LN368@inflate:

; 705  :                 copy = 0;

  00aff	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN367@inflate:

; 706  :                 do {
; 707  :                     len = (unsigned)(next[copy++]);

  00b07	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00b0b	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00b10	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00b14	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
  00b18	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  00b1c	83 c0 01	 add	 eax, 1
  00b1f	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 708  :                     if (state->head != Z_NULL &&
; 709  :                             state->head->name != Z_NULL &&
; 710  :                             state->length < state->head->name_max)

  00b23	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b2b	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00b30	74 6b		 je	 SHORT $LN364@inflate
  00b32	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b3a	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b3e	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00b43	74 58		 je	 SHORT $LN364@inflate
  00b45	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b4d	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00b51	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b59	8b 40 28	 mov	 eax, DWORD PTR [rax+40]
  00b5c	39 41 48	 cmp	 DWORD PTR [rcx+72], eax
  00b5f	73 3c		 jae	 SHORT $LN364@inflate

; 711  :                         state->head->name[state->length++] = len;

  00b61	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00b69	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00b6d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b75	8b 50 48	 mov	 edx, DWORD PTR [rax+72]
  00b78	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00b7c	0f b6 44 24 44	 movzx	 eax, BYTE PTR len$[rsp]
  00b81	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00b84	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b8c	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00b8f	83 c1 01	 add	 ecx, 1
  00b92	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00b9a	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN364@inflate:

; 712  :                 } while (len && copy < have);

  00b9d	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  00ba2	74 0e		 je	 SHORT $LN363@inflate
  00ba4	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00ba8	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  00bac	0f 82 55 ff ff
	ff		 jb	 $LN367@inflate
$LN363@inflate:

; 713  :                 if (state->flags & 0x0200)

  00bb2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bba	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00bbd	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00bc2	85 c0		 test	 eax, eax
  00bc4	74 29		 je	 SHORT $LN362@inflate

; 714  :                     state->check = crc32(state->check, next, copy);

  00bc6	44 8b 44 24 68	 mov	 r8d, DWORD PTR copy$[rsp]
  00bcb	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  00bd0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00bd8	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00bdb	e8 00 00 00 00	 call	 crc32
  00be0	44 8b d8	 mov	 r11d, eax
  00be3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00beb	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN362@inflate:

; 715  :                 have -= copy;

  00bef	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00bf3	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00bf7	2b c1		 sub	 eax, ecx
  00bf9	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax

; 716  :                 next += copy;

  00bfd	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00c01	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00c06	48 03 c1	 add	 rax, rcx
  00c09	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 717  :                 if (len) goto inf_leave;

  00c0e	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  00c13	74 05		 je	 SHORT $LN361@inflate
  00c15	e9 de 1e 00 00	 jmp	 $inf_leave$78250
$LN361@inflate:

; 718  :             }
; 719  :             else if (state->head != Z_NULL)

  00c1a	eb 23		 jmp	 SHORT $LN360@inflate
$LN369@inflate:
  00c1c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c24	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00c29	74 14		 je	 SHORT $LN359@inflate

; 720  :                 state->head->name = Z_NULL;

  00c2b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c33	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00c37	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0
$LN359@inflate:
$LN360@inflate:

; 721  :             state->length = 0;

  00c3f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c47	c7 40 48 00 00
	00 00		 mov	 DWORD PTR [rax+72], 0

; 722  :             state->mode = COMMENT;

  00c4e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c56	c7 00 07 00 00
	00		 mov	 DWORD PTR [rax], 7
$LN358@inflate:

; 723  :         case COMMENT:
; 724  :             if (state->flags & 0x1000) {

  00c5c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00c64	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00c67	25 00 10 00 00	 and	 eax, 4096		; 00001000H
  00c6c	85 c0		 test	 eax, eax
  00c6e	0f 84 29 01 00
	00		 je	 $LN357@inflate

; 725  :                 if (have == 0) goto inf_leave;

  00c74	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00c79	75 05		 jne	 SHORT $LN356@inflate
  00c7b	e9 78 1e 00 00	 jmp	 $inf_leave$78250
$LN356@inflate:

; 726  :                 copy = 0;

  00c80	c7 44 24 68 00
	00 00 00	 mov	 DWORD PTR copy$[rsp], 0
$LN355@inflate:

; 727  :                 do {
; 728  :                     len = (unsigned)(next[copy++]);

  00c88	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00c8c	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00c91	0f b6 04 08	 movzx	 eax, BYTE PTR [rax+rcx]
  00c95	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax
  00c99	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  00c9d	83 c0 01	 add	 eax, 1
  00ca0	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 729  :                     if (state->head != Z_NULL &&
; 730  :                             state->head->comment != Z_NULL &&
; 731  :                             state->length < state->head->comm_max)

  00ca4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cac	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00cb1	74 6b		 je	 SHORT $LN352@inflate
  00cb3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cbb	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cbf	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  00cc4	74 58		 je	 SHORT $LN352@inflate
  00cc6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cce	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00cd2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00cda	8b 40 38	 mov	 eax, DWORD PTR [rax+56]
  00cdd	39 41 48	 cmp	 DWORD PTR [rcx+72], eax
  00ce0	73 3c		 jae	 SHORT $LN352@inflate

; 732  :                         state->head->comment[state->length++] = len;

  00ce2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  00cea	48 8b 49 20	 mov	 rcx, QWORD PTR [rcx+32]
  00cee	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00cf6	8b 50 48	 mov	 edx, DWORD PTR [rax+72]
  00cf9	48 8b 49 30	 mov	 rcx, QWORD PTR [rcx+48]
  00cfd	0f b6 44 24 44	 movzx	 eax, BYTE PTR len$[rsp]
  00d02	88 04 0a	 mov	 BYTE PTR [rdx+rcx], al
  00d05	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d0d	8b 48 48	 mov	 ecx, DWORD PTR [rax+72]
  00d10	83 c1 01	 add	 ecx, 1
  00d13	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d1b	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN352@inflate:

; 733  :                 } while (len && copy < have);

  00d1e	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  00d23	74 0e		 je	 SHORT $LN351@inflate
  00d25	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00d29	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  00d2d	0f 82 55 ff ff
	ff		 jb	 $LN355@inflate
$LN351@inflate:

; 734  :                 if (state->flags & 0x0200)

  00d33	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d3b	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00d3e	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00d43	85 c0		 test	 eax, eax
  00d45	74 29		 je	 SHORT $LN350@inflate

; 735  :                     state->check = crc32(state->check, next, copy);

  00d47	44 8b 44 24 68	 mov	 r8d, DWORD PTR copy$[rsp]
  00d4c	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  00d51	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d59	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  00d5c	e8 00 00 00 00	 call	 crc32
  00d61	44 8b d8	 mov	 r11d, eax
  00d64	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00d6c	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
$LN350@inflate:

; 736  :                 have -= copy;

  00d70	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00d74	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00d78	2b c1		 sub	 eax, ecx
  00d7a	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax

; 737  :                 next += copy;

  00d7e	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  00d82	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00d87	48 03 c1	 add	 rax, rcx
  00d8a	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 738  :                 if (len) goto inf_leave;

  00d8f	83 7c 24 44 00	 cmp	 DWORD PTR len$[rsp], 0
  00d94	74 05		 je	 SHORT $LN349@inflate
  00d96	e9 5d 1d 00 00	 jmp	 $inf_leave$78250
$LN349@inflate:

; 739  :             }
; 740  :             else if (state->head != Z_NULL)

  00d9b	eb 23		 jmp	 SHORT $LN348@inflate
$LN357@inflate:
  00d9d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00da5	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00daa	74 14		 je	 SHORT $LN347@inflate

; 741  :                 state->head->comment = Z_NULL;

  00dac	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00db4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00db8	48 c7 40 30 00
	00 00 00	 mov	 QWORD PTR [rax+48], 0
$LN347@inflate:
$LN348@inflate:

; 742  :             state->mode = HCRC;

  00dc0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00dc8	c7 00 08 00 00
	00		 mov	 DWORD PTR [rax], 8
$LN346@inflate:

; 743  :         case HCRC:
; 744  :             if (state->flags & 0x0200) {

  00dce	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00dd6	8b 40 10	 mov	 eax, DWORD PTR [rax+16]
  00dd9	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00dde	85 c0		 test	 eax, eax
  00de0	0f 84 b6 00 00
	00		 je	 $LN345@inflate
$LN344@inflate:
$LN341@inflate:

; 745  :                 NEEDBITS(16);

  00de6	83 7c 24 48 10	 cmp	 DWORD PTR bits$[rsp], 16
  00deb	73 57		 jae	 SHORT $LN340@inflate
$LN339@inflate:
  00ded	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00df2	75 05		 jne	 SHORT $LN336@inflate
  00df4	e9 ff 1c 00 00	 jmp	 $inf_leave$78250
$LN336@inflate:
  00df9	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00dfd	83 e8 01	 sub	 eax, 1
  00e00	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00e04	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00e09	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00e0c	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e10	0f b6 c8	 movzx	 ecx, al
  00e13	8b c2		 mov	 eax, edx
  00e15	d3 e0		 shl	 eax, cl
  00e17	8b c8		 mov	 ecx, eax
  00e19	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00e1d	03 c1		 add	 eax, ecx
  00e1f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00e23	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00e28	48 83 c0 01	 add	 rax, 1
  00e2c	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00e31	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00e35	83 c0 08	 add	 eax, 8
  00e38	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00e3c	33 c0		 xor	 eax, eax
  00e3e	85 c0		 test	 eax, eax
  00e40	75 ab		 jne	 SHORT $LN339@inflate
  00e42	eb a2		 jmp	 SHORT $LN341@inflate
$LN340@inflate:
  00e44	33 c0		 xor	 eax, eax
  00e46	85 c0		 test	 eax, eax
  00e48	75 9c		 jne	 SHORT $LN344@inflate

; 746  :                 if (hold != (state->check & 0xffff)) {

  00e4a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e52	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00e55	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00e5a	39 44 24 5c	 cmp	 DWORD PTR hold$[rsp], eax
  00e5e	74 26		 je	 SHORT $LN335@inflate

; 747  :                     strm->msg = (char *)"header crc mismatch";

  00e60	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00e68	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
  00e6f	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 748  :                     state->mode = BAD;

  00e73	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00e7b	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 749  :                     break;

  00e81	e9 6d 1c 00 00	 jmp	 $LN484@inflate
$LN335@inflate:
$LN334@inflate:

; 750  :                 }
; 751  :                 INITBITS();

  00e86	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00e8e	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00e96	33 c0		 xor	 eax, eax
  00e98	85 c0		 test	 eax, eax
  00e9a	75 ea		 jne	 SHORT $LN334@inflate
$LN345@inflate:

; 752  :             }
; 753  :             if (state->head != Z_NULL) {

  00e9c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ea4	48 83 78 20 00	 cmp	 QWORD PTR [rax+32], 0
  00ea9	74 33		 je	 SHORT $LN331@inflate

; 754  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  00eab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00eb3	8b 48 10	 mov	 ecx, DWORD PTR [rax+16]
  00eb6	c1 f9 09	 sar	 ecx, 9
  00eb9	83 e1 01	 and	 ecx, 1
  00ebc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ec4	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00ec8	89 48 3c	 mov	 DWORD PTR [rax+60], ecx

; 755  :                 state->head->done = 1;

  00ecb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ed3	48 8b 40 20	 mov	 rax, QWORD PTR [rax+32]
  00ed7	c7 40 40 01 00
	00 00		 mov	 DWORD PTR [rax+64], 1
$LN331@inflate:

; 756  :             }
; 757  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  00ede	45 33 c0	 xor	 r8d, r8d
  00ee1	33 d2		 xor	 edx, edx
  00ee3	33 c9		 xor	 ecx, ecx
  00ee5	e8 00 00 00 00	 call	 crc32
  00eea	44 8b d8	 mov	 r11d, eax
  00eed	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ef5	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  00ef9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00f01	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00f09	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00f0c	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 758  :             state->mode = TYPE;

  00f0f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00f17	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 759  :             break;

  00f1d	e9 d1 1b 00 00	 jmp	 $LN484@inflate
$LN330@inflate:
$LN329@inflate:
$LN326@inflate:

; 760  : #endif
; 761  :         case DICTID:
; 762  :             NEEDBITS(32);

  00f22	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  00f27	73 57		 jae	 SHORT $LN325@inflate
$LN324@inflate:
  00f29	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  00f2e	75 05		 jne	 SHORT $LN321@inflate
  00f30	e9 c3 1b 00 00	 jmp	 $inf_leave$78250
$LN321@inflate:
  00f35	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  00f39	83 e8 01	 sub	 eax, 1
  00f3c	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  00f40	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00f45	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  00f48	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00f4c	0f b6 c8	 movzx	 ecx, al
  00f4f	8b c2		 mov	 eax, edx
  00f51	d3 e0		 shl	 eax, cl
  00f53	8b c8		 mov	 ecx, eax
  00f55	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00f59	03 c1		 add	 eax, ecx
  00f5b	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  00f5f	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  00f64	48 83 c0 01	 add	 rax, 1
  00f68	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  00f6d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  00f71	83 c0 08	 add	 eax, 8
  00f74	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  00f78	33 c0		 xor	 eax, eax
  00f7a	85 c0		 test	 eax, eax
  00f7c	75 ab		 jne	 SHORT $LN324@inflate
  00f7e	eb a2		 jmp	 SHORT $LN326@inflate
$LN325@inflate:
  00f80	33 c0		 xor	 eax, eax
  00f82	85 c0		 test	 eax, eax
  00f84	75 9c		 jne	 SHORT $LN329@inflate

; 763  :             strm->adler = state->check = REVERSE(hold);

  00f86	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  00f8a	c1 e9 18	 shr	 ecx, 24
  00f8d	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00f93	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00f97	c1 e8 08	 shr	 eax, 8
  00f9a	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00f9f	03 c8		 add	 ecx, eax
  00fa1	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00fa5	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00faa	c1 e0 08	 shl	 eax, 8
  00fad	03 c8		 add	 ecx, eax
  00faf	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  00fb3	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  00fb8	c1 e0 18	 shl	 eax, 24
  00fbb	03 c8		 add	 ecx, eax
  00fbd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00fc5	89 48 18	 mov	 DWORD PTR [rax+24], ecx
  00fc8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  00fd0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00fd8	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  00fdb	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN320@inflate:

; 764  :             INITBITS();

  00fde	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  00fe6	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  00fee	33 c0		 xor	 eax, eax
  00ff0	85 c0		 test	 eax, eax
  00ff2	75 ea		 jne	 SHORT $LN320@inflate

; 765  :             state->mode = DICT;

  00ff4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  00ffc	c7 00 0a 00 00
	00		 mov	 DWORD PTR [rax], 10
$LN317@inflate:

; 766  :         case DICT:
; 767  :             if (state->havedict == 0) {

  01002	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0100a	83 78 0c 00	 cmp	 DWORD PTR [rax+12], 0
  0100e	75 6d		 jne	 SHORT $LN316@inflate
$LN315@inflate:

; 768  :                 RESTORE();

  01010	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01018	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  0101d	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  01021	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01029	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0102d	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  01030	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01038	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0103d	48 89 01	 mov	 QWORD PTR [rcx], rax
  01040	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01048	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0104c	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  0104f	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01057	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0105b	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  0105e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01066	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0106a	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  0106d	33 c0		 xor	 eax, eax
  0106f	85 c0		 test	 eax, eax
  01071	75 9d		 jne	 SHORT $LN315@inflate

; 769  :                 return Z_NEED_DICT;

  01073	b8 02 00 00 00	 mov	 eax, 2
  01078	e9 f8 1c 00 00	 jmp	 $LN494@inflate
$LN316@inflate:

; 770  :             }
; 771  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  0107d	45 33 c0	 xor	 r8d, r8d
  01080	33 d2		 xor	 edx, edx
  01082	33 c9		 xor	 ecx, ecx
  01084	e8 00 00 00 00	 call	 adler32
  01089	44 8b d8	 mov	 r11d, eax
  0108c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01094	44 89 58 18	 mov	 DWORD PTR [rax+24], r11d
  01098	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  010a0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010a8	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  010ab	89 41 4c	 mov	 DWORD PTR [rcx+76], eax

; 772  :             state->mode = TYPE;

  010ae	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010b6	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11
$LN312@inflate:

; 773  :         case TYPE:
; 774  :             if (flush == Z_BLOCK) goto inf_leave;

  010bc	83 bc 24 c8 00
	00 00 05	 cmp	 DWORD PTR flush$[rsp], 5
  010c4	75 05		 jne	 SHORT $LN311@inflate
  010c6	e9 2d 1a 00 00	 jmp	 $inf_leave$78250
$LN311@inflate:
$LN310@inflate:

; 775  :         case TYPEDO:
; 776  :             if (state->last) {

  010cb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  010d3	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  010d7	74 3e		 je	 SHORT $LN309@inflate
$LN308@inflate:

; 777  :                 BYTEBITS();

  010d9	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  010dd	83 e0 07	 and	 eax, 7
  010e0	0f b6 c8	 movzx	 ecx, al
  010e3	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  010e7	d3 e8		 shr	 eax, cl
  010e9	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  010ed	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  010f1	83 e1 07	 and	 ecx, 7
  010f4	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  010f8	2b c1		 sub	 eax, ecx
  010fa	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  010fe	33 c0		 xor	 eax, eax
  01100	85 c0		 test	 eax, eax
  01102	75 d5		 jne	 SHORT $LN308@inflate

; 778  :                 state->mode = CHECK;

  01104	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0110c	c7 00 18 00 00
	00		 mov	 DWORD PTR [rax], 24

; 779  :                 break;

  01112	e9 dc 19 00 00	 jmp	 $LN484@inflate
$LN309@inflate:
$LN305@inflate:
$LN302@inflate:

; 780  :             }
; 781  :             NEEDBITS(3);

  01117	83 7c 24 48 03	 cmp	 DWORD PTR bits$[rsp], 3
  0111c	73 57		 jae	 SHORT $LN301@inflate
$LN300@inflate:
  0111e	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01123	75 05		 jne	 SHORT $LN297@inflate
  01125	e9 ce 19 00 00	 jmp	 $inf_leave$78250
$LN297@inflate:
  0112a	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0112e	83 e8 01	 sub	 eax, 1
  01131	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01135	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0113a	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0113d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01141	0f b6 c8	 movzx	 ecx, al
  01144	8b c2		 mov	 eax, edx
  01146	d3 e0		 shl	 eax, cl
  01148	8b c8		 mov	 ecx, eax
  0114a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0114e	03 c1		 add	 eax, ecx
  01150	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01154	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01159	48 83 c0 01	 add	 rax, 1
  0115d	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01162	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01166	83 c0 08	 add	 eax, 8
  01169	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0116d	33 c0		 xor	 eax, eax
  0116f	85 c0		 test	 eax, eax
  01171	75 ab		 jne	 SHORT $LN300@inflate
  01173	eb a2		 jmp	 SHORT $LN302@inflate
$LN301@inflate:
  01175	33 c0		 xor	 eax, eax
  01177	85 c0		 test	 eax, eax
  01179	75 9c		 jne	 SHORT $LN305@inflate

; 782  :             state->last = BITS(1);

  0117b	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0117f	83 e1 01	 and	 ecx, 1
  01182	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0118a	89 48 04	 mov	 DWORD PTR [rax+4], ecx
$LN296@inflate:

; 783  :             DROPBITS(1);

  0118d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01191	d1 e8		 shr	 eax, 1
  01193	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01197	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0119b	83 e8 01	 sub	 eax, 1
  0119e	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  011a2	33 c0		 xor	 eax, eax
  011a4	85 c0		 test	 eax, eax
  011a6	75 e5		 jne	 SHORT $LN296@inflate

; 784  :             switch (BITS(2)) {

  011a8	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  011ac	83 e0 03	 and	 eax, 3
  011af	89 84 24 94 00
	00 00		 mov	 DWORD PTR tv561[rsp], eax
  011b6	83 bc 24 94 00
	00 00 00	 cmp	 DWORD PTR tv561[rsp], 0
  011be	74 20		 je	 SHORT $LN291@inflate
  011c0	83 bc 24 94 00
	00 00 01	 cmp	 DWORD PTR tv561[rsp], 1
  011c8	74 26		 je	 SHORT $LN290@inflate
  011ca	83 bc 24 94 00
	00 00 02	 cmp	 DWORD PTR tv561[rsp], 2
  011d2	74 3a		 je	 SHORT $LN289@inflate
  011d4	83 bc 24 94 00
	00 00 03	 cmp	 DWORD PTR tv561[rsp], 3
  011dc	74 40		 je	 SHORT $LN288@inflate
  011de	eb 5f		 jmp	 SHORT $LN292@inflate
$LN291@inflate:

; 785  :             case 0:                             /* stored block */
; 786  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 787  :                         state->last ? " (last)" : ""));
; 788  :                 state->mode = STORED;

  011e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  011e8	c7 00 0d 00 00
	00		 mov	 DWORD PTR [rax], 13

; 789  :                 break;

  011ee	eb 4f		 jmp	 SHORT $LN292@inflate
$LN290@inflate:

; 790  :             case 1:                             /* fixed block */
; 791  :                 fixedtables(state);

  011f0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  011f8	e8 00 00 00 00	 call	 fixedtables

; 792  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 793  :                         state->last ? " (last)" : ""));
; 794  :                 state->mode = LEN;              /* decode codes */

  011fd	4c 8b 9c 24 80
	00 00 00	 mov	 r11, QWORD PTR state$[rsp]
  01205	41 c7 03 12 00
	00 00		 mov	 DWORD PTR [r11], 18

; 795  :                 break;

  0120c	eb 31		 jmp	 SHORT $LN292@inflate
$LN289@inflate:

; 796  :             case 2:                             /* dynamic block */
; 797  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 798  :                         state->last ? " (last)" : ""));
; 799  :                 state->mode = TABLE;

  0120e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01216	c7 00 0f 00 00
	00		 mov	 DWORD PTR [rax], 15

; 800  :                 break;

  0121c	eb 21		 jmp	 SHORT $LN292@inflate
$LN288@inflate:

; 801  :             case 3:
; 802  :                 strm->msg = (char *)"invalid block type";

  0121e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01226	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
  0122d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 803  :                 state->mode = BAD;

  01231	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01239	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27
$LN292@inflate:
$LN287@inflate:

; 804  :             }
; 805  :             DROPBITS(2);

  0123f	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01243	c1 e8 02	 shr	 eax, 2
  01246	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0124a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0124e	83 e8 02	 sub	 eax, 2
  01251	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01255	33 c0		 xor	 eax, eax
  01257	85 c0		 test	 eax, eax
  01259	75 e4		 jne	 SHORT $LN287@inflate

; 806  :             break;

  0125b	e9 93 18 00 00	 jmp	 $LN484@inflate
$LN284@inflate:
$LN283@inflate:

; 807  :         case STORED:
; 808  :             BYTEBITS();                         /* go to byte boundary */

  01260	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01264	83 e0 07	 and	 eax, 7
  01267	0f b6 c8	 movzx	 ecx, al
  0126a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0126e	d3 e8		 shr	 eax, cl
  01270	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01274	8b 4c 24 48	 mov	 ecx, DWORD PTR bits$[rsp]
  01278	83 e1 07	 and	 ecx, 7
  0127b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0127f	2b c1		 sub	 eax, ecx
  01281	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01285	33 c0		 xor	 eax, eax
  01287	85 c0		 test	 eax, eax
  01289	75 d5		 jne	 SHORT $LN283@inflate
$LN280@inflate:
$LN277@inflate:

; 809  :             NEEDBITS(32);

  0128b	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  01290	73 57		 jae	 SHORT $LN276@inflate
$LN275@inflate:
  01292	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01297	75 05		 jne	 SHORT $LN272@inflate
  01299	e9 5a 18 00 00	 jmp	 $inf_leave$78250
$LN272@inflate:
  0129e	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  012a2	83 e8 01	 sub	 eax, 1
  012a5	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  012a9	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  012ae	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  012b1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  012b5	0f b6 c8	 movzx	 ecx, al
  012b8	8b c2		 mov	 eax, edx
  012ba	d3 e0		 shl	 eax, cl
  012bc	8b c8		 mov	 ecx, eax
  012be	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  012c2	03 c1		 add	 eax, ecx
  012c4	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  012c8	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  012cd	48 83 c0 01	 add	 rax, 1
  012d1	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  012d6	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  012da	83 c0 08	 add	 eax, 8
  012dd	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  012e1	33 c0		 xor	 eax, eax
  012e3	85 c0		 test	 eax, eax
  012e5	75 ab		 jne	 SHORT $LN275@inflate
  012e7	eb a2		 jmp	 SHORT $LN277@inflate
$LN276@inflate:
  012e9	33 c0		 xor	 eax, eax
  012eb	85 c0		 test	 eax, eax
  012ed	75 9c		 jne	 SHORT $LN280@inflate

; 810  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  012ef	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  012f3	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  012f9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  012fd	c1 e8 10	 shr	 eax, 16
  01300	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  01305	3b c8		 cmp	 ecx, eax
  01307	74 26		 je	 SHORT $LN271@inflate

; 811  :                 strm->msg = (char *)"invalid stored block lengths";

  01309	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01311	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
  01318	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 812  :                 state->mode = BAD;

  0131c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01324	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 813  :                 break;

  0132a	e9 c4 17 00 00	 jmp	 $LN484@inflate
$LN271@inflate:

; 814  :             }
; 815  :             state->length = (unsigned)hold & 0xffff;

  0132f	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01333	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  01339	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01341	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN270@inflate:

; 816  :             Tracev((stderr, "inflate:       stored length %u\n",
; 817  :                     state->length));
; 818  :             INITBITS();

  01344	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  0134c	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  01354	33 c0		 xor	 eax, eax
  01356	85 c0		 test	 eax, eax
  01358	75 ea		 jne	 SHORT $LN270@inflate

; 819  :             state->mode = COPY;

  0135a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01362	c7 00 0e 00 00
	00		 mov	 DWORD PTR [rax], 14
$LN267@inflate:

; 820  :         case COPY:
; 821  :             copy = state->length;

  01368	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01370	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  01373	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 822  :             if (copy) {

  01377	83 7c 24 68 00	 cmp	 DWORD PTR copy$[rsp], 0
  0137c	0f 84 a5 00 00
	00		 je	 $LN266@inflate

; 823  :                 if (copy > have) copy = have;

  01382	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01386	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  0138a	76 08		 jbe	 SHORT $LN265@inflate
  0138c	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01390	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN265@inflate:

; 824  :                 if (copy > left) copy = left;

  01394	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01398	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  0139c	76 08		 jbe	 SHORT $LN264@inflate
  0139e	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  013a2	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN264@inflate:

; 825  :                 if (copy == 0) goto inf_leave;

  013a6	83 7c 24 68 00	 cmp	 DWORD PTR copy$[rsp], 0
  013ab	75 05		 jne	 SHORT $LN263@inflate
  013ad	e9 46 17 00 00	 jmp	 $inf_leave$78250
$LN263@inflate:

; 826  :                 zmemcpy(put, next, copy);

  013b2	44 8b 44 24 68	 mov	 r8d, DWORD PTR copy$[rsp]
  013b7	48 8b 54 24 50	 mov	 rdx, QWORD PTR next$[rsp]
  013bc	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  013c1	e8 00 00 00 00	 call	 memcpy

; 827  :                 have -= copy;

  013c6	44 8b 5c 24 68	 mov	 r11d, DWORD PTR copy$[rsp]
  013cb	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  013cf	41 2b c3	 sub	 eax, r11d
  013d2	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax

; 828  :                 next += copy;

  013d6	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  013da	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  013df	48 03 c1	 add	 rax, rcx
  013e2	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax

; 829  :                 left -= copy;

  013e7	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  013eb	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  013ef	2b c1		 sub	 eax, ecx
  013f1	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 830  :                 put += copy;

  013f5	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  013f9	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  013fe	48 03 c1	 add	 rax, rcx
  01401	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 831  :                 state->length -= copy;

  01406	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0140e	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  01412	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  01415	2b c8		 sub	 ecx, eax
  01417	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0141f	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 832  :                 break;

  01422	e9 cc 16 00 00	 jmp	 $LN484@inflate
$LN266@inflate:

; 833  :             }
; 834  :             Tracev((stderr, "inflate:       stored end\n"));
; 835  :             state->mode = TYPE;

  01427	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0142f	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 836  :             break;

  01435	e9 b9 16 00 00	 jmp	 $LN484@inflate
$LN262@inflate:
$LN261@inflate:
$LN258@inflate:

; 837  :         case TABLE:
; 838  :             NEEDBITS(14);

  0143a	83 7c 24 48 0e	 cmp	 DWORD PTR bits$[rsp], 14
  0143f	73 57		 jae	 SHORT $LN257@inflate
$LN256@inflate:
  01441	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01446	75 05		 jne	 SHORT $LN253@inflate
  01448	e9 ab 16 00 00	 jmp	 $inf_leave$78250
$LN253@inflate:
  0144d	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01451	83 e8 01	 sub	 eax, 1
  01454	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01458	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0145d	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01460	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01464	0f b6 c8	 movzx	 ecx, al
  01467	8b c2		 mov	 eax, edx
  01469	d3 e0		 shl	 eax, cl
  0146b	8b c8		 mov	 ecx, eax
  0146d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01471	03 c1		 add	 eax, ecx
  01473	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01477	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  0147c	48 83 c0 01	 add	 rax, 1
  01480	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01485	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01489	83 c0 08	 add	 eax, 8
  0148c	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01490	33 c0		 xor	 eax, eax
  01492	85 c0		 test	 eax, eax
  01494	75 ab		 jne	 SHORT $LN256@inflate
  01496	eb a2		 jmp	 SHORT $LN258@inflate
$LN257@inflate:
  01498	33 c0		 xor	 eax, eax
  0149a	85 c0		 test	 eax, eax
  0149c	75 9c		 jne	 SHORT $LN261@inflate

; 839  :             state->nlen = BITS(5) + 257;

  0149e	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  014a2	83 e1 1f	 and	 ecx, 31
  014a5	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  014ab	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  014b3	89 48 74	 mov	 DWORD PTR [rax+116], ecx
$LN252@inflate:

; 840  :             DROPBITS(5);

  014b6	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  014ba	c1 e8 05	 shr	 eax, 5
  014bd	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  014c1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  014c5	83 e8 05	 sub	 eax, 5
  014c8	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  014cc	33 c0		 xor	 eax, eax
  014ce	85 c0		 test	 eax, eax
  014d0	75 e4		 jne	 SHORT $LN252@inflate

; 841  :             state->ndist = BITS(5) + 1;

  014d2	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  014d6	83 e1 1f	 and	 ecx, 31
  014d9	83 c1 01	 add	 ecx, 1
  014dc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  014e4	89 48 78	 mov	 DWORD PTR [rax+120], ecx
$LN249@inflate:

; 842  :             DROPBITS(5);

  014e7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  014eb	c1 e8 05	 shr	 eax, 5
  014ee	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  014f2	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  014f6	83 e8 05	 sub	 eax, 5
  014f9	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  014fd	33 c0		 xor	 eax, eax
  014ff	85 c0		 test	 eax, eax
  01501	75 e4		 jne	 SHORT $LN249@inflate

; 843  :             state->ncode = BITS(4) + 4;

  01503	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  01507	83 e1 0f	 and	 ecx, 15
  0150a	83 c1 04	 add	 ecx, 4
  0150d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01515	89 48 70	 mov	 DWORD PTR [rax+112], ecx
$LN246@inflate:

; 844  :             DROPBITS(4);

  01518	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0151c	c1 e8 04	 shr	 eax, 4
  0151f	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01523	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01527	83 e8 04	 sub	 eax, 4
  0152a	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0152e	33 c0		 xor	 eax, eax
  01530	85 c0		 test	 eax, eax
  01532	75 e4		 jne	 SHORT $LN246@inflate

; 845  : #ifndef PKZIP_BUG_WORKAROUND
; 846  :             if (state->nlen > 286 || state->ndist > 30) {

  01534	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0153c	81 78 74 1e 01
	00 00		 cmp	 DWORD PTR [rax+116], 286 ; 0000011eH
  01543	77 0e		 ja	 SHORT $LN242@inflate
  01545	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0154d	83 78 78 1e	 cmp	 DWORD PTR [rax+120], 30
  01551	76 26		 jbe	 SHORT $LN243@inflate
$LN242@inflate:

; 847  :                 strm->msg = (char *)"too many length or distance symbols";

  01553	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0155b	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
  01562	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 848  :                 state->mode = BAD;

  01566	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0156e	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 849  :                 break;

  01574	e9 7a 15 00 00	 jmp	 $LN484@inflate
$LN243@inflate:

; 850  :             }
; 851  : #endif
; 852  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 853  :             state->have = 0;

  01579	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01581	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 854  :             state->mode = LENLENS;

  01588	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01590	c7 00 10 00 00
	00		 mov	 DWORD PTR [rax], 16
$LN241@inflate:
$LN240@inflate:

; 855  :         case LENLENS:
; 856  :             while (state->have < state->ncode) {

  01596	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0159e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  015a6	8b 40 70	 mov	 eax, DWORD PTR [rax+112]
  015a9	39 41 7c	 cmp	 DWORD PTR [rcx+124], eax
  015ac	0f 83 cb 00 00
	00		 jae	 $LN239@inflate
$LN238@inflate:
$LN235@inflate:

; 857  :                 NEEDBITS(3);

  015b2	83 7c 24 48 03	 cmp	 DWORD PTR bits$[rsp], 3
  015b7	73 57		 jae	 SHORT $LN234@inflate
$LN233@inflate:
  015b9	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  015be	75 05		 jne	 SHORT $LN230@inflate
  015c0	e9 33 15 00 00	 jmp	 $inf_leave$78250
$LN230@inflate:
  015c5	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  015c9	83 e8 01	 sub	 eax, 1
  015cc	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  015d0	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  015d5	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  015d8	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  015dc	0f b6 c8	 movzx	 ecx, al
  015df	8b c2		 mov	 eax, edx
  015e1	d3 e0		 shl	 eax, cl
  015e3	8b c8		 mov	 ecx, eax
  015e5	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  015e9	03 c1		 add	 eax, ecx
  015eb	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  015ef	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  015f4	48 83 c0 01	 add	 rax, 1
  015f8	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  015fd	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01601	83 c0 08	 add	 eax, 8
  01604	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01608	33 c0		 xor	 eax, eax
  0160a	85 c0		 test	 eax, eax
  0160c	75 ab		 jne	 SHORT $LN233@inflate
  0160e	eb a2		 jmp	 SHORT $LN235@inflate
$LN234@inflate:
  01610	33 c0		 xor	 eax, eax
  01612	85 c0		 test	 eax, eax
  01614	75 9c		 jne	 SHORT $LN238@inflate

; 858  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  01616	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  0161a	83 e2 07	 and	 edx, 7
  0161d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01625	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  01628	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflate@@9@9
  0162f	0f b7 0c 48	 movzx	 ecx, WORD PTR [rax+rcx*2]
  01633	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0163b	66 89 94 48 88
	00 00 00	 mov	 WORD PTR [rax+rcx*2+136], dx
  01643	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0164b	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  0164e	83 c1 01	 add	 ecx, 1
  01651	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01659	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
$LN229@inflate:

; 859  :                 DROPBITS(3);

  0165c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01660	c1 e8 03	 shr	 eax, 3
  01663	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01667	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0166b	83 e8 03	 sub	 eax, 3
  0166e	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01672	33 c0		 xor	 eax, eax
  01674	85 c0		 test	 eax, eax
  01676	75 e4		 jne	 SHORT $LN229@inflate

; 860  :             }

  01678	e9 19 ff ff ff	 jmp	 $LN240@inflate
$LN239@inflate:
$LN226@inflate:

; 861  :             while (state->have < 19)

  0167d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01685	83 78 7c 13	 cmp	 DWORD PTR [rax+124], 19
  01689	73 43		 jae	 SHORT $LN225@inflate

; 862  :                 state->lens[order[state->have++]] = 0;

  0168b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01693	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  01696	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:?order@?1??inflate@@9@9
  0169d	0f b7 14 48	 movzx	 edx, WORD PTR [rax+rcx*2]
  016a1	33 c9		 xor	 ecx, ecx
  016a3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016ab	66 89 8c 50 88
	00 00 00	 mov	 WORD PTR [rax+rdx*2+136], cx
  016b3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016bb	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  016be	83 c1 01	 add	 ecx, 1
  016c1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016c9	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  016cc	eb af		 jmp	 SHORT $LN226@inflate
$LN225@inflate:

; 863  :             state->next = state->codes;

  016ce	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  016d6	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  016dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016e5	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 864  :             state->lencode = (code const FAR *)(state->next);

  016ec	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  016f4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  016fc	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01703	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 865  :             state->lenbits = 7;

  01707	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0170f	c7 40 68 07 00
	00 00		 mov	 DWORD PTR [rax+104], 7

; 866  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 867  :                                 &(state->lenbits), state->work);

  01716	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0171e	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  01725	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0172d	48 83 c0 68	 add	 rax, 104		; 00000068H
  01731	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  01739	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  01740	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01748	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  0174f	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01754	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01759	41 b8 13 00 00
	00		 mov	 r8d, 19
  0175f	33 c9		 xor	 ecx, ecx
  01761	e8 00 00 00 00	 call	 inflate_table
  01766	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 868  :             if (ret) {

  0176a	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  0176f	74 26		 je	 SHORT $LN224@inflate

; 869  :                 strm->msg = (char *)"invalid code lengths set";

  01771	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01779	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
  01780	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 870  :                 state->mode = BAD;

  01784	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0178c	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 871  :                 break;

  01792	e9 5c 13 00 00	 jmp	 $LN484@inflate
$LN224@inflate:

; 872  :             }
; 873  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 874  :             state->have = 0;

  01797	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0179f	c7 40 7c 00 00
	00 00		 mov	 DWORD PTR [rax+124], 0

; 875  :             state->mode = CODELENS;

  017a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017ae	c7 00 11 00 00
	00		 mov	 DWORD PTR [rax], 17
$LN223@inflate:
$LN222@inflate:

; 876  :         case CODELENS:
; 877  :             while (state->have < state->nlen + state->ndist) {

  017b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017bc	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  017bf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017c7	03 48 78	 add	 ecx, DWORD PTR [rax+120]
  017ca	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017d2	39 48 7c	 cmp	 DWORD PTR [rax+124], ecx
  017d5	0f 83 d5 04 00
	00		 jae	 $LN221@inflate
$LN220@inflate:

; 878  :                 for (;;) {
; 879  :                     this = state->lencode[BITS(state->lenbits)];

  017db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  017e3	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  017e6	b8 01 00 00 00	 mov	 eax, 1
  017eb	d3 e0		 shl	 eax, cl
  017ed	8b c8		 mov	 ecx, eax
  017ef	83 e9 01	 sub	 ecx, 1
  017f2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  017f6	23 c1		 and	 eax, ecx
  017f8	8b c8		 mov	 ecx, eax
  017fa	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01802	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01806	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01809	89 44 24 64	 mov	 DWORD PTR this$[rsp], eax

; 880  :                     if ((unsigned)(this.bits) <= bits) break;

  0180d	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01812	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01816	77 02		 ja	 SHORT $LN218@inflate
  01818	eb 5a		 jmp	 SHORT $LN219@inflate
$LN218@inflate:
$LN217@inflate:

; 881  :                     PULLBYTE();

  0181a	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0181f	75 05		 jne	 SHORT $LN214@inflate
  01821	e9 d2 12 00 00	 jmp	 $inf_leave$78250
$LN214@inflate:
  01826	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0182a	83 e8 01	 sub	 eax, 1
  0182d	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01831	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01836	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01839	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0183d	0f b6 c8	 movzx	 ecx, al
  01840	8b c2		 mov	 eax, edx
  01842	d3 e0		 shl	 eax, cl
  01844	8b c8		 mov	 ecx, eax
  01846	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0184a	03 c1		 add	 eax, ecx
  0184c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01850	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01855	48 83 c0 01	 add	 rax, 1
  01859	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  0185e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01862	83 c0 08	 add	 eax, 8
  01865	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01869	33 c0		 xor	 eax, eax
  0186b	85 c0		 test	 eax, eax
  0186d	75 ab		 jne	 SHORT $LN217@inflate

; 882  :                 }

  0186f	e9 67 ff ff ff	 jmp	 $LN220@inflate
$LN219@inflate:

; 883  :                 if (this.val < 16) {

  01874	0f b7 44 24 66	 movzx	 eax, WORD PTR this$[rsp+2]
  01879	83 f8 10	 cmp	 eax, 16
  0187c	0f 8d cd 00 00
	00		 jge	 $LN213@inflate
$LN212@inflate:
$LN209@inflate:

; 884  :                     NEEDBITS(this.bits);

  01882	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01887	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  0188b	73 57		 jae	 SHORT $LN208@inflate
$LN207@inflate:
  0188d	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01892	75 05		 jne	 SHORT $LN204@inflate
  01894	e9 5f 12 00 00	 jmp	 $inf_leave$78250
$LN204@inflate:
  01899	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0189d	83 e8 01	 sub	 eax, 1
  018a0	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  018a4	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  018a9	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  018ac	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  018b0	0f b6 c8	 movzx	 ecx, al
  018b3	8b c2		 mov	 eax, edx
  018b5	d3 e0		 shl	 eax, cl
  018b7	8b c8		 mov	 ecx, eax
  018b9	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  018bd	03 c1		 add	 eax, ecx
  018bf	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  018c3	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  018c8	48 83 c0 01	 add	 rax, 1
  018cc	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  018d1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  018d5	83 c0 08	 add	 eax, 8
  018d8	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  018dc	33 c0		 xor	 eax, eax
  018de	85 c0		 test	 eax, eax
  018e0	75 ab		 jne	 SHORT $LN207@inflate
  018e2	eb 9e		 jmp	 SHORT $LN209@inflate
$LN208@inflate:
  018e4	33 c0		 xor	 eax, eax
  018e6	85 c0		 test	 eax, eax
  018e8	75 98		 jne	 SHORT $LN212@inflate
$LN203@inflate:

; 885  :                     DROPBITS(this.bits);

  018ea	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  018ef	0f b6 c8	 movzx	 ecx, al
  018f2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  018f6	d3 e8		 shr	 eax, cl
  018f8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  018fc	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  01901	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01905	2b c1		 sub	 eax, ecx
  01907	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0190b	33 c0		 xor	 eax, eax
  0190d	85 c0		 test	 eax, eax
  0190f	75 d9		 jne	 SHORT $LN203@inflate

; 886  :                     state->lens[state->have++] = this.val;

  01911	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01919	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  0191c	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01924	0f b7 44 24 66	 movzx	 eax, WORD PTR this$[rsp+2]
  01929	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  01931	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01939	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  0193c	83 c1 01	 add	 ecx, 1
  0193f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01947	89 48 7c	 mov	 DWORD PTR [rax+124], ecx

; 887  :                 }
; 888  :                 else {

  0194a	e9 5c 03 00 00	 jmp	 $LN200@inflate
$LN213@inflate:

; 889  :                     if (this.val == 16) {

  0194f	0f b7 44 24 66	 movzx	 eax, WORD PTR this$[rsp+2]
  01954	83 f8 10	 cmp	 eax, 16
  01957	0f 85 19 01 00
	00		 jne	 $LN199@inflate
$LN198@inflate:
$LN195@inflate:

; 890  :                         NEEDBITS(this.bits + 2);

  0195d	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01962	83 c0 02	 add	 eax, 2
  01965	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  01969	73 57		 jae	 SHORT $LN194@inflate
$LN193@inflate:
  0196b	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01970	75 05		 jne	 SHORT $LN190@inflate
  01972	e9 81 11 00 00	 jmp	 $inf_leave$78250
$LN190@inflate:
  01977	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0197b	83 e8 01	 sub	 eax, 1
  0197e	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01982	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01987	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0198a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0198e	0f b6 c8	 movzx	 ecx, al
  01991	8b c2		 mov	 eax, edx
  01993	d3 e0		 shl	 eax, cl
  01995	8b c8		 mov	 ecx, eax
  01997	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0199b	03 c1		 add	 eax, ecx
  0199d	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  019a1	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  019a6	48 83 c0 01	 add	 rax, 1
  019aa	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  019af	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  019b3	83 c0 08	 add	 eax, 8
  019b6	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  019ba	33 c0		 xor	 eax, eax
  019bc	85 c0		 test	 eax, eax
  019be	75 ab		 jne	 SHORT $LN193@inflate
  019c0	eb 9b		 jmp	 SHORT $LN195@inflate
$LN194@inflate:
  019c2	33 c0		 xor	 eax, eax
  019c4	85 c0		 test	 eax, eax
  019c6	75 95		 jne	 SHORT $LN198@inflate
$LN189@inflate:

; 891  :                         DROPBITS(this.bits);

  019c8	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  019cd	0f b6 c8	 movzx	 ecx, al
  019d0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  019d4	d3 e8		 shr	 eax, cl
  019d6	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  019da	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  019df	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  019e3	2b c1		 sub	 eax, ecx
  019e5	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  019e9	33 c0		 xor	 eax, eax
  019eb	85 c0		 test	 eax, eax
  019ed	75 d9		 jne	 SHORT $LN189@inflate

; 892  :                         if (state->have == 0) {

  019ef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  019f7	83 78 7c 00	 cmp	 DWORD PTR [rax+124], 0
  019fb	75 26		 jne	 SHORT $LN186@inflate

; 893  :                             strm->msg = (char *)"invalid bit length repeat";

  019fd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01a05	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  01a0c	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 894  :                             state->mode = BAD;

  01a10	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a18	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 895  :                             break;

  01a1e	e9 8d 02 00 00	 jmp	 $LN221@inflate
$LN186@inflate:

; 896  :                         }
; 897  :                         len = state->lens[state->have - 1];

  01a23	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a2b	8b 40 7c	 mov	 eax, DWORD PTR [rax+124]
  01a2e	83 e8 01	 sub	 eax, 1
  01a31	8b c8		 mov	 ecx, eax
  01a33	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01a3b	0f b7 84 48 88
	00 00 00	 movzx	 eax, WORD PTR [rax+rcx*2+136]
  01a43	89 44 24 44	 mov	 DWORD PTR len$[rsp], eax

; 898  :                         copy = 3 + BITS(2);

  01a47	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01a4b	83 e0 03	 and	 eax, 3
  01a4e	83 c0 03	 add	 eax, 3
  01a51	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN185@inflate:

; 899  :                         DROPBITS(2);

  01a55	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01a59	c1 e8 02	 shr	 eax, 2
  01a5c	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01a60	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01a64	83 e8 02	 sub	 eax, 2
  01a67	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01a6b	33 c0		 xor	 eax, eax
  01a6d	85 c0		 test	 eax, eax
  01a6f	75 e4		 jne	 SHORT $LN185@inflate

; 900  :                     }
; 901  :                     else if (this.val == 17) {

  01a71	e9 9b 01 00 00	 jmp	 $LN182@inflate
$LN199@inflate:
  01a76	0f b7 44 24 66	 movzx	 eax, WORD PTR this$[rsp+2]
  01a7b	83 f8 11	 cmp	 eax, 17
  01a7e	0f 85 c9 00 00
	00		 jne	 $LN181@inflate
$LN180@inflate:
$LN177@inflate:

; 902  :                         NEEDBITS(this.bits + 3);

  01a84	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01a89	83 c0 03	 add	 eax, 3
  01a8c	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  01a90	73 57		 jae	 SHORT $LN176@inflate
$LN175@inflate:
  01a92	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01a97	75 05		 jne	 SHORT $LN172@inflate
  01a99	e9 5a 10 00 00	 jmp	 $inf_leave$78250
$LN172@inflate:
  01a9e	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01aa2	83 e8 01	 sub	 eax, 1
  01aa5	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01aa9	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01aae	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01ab1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01ab5	0f b6 c8	 movzx	 ecx, al
  01ab8	8b c2		 mov	 eax, edx
  01aba	d3 e0		 shl	 eax, cl
  01abc	8b c8		 mov	 ecx, eax
  01abe	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01ac2	03 c1		 add	 eax, ecx
  01ac4	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01ac8	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01acd	48 83 c0 01	 add	 rax, 1
  01ad1	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01ad6	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01ada	83 c0 08	 add	 eax, 8
  01add	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01ae1	33 c0		 xor	 eax, eax
  01ae3	85 c0		 test	 eax, eax
  01ae5	75 ab		 jne	 SHORT $LN175@inflate
  01ae7	eb 9b		 jmp	 SHORT $LN177@inflate
$LN176@inflate:
  01ae9	33 c0		 xor	 eax, eax
  01aeb	85 c0		 test	 eax, eax
  01aed	75 95		 jne	 SHORT $LN180@inflate
$LN171@inflate:

; 903  :                         DROPBITS(this.bits);

  01aef	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01af4	0f b6 c8	 movzx	 ecx, al
  01af7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01afb	d3 e8		 shr	 eax, cl
  01afd	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01b01	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  01b06	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01b0a	2b c1		 sub	 eax, ecx
  01b0c	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01b10	33 c0		 xor	 eax, eax
  01b12	85 c0		 test	 eax, eax
  01b14	75 d9		 jne	 SHORT $LN171@inflate

; 904  :                         len = 0;

  01b16	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 905  :                         copy = 3 + BITS(3);

  01b1e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01b22	83 e0 07	 and	 eax, 7
  01b25	83 c0 03	 add	 eax, 3
  01b28	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN168@inflate:

; 906  :                         DROPBITS(3);

  01b2c	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01b30	c1 e8 03	 shr	 eax, 3
  01b33	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01b37	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01b3b	83 e8 03	 sub	 eax, 3
  01b3e	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01b42	33 c0		 xor	 eax, eax
  01b44	85 c0		 test	 eax, eax
  01b46	75 e4		 jne	 SHORT $LN168@inflate

; 907  :                     }
; 908  :                     else {

  01b48	e9 c4 00 00 00	 jmp	 $LN165@inflate
$LN181@inflate:
$LN164@inflate:
$LN161@inflate:

; 909  :                         NEEDBITS(this.bits + 7);

  01b4d	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01b52	83 c0 07	 add	 eax, 7
  01b55	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  01b59	73 57		 jae	 SHORT $LN160@inflate
$LN159@inflate:
  01b5b	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01b60	75 05		 jne	 SHORT $LN156@inflate
  01b62	e9 91 0f 00 00	 jmp	 $inf_leave$78250
$LN156@inflate:
  01b67	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01b6b	83 e8 01	 sub	 eax, 1
  01b6e	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01b72	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01b77	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01b7a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01b7e	0f b6 c8	 movzx	 ecx, al
  01b81	8b c2		 mov	 eax, edx
  01b83	d3 e0		 shl	 eax, cl
  01b85	8b c8		 mov	 ecx, eax
  01b87	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01b8b	03 c1		 add	 eax, ecx
  01b8d	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01b91	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01b96	48 83 c0 01	 add	 rax, 1
  01b9a	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01b9f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01ba3	83 c0 08	 add	 eax, 8
  01ba6	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01baa	33 c0		 xor	 eax, eax
  01bac	85 c0		 test	 eax, eax
  01bae	75 ab		 jne	 SHORT $LN159@inflate
  01bb0	eb 9b		 jmp	 SHORT $LN161@inflate
$LN160@inflate:
  01bb2	33 c0		 xor	 eax, eax
  01bb4	85 c0		 test	 eax, eax
  01bb6	75 95		 jne	 SHORT $LN164@inflate
$LN155@inflate:

; 910  :                         DROPBITS(this.bits);

  01bb8	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01bbd	0f b6 c8	 movzx	 ecx, al
  01bc0	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01bc4	d3 e8		 shr	 eax, cl
  01bc6	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01bca	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  01bcf	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01bd3	2b c1		 sub	 eax, ecx
  01bd5	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01bd9	33 c0		 xor	 eax, eax
  01bdb	85 c0		 test	 eax, eax
  01bdd	75 d9		 jne	 SHORT $LN155@inflate

; 911  :                         len = 0;

  01bdf	c7 44 24 44 00
	00 00 00	 mov	 DWORD PTR len$[rsp], 0

; 912  :                         copy = 11 + BITS(7);

  01be7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01beb	83 e0 7f	 and	 eax, 127		; 0000007fH
  01bee	83 c0 0b	 add	 eax, 11
  01bf1	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN152@inflate:

; 913  :                         DROPBITS(7);

  01bf5	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01bf9	c1 e8 07	 shr	 eax, 7
  01bfc	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01c00	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01c04	83 e8 07	 sub	 eax, 7
  01c07	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01c0b	33 c0		 xor	 eax, eax
  01c0d	85 c0		 test	 eax, eax
  01c0f	75 e4		 jne	 SHORT $LN152@inflate
$LN165@inflate:
$LN182@inflate:

; 914  :                     }
; 915  :                     if (state->have + copy > state->nlen + state->ndist) {

  01c11	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c19	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  01c1c	03 54 24 68	 add	 edx, DWORD PTR copy$[rsp]
  01c20	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c28	8b 40 74	 mov	 eax, DWORD PTR [rax+116]
  01c2b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01c33	03 41 78	 add	 eax, DWORD PTR [rcx+120]
  01c36	3b d0		 cmp	 edx, eax
  01c38	76 23		 jbe	 SHORT $LN149@inflate

; 916  :                         strm->msg = (char *)"invalid bit length repeat";

  01c3a	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01c42	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
  01c49	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 917  :                         state->mode = BAD;

  01c4d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c55	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 918  :                         break;

  01c5b	eb 53		 jmp	 SHORT $LN221@inflate
$LN149@inflate:
$LN148@inflate:

; 919  :                     }
; 920  :                     while (copy--)

  01c5d	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  01c61	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  01c65	83 e8 01	 sub	 eax, 1
  01c68	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
  01c6c	85 c9		 test	 ecx, ecx
  01c6e	74 3b		 je	 SHORT $LN147@inflate

; 921  :                         state->lens[state->have++] = (unsigned short)len;

  01c70	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c78	8b 50 7c	 mov	 edx, DWORD PTR [rax+124]
  01c7b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01c83	0f b7 44 24 44	 movzx	 eax, WORD PTR len$[rsp]
  01c88	66 89 84 51 88
	00 00 00	 mov	 WORD PTR [rcx+rdx*2+136], ax
  01c90	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01c98	8b 48 7c	 mov	 ecx, DWORD PTR [rax+124]
  01c9b	83 c1 01	 add	 ecx, 1
  01c9e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01ca6	89 48 7c	 mov	 DWORD PTR [rax+124], ecx
  01ca9	eb b2		 jmp	 SHORT $LN148@inflate
$LN147@inflate:
$LN200@inflate:

; 922  :                 }
; 923  :             }

  01cab	e9 04 fb ff ff	 jmp	 $LN222@inflate
$LN221@inflate:

; 924  : 
; 925  :             /* handle error breaks in while */
; 926  :             if (state->mode == BAD) break;

  01cb0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01cb8	83 38 1b	 cmp	 DWORD PTR [rax], 27
  01cbb	75 05		 jne	 SHORT $LN146@inflate
  01cbd	e9 31 0e 00 00	 jmp	 $LN484@inflate
$LN146@inflate:

; 927  : 
; 928  :             /* build code tables */
; 929  :             state->next = state->codes;

  01cc2	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01cca	48 81 c1 48 05
	00 00		 add	 rcx, 1352		; 00000548H
  01cd1	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01cd9	48 89 88 80 00
	00 00		 mov	 QWORD PTR [rax+128], rcx

; 930  :             state->lencode = (code const FAR *)(state->next);

  01ce0	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01ce8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01cf0	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01cf7	48 89 41 58	 mov	 QWORD PTR [rcx+88], rax

; 931  :             state->lenbits = 9;

  01cfb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d03	c7 40 68 09 00
	00 00		 mov	 DWORD PTR [rax+104], 9

; 932  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 933  :                                 &(state->lenbits), state->work);

  01d0a	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01d12	48 81 c1 08 03
	00 00		 add	 rcx, 776		; 00000308H
  01d19	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d21	48 83 c0 68	 add	 rax, 104		; 00000068H
  01d25	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  01d2d	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  01d34	48 8b 94 24 80
	00 00 00	 mov	 rdx, QWORD PTR state$[rsp]
  01d3c	48 81 c2 88 00
	00 00		 add	 rdx, 136		; 00000088H
  01d43	48 89 4c 24 28	 mov	 QWORD PTR [rsp+40], rcx
  01d48	48 89 44 24 20	 mov	 QWORD PTR [rsp+32], rax
  01d4d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d55	44 8b 40 74	 mov	 r8d, DWORD PTR [rax+116]
  01d59	b9 01 00 00 00	 mov	 ecx, 1
  01d5e	e8 00 00 00 00	 call	 inflate_table
  01d63	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 934  :             if (ret) {

  01d67	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  01d6c	74 26		 je	 SHORT $LN145@inflate

; 935  :                 strm->msg = (char *)"invalid literal/lengths set";

  01d6e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01d76	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
  01d7d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 936  :                 state->mode = BAD;

  01d81	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01d89	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 937  :                 break;

  01d8f	e9 5f 0d 00 00	 jmp	 $LN484@inflate
$LN145@inflate:

; 938  :             }
; 939  :             state->distcode = (code const FAR *)(state->next);

  01d94	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01d9c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01da4	48 8b 80 80 00
	00 00		 mov	 rax, QWORD PTR [rax+128]
  01dab	48 89 41 60	 mov	 QWORD PTR [rcx+96], rax

; 940  :             state->distbits = 6;

  01daf	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01db7	c7 40 6c 06 00
	00 00		 mov	 DWORD PTR [rax+108], 6

; 941  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 942  :                             &(state->next), &(state->distbits), state->work);

  01dbe	4c 8b 94 24 80
	00 00 00	 mov	 r10, QWORD PTR state$[rsp]
  01dc6	49 81 c2 08 03
	00 00		 add	 r10, 776		; 00000308H
  01dcd	4c 8b 84 24 80
	00 00 00	 mov	 r8, QWORD PTR state$[rsp]
  01dd5	49 83 c0 6c	 add	 r8, 108			; 0000006cH
  01dd9	4c 8b 8c 24 80
	00 00 00	 mov	 r9, QWORD PTR state$[rsp]
  01de1	49 81 c1 80 00
	00 00		 add	 r9, 128			; 00000080H
  01de8	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01df0	8b 48 74	 mov	 ecx, DWORD PTR [rax+116]
  01df3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01dfb	48 8d 94 48 88
	00 00 00	 lea	 rdx, QWORD PTR [rax+rcx*2+136]
  01e03	4c 89 54 24 28	 mov	 QWORD PTR [rsp+40], r10
  01e08	4c 89 44 24 20	 mov	 QWORD PTR [rsp+32], r8
  01e0d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e15	44 8b 40 78	 mov	 r8d, DWORD PTR [rax+120]
  01e19	b9 02 00 00 00	 mov	 ecx, 2
  01e1e	e8 00 00 00 00	 call	 inflate_table
  01e23	89 44 24 58	 mov	 DWORD PTR ret$[rsp], eax

; 943  :             if (ret) {

  01e27	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  01e2c	74 26		 je	 SHORT $LN144@inflate

; 944  :                 strm->msg = (char *)"invalid distances set";

  01e2e	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01e36	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
  01e3d	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 945  :                 state->mode = BAD;

  01e41	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e49	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 946  :                 break;

  01e4f	e9 9f 0c 00 00	 jmp	 $LN484@inflate
$LN144@inflate:

; 947  :             }
; 948  :             Tracev((stderr, "inflate:       codes ok\n"));
; 949  :             state->mode = LEN;

  01e54	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01e5c	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18
$LN143@inflate:

; 950  :         case LEN:
; 951  :             if (have >= 6 && left >= 258) {

  01e62	83 7c 24 3c 06	 cmp	 DWORD PTR have$[rsp], 6
  01e67	0f 82 ea 00 00
	00		 jb	 $LN142@inflate
  01e6d	81 7c 24 4c 02
	01 00 00	 cmp	 DWORD PTR left$[rsp], 258 ; 00000102H
  01e75	0f 82 dc 00 00
	00		 jb	 $LN142@inflate
$LN141@inflate:

; 952  :                 RESTORE();

  01e7b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01e83	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  01e88	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  01e8c	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01e94	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  01e98	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  01e9b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01ea3	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01ea8	48 89 01	 mov	 QWORD PTR [rcx], rax
  01eab	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01eb3	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01eb7	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  01eba	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01ec2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01ec6	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  01ec9	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  01ed1	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01ed5	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  01ed8	33 c0		 xor	 eax, eax
  01eda	85 c0		 test	 eax, eax
  01edc	75 9d		 jne	 SHORT $LN141@inflate

; 953  :                 inflate_fast(strm, out);

  01ede	8b 54 24 78	 mov	 edx, DWORD PTR out$[rsp]
  01ee2	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  01eea	e8 00 00 00 00	 call	 inflate_fast
$LN138@inflate:

; 954  :                 LOAD();

  01eef	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01ef7	48 8b 40 10	 mov	 rax, QWORD PTR [rax+16]
  01efb	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  01f00	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f08	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  01f0b	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax
  01f0f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f17	48 8b 00	 mov	 rax, QWORD PTR [rax]
  01f1a	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01f1f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  01f27	8b 40 08	 mov	 eax, DWORD PTR [rax+8]
  01f2a	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01f2e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f36	8b 40 40	 mov	 eax, DWORD PTR [rax+64]
  01f39	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01f3d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f45	8b 40 44	 mov	 eax, DWORD PTR [rax+68]
  01f48	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01f4c	33 c0		 xor	 eax, eax
  01f4e	85 c0		 test	 eax, eax
  01f50	75 9d		 jne	 SHORT $LN138@inflate

; 955  :                 break;

  01f52	e9 9c 0b 00 00	 jmp	 $LN484@inflate
$LN142@inflate:
$LN135@inflate:

; 956  :             }
; 957  :             for (;;) {
; 958  :                 this = state->lencode[BITS(state->lenbits)];

  01f57	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f5f	8b 48 68	 mov	 ecx, DWORD PTR [rax+104]
  01f62	b8 01 00 00 00	 mov	 eax, 1
  01f67	d3 e0		 shl	 eax, cl
  01f69	8b c8		 mov	 ecx, eax
  01f6b	83 e9 01	 sub	 ecx, 1
  01f6e	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01f72	23 c1		 and	 eax, ecx
  01f74	8b c8		 mov	 ecx, eax
  01f76	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  01f7e	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  01f82	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  01f85	89 44 24 64	 mov	 DWORD PTR this$[rsp], eax

; 959  :                 if ((unsigned)(this.bits) <= bits) break;

  01f89	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  01f8e	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  01f92	77 02		 ja	 SHORT $LN133@inflate
  01f94	eb 5a		 jmp	 SHORT $LN134@inflate
$LN133@inflate:
$LN132@inflate:

; 960  :                 PULLBYTE();

  01f96	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  01f9b	75 05		 jne	 SHORT $LN129@inflate
  01f9d	e9 56 0b 00 00	 jmp	 $inf_leave$78250
$LN129@inflate:
  01fa2	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  01fa6	83 e8 01	 sub	 eax, 1
  01fa9	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  01fad	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01fb2	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  01fb5	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01fb9	0f b6 c8	 movzx	 ecx, al
  01fbc	8b c2		 mov	 eax, edx
  01fbe	d3 e0		 shl	 eax, cl
  01fc0	8b c8		 mov	 ecx, eax
  01fc2	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  01fc6	03 c1		 add	 eax, ecx
  01fc8	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  01fcc	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  01fd1	48 83 c0 01	 add	 rax, 1
  01fd5	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  01fda	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  01fde	83 c0 08	 add	 eax, 8
  01fe1	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  01fe5	33 c0		 xor	 eax, eax
  01fe7	85 c0		 test	 eax, eax
  01fe9	75 ab		 jne	 SHORT $LN132@inflate

; 961  :             }

  01feb	e9 67 ff ff ff	 jmp	 $LN135@inflate
$LN134@inflate:

; 962  :             if (this.op && (this.op & 0xf0) == 0) {

  01ff0	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  01ff5	85 c0		 test	 eax, eax
  01ff7	0f 84 f9 00 00
	00		 je	 $LN128@inflate
  01ffd	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  02002	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  02007	85 c0		 test	 eax, eax
  02009	0f 85 e7 00 00
	00		 jne	 $LN128@inflate

; 963  :                 last = this;

  0200f	8b 44 24 64	 mov	 eax, DWORD PTR this$[rsp]
  02013	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN127@inflate:

; 964  :                 for (;;) {
; 965  :                     this = state->lencode[last.val +
; 966  :                             (BITS(last.bits + last.op) >> last.bits)];

  02017	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  0201d	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  02022	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  02027	03 c8		 add	 ecx, eax
  02029	b8 01 00 00 00	 mov	 eax, 1
  0202e	d3 e0		 shl	 eax, cl
  02030	83 e8 01	 sub	 eax, 1
  02033	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  02037	23 d0		 and	 edx, eax
  02039	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0203e	0f b6 c8	 movzx	 ecx, al
  02041	8b c2		 mov	 eax, edx
  02043	d3 e8		 shr	 eax, cl
  02045	8b c8		 mov	 ecx, eax
  02047	41 8b c0	 mov	 eax, r8d
  0204a	03 c1		 add	 eax, ecx
  0204c	8b c8		 mov	 ecx, eax
  0204e	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02056	48 8b 40 58	 mov	 rax, QWORD PTR [rax+88]
  0205a	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  0205d	89 44 24 64	 mov	 DWORD PTR this$[rsp], eax

; 967  :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  02061	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02066	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  0206b	03 c1		 add	 eax, ecx
  0206d	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  02071	77 02		 ja	 SHORT $LN125@inflate
  02073	eb 5a		 jmp	 SHORT $LN126@inflate
$LN125@inflate:
$LN124@inflate:

; 968  :                     PULLBYTE();

  02075	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  0207a	75 05		 jne	 SHORT $LN121@inflate
  0207c	e9 77 0a 00 00	 jmp	 $inf_leave$78250
$LN121@inflate:
  02081	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  02085	83 e8 01	 sub	 eax, 1
  02088	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  0208c	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02091	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  02094	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02098	0f b6 c8	 movzx	 ecx, al
  0209b	8b c2		 mov	 eax, edx
  0209d	d3 e0		 shl	 eax, cl
  0209f	8b c8		 mov	 ecx, eax
  020a1	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  020a5	03 c1		 add	 eax, ecx
  020a7	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  020ab	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  020b0	48 83 c0 01	 add	 rax, 1
  020b4	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  020b9	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  020bd	83 c0 08	 add	 eax, 8
  020c0	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  020c4	33 c0		 xor	 eax, eax
  020c6	85 c0		 test	 eax, eax
  020c8	75 ab		 jne	 SHORT $LN124@inflate

; 969  :                 }

  020ca	e9 48 ff ff ff	 jmp	 $LN127@inflate
$LN126@inflate:
$LN120@inflate:

; 970  :                 DROPBITS(last.bits);

  020cf	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  020d4	0f b6 c8	 movzx	 ecx, al
  020d7	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  020db	d3 e8		 shr	 eax, cl
  020dd	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  020e1	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  020e6	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  020ea	2b c1		 sub	 eax, ecx
  020ec	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  020f0	33 c0		 xor	 eax, eax
  020f2	85 c0		 test	 eax, eax
  020f4	75 d9		 jne	 SHORT $LN120@inflate
$LN128@inflate:
$LN117@inflate:

; 971  :             }
; 972  :             DROPBITS(this.bits);

  020f6	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  020fb	0f b6 c8	 movzx	 ecx, al
  020fe	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  02102	d3 e8		 shr	 eax, cl
  02104	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02108	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  0210d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02111	2b c1		 sub	 eax, ecx
  02113	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  02117	33 c0		 xor	 eax, eax
  02119	85 c0		 test	 eax, eax
  0211b	75 d9		 jne	 SHORT $LN117@inflate

; 973  :             state->length = (unsigned)this.val;

  0211d	0f b7 4c 24 66	 movzx	 ecx, WORD PTR this$[rsp+2]
  02122	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0212a	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 974  :             if ((int)(this.op) == 0) {

  0212d	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  02132	85 c0		 test	 eax, eax
  02134	75 13		 jne	 SHORT $LN114@inflate

; 975  :                 Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
; 976  :                         "inflate:         literal '%c'\n" :
; 977  :                         "inflate:         literal 0x%02x\n", this.val));
; 978  :                 state->mode = LIT;

  02136	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0213e	c7 00 17 00 00
	00		 mov	 DWORD PTR [rax], 23

; 979  :                 break;

  02144	e9 aa 09 00 00	 jmp	 $LN484@inflate
$LN114@inflate:

; 980  :             }
; 981  :             if (this.op & 32) {

  02149	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  0214e	83 e0 20	 and	 eax, 32			; 00000020H
  02151	85 c0		 test	 eax, eax
  02153	74 13		 je	 SHORT $LN113@inflate

; 982  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 983  :                 state->mode = TYPE;

  02155	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0215d	c7 00 0b 00 00
	00		 mov	 DWORD PTR [rax], 11

; 984  :                 break;

  02163	e9 8b 09 00 00	 jmp	 $LN484@inflate
$LN113@inflate:

; 985  :             }
; 986  :             if (this.op & 64) {

  02168	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  0216d	83 e0 40	 and	 eax, 64			; 00000040H
  02170	85 c0		 test	 eax, eax
  02172	74 26		 je	 SHORT $LN112@inflate

; 987  :                 strm->msg = (char *)"invalid literal/length code";

  02174	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0217c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
  02183	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 988  :                 state->mode = BAD;

  02187	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0218f	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 989  :                 break;

  02195	e9 59 09 00 00	 jmp	 $LN484@inflate
$LN112@inflate:

; 990  :             }
; 991  :             state->extra = (unsigned)(this.op) & 15;

  0219a	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR this$[rsp]
  0219f	83 e1 0f	 and	 ecx, 15
  021a2	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  021aa	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 992  :             state->mode = LENEXT;

  021ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  021b5	c7 00 13 00 00
	00		 mov	 DWORD PTR [rax], 19
$LN111@inflate:

; 993  :         case LENEXT:
; 994  :             if (state->extra) {

  021bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  021c3	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  021c7	0f 84 d2 00 00
	00		 je	 $LN110@inflate
$LN109@inflate:
$LN106@inflate:

; 995  :                 NEEDBITS(state->extra);

  021cd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  021d5	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  021d8	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  021dc	73 57		 jae	 SHORT $LN105@inflate
$LN104@inflate:
  021de	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  021e3	75 05		 jne	 SHORT $LN101@inflate
  021e5	e9 0e 09 00 00	 jmp	 $inf_leave$78250
$LN101@inflate:
  021ea	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  021ee	83 e8 01	 sub	 eax, 1
  021f1	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  021f5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  021fa	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  021fd	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02201	0f b6 c8	 movzx	 ecx, al
  02204	8b c2		 mov	 eax, edx
  02206	d3 e0		 shl	 eax, cl
  02208	8b c8		 mov	 ecx, eax
  0220a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0220e	03 c1		 add	 eax, ecx
  02210	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02214	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02219	48 83 c0 01	 add	 rax, 1
  0221d	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  02222	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02226	83 c0 08	 add	 eax, 8
  02229	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0222d	33 c0		 xor	 eax, eax
  0222f	85 c0		 test	 eax, eax
  02231	75 ab		 jne	 SHORT $LN104@inflate
  02233	eb 98		 jmp	 SHORT $LN106@inflate
$LN105@inflate:
  02235	33 c0		 xor	 eax, eax
  02237	85 c0		 test	 eax, eax
  02239	75 92		 jne	 SHORT $LN109@inflate

; 996  :                 state->length += BITS(state->extra);

  0223b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02243	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  02246	b8 01 00 00 00	 mov	 eax, 1
  0224b	d3 e0		 shl	 eax, cl
  0224d	83 e8 01	 sub	 eax, 1
  02250	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  02254	23 c8		 and	 ecx, eax
  02256	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0225e	03 48 48	 add	 ecx, DWORD PTR [rax+72]
  02261	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02269	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN100@inflate:

; 997  :                 DROPBITS(state->extra);

  0226c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02274	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02277	0f b6 c8	 movzx	 ecx, al
  0227a	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0227e	d3 e8		 shr	 eax, cl
  02280	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02284	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0228c	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0228f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02293	2b c1		 sub	 eax, ecx
  02295	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  02299	33 c0		 xor	 eax, eax
  0229b	85 c0		 test	 eax, eax
  0229d	75 cd		 jne	 SHORT $LN100@inflate
$LN110@inflate:

; 998  :             }
; 999  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1000 :             state->mode = DIST;

  0229f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022a7	c7 00 14 00 00
	00		 mov	 DWORD PTR [rax], 20
$LN97@inflate:
$LN96@inflate:

; 1001 :         case DIST:
; 1002 :             for (;;) {
; 1003 :                 this = state->distcode[BITS(state->distbits)];

  022ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022b5	8b 48 6c	 mov	 ecx, DWORD PTR [rax+108]
  022b8	b8 01 00 00 00	 mov	 eax, 1
  022bd	d3 e0		 shl	 eax, cl
  022bf	8b c8		 mov	 ecx, eax
  022c1	83 e9 01	 sub	 ecx, 1
  022c4	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  022c8	23 c1		 and	 eax, ecx
  022ca	8b c8		 mov	 ecx, eax
  022cc	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  022d4	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  022d8	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  022db	89 44 24 64	 mov	 DWORD PTR this$[rsp], eax

; 1004 :                 if ((unsigned)(this.bits) <= bits) break;

  022df	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  022e4	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  022e8	77 02		 ja	 SHORT $LN94@inflate
  022ea	eb 5a		 jmp	 SHORT $LN95@inflate
$LN94@inflate:
$LN93@inflate:

; 1005 :                 PULLBYTE();

  022ec	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  022f1	75 05		 jne	 SHORT $LN90@inflate
  022f3	e9 00 08 00 00	 jmp	 $inf_leave$78250
$LN90@inflate:
  022f8	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  022fc	83 e8 01	 sub	 eax, 1
  022ff	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  02303	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02308	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0230b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0230f	0f b6 c8	 movzx	 ecx, al
  02312	8b c2		 mov	 eax, edx
  02314	d3 e0		 shl	 eax, cl
  02316	8b c8		 mov	 ecx, eax
  02318	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0231c	03 c1		 add	 eax, ecx
  0231e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02322	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02327	48 83 c0 01	 add	 rax, 1
  0232b	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  02330	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02334	83 c0 08	 add	 eax, 8
  02337	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0233b	33 c0		 xor	 eax, eax
  0233d	85 c0		 test	 eax, eax
  0233f	75 ab		 jne	 SHORT $LN93@inflate

; 1006 :             }

  02341	e9 67 ff ff ff	 jmp	 $LN96@inflate
$LN95@inflate:

; 1007 :             if ((this.op & 0xf0) == 0) {

  02346	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  0234b	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  02350	85 c0		 test	 eax, eax
  02352	0f 85 e7 00 00
	00		 jne	 $LN89@inflate

; 1008 :                 last = this;

  02358	8b 44 24 64	 mov	 eax, DWORD PTR this$[rsp]
  0235c	89 44 24 38	 mov	 DWORD PTR last$[rsp], eax
$LN88@inflate:

; 1009 :                 for (;;) {
; 1010 :                     this = state->distcode[last.val +
; 1011 :                             (BITS(last.bits + last.op) >> last.bits)];

  02360	44 0f b7 44 24
	3a		 movzx	 r8d, WORD PTR last$[rsp+2]
  02366	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  0236b	0f b6 44 24 38	 movzx	 eax, BYTE PTR last$[rsp]
  02370	03 c8		 add	 ecx, eax
  02372	b8 01 00 00 00	 mov	 eax, 1
  02377	d3 e0		 shl	 eax, cl
  02379	83 e8 01	 sub	 eax, 1
  0237c	8b 54 24 5c	 mov	 edx, DWORD PTR hold$[rsp]
  02380	23 d0		 and	 edx, eax
  02382	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  02387	0f b6 c8	 movzx	 ecx, al
  0238a	8b c2		 mov	 eax, edx
  0238c	d3 e8		 shr	 eax, cl
  0238e	8b c8		 mov	 ecx, eax
  02390	41 8b c0	 mov	 eax, r8d
  02393	03 c1		 add	 eax, ecx
  02395	8b c8		 mov	 ecx, eax
  02397	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0239f	48 8b 40 60	 mov	 rax, QWORD PTR [rax+96]
  023a3	8b 04 88	 mov	 eax, DWORD PTR [rax+rcx*4]
  023a6	89 44 24 64	 mov	 DWORD PTR this$[rsp], eax

; 1012 :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  023aa	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  023af	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  023b4	03 c1		 add	 eax, ecx
  023b6	3b 44 24 48	 cmp	 eax, DWORD PTR bits$[rsp]
  023ba	77 02		 ja	 SHORT $LN86@inflate
  023bc	eb 5a		 jmp	 SHORT $LN87@inflate
$LN86@inflate:
$LN85@inflate:

; 1013 :                     PULLBYTE();

  023be	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  023c3	75 05		 jne	 SHORT $LN82@inflate
  023c5	e9 2e 07 00 00	 jmp	 $inf_leave$78250
$LN82@inflate:
  023ca	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  023ce	83 e8 01	 sub	 eax, 1
  023d1	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  023d5	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  023da	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  023dd	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  023e1	0f b6 c8	 movzx	 ecx, al
  023e4	8b c2		 mov	 eax, edx
  023e6	d3 e0		 shl	 eax, cl
  023e8	8b c8		 mov	 ecx, eax
  023ea	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  023ee	03 c1		 add	 eax, ecx
  023f0	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  023f4	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  023f9	48 83 c0 01	 add	 rax, 1
  023fd	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  02402	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02406	83 c0 08	 add	 eax, 8
  02409	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0240d	33 c0		 xor	 eax, eax
  0240f	85 c0		 test	 eax, eax
  02411	75 ab		 jne	 SHORT $LN85@inflate

; 1014 :                 }

  02413	e9 48 ff ff ff	 jmp	 $LN88@inflate
$LN87@inflate:
$LN81@inflate:

; 1015 :                 DROPBITS(last.bits);

  02418	0f b6 44 24 39	 movzx	 eax, BYTE PTR last$[rsp+1]
  0241d	0f b6 c8	 movzx	 ecx, al
  02420	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  02424	d3 e8		 shr	 eax, cl
  02426	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  0242a	0f b6 4c 24 39	 movzx	 ecx, BYTE PTR last$[rsp+1]
  0242f	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02433	2b c1		 sub	 eax, ecx
  02435	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  02439	33 c0		 xor	 eax, eax
  0243b	85 c0		 test	 eax, eax
  0243d	75 d9		 jne	 SHORT $LN81@inflate
$LN89@inflate:
$LN78@inflate:

; 1016 :             }
; 1017 :             DROPBITS(this.bits);

  0243f	0f b6 44 24 65	 movzx	 eax, BYTE PTR this$[rsp+1]
  02444	0f b6 c8	 movzx	 ecx, al
  02447	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0244b	d3 e8		 shr	 eax, cl
  0244d	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02451	0f b6 4c 24 65	 movzx	 ecx, BYTE PTR this$[rsp+1]
  02456	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0245a	2b c1		 sub	 eax, ecx
  0245c	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  02460	33 c0		 xor	 eax, eax
  02462	85 c0		 test	 eax, eax
  02464	75 d9		 jne	 SHORT $LN78@inflate

; 1018 :             if (this.op & 64) {

  02466	0f b6 44 24 64	 movzx	 eax, BYTE PTR this$[rsp]
  0246b	83 e0 40	 and	 eax, 64			; 00000040H
  0246e	85 c0		 test	 eax, eax
  02470	74 26		 je	 SHORT $LN75@inflate

; 1019 :                 strm->msg = (char *)"invalid distance code";

  02472	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  0247a	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
  02481	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1020 :                 state->mode = BAD;

  02485	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0248d	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 1021 :                 break;

  02493	e9 5b 06 00 00	 jmp	 $LN484@inflate
$LN75@inflate:

; 1022 :             }
; 1023 :             state->offset = (unsigned)this.val;

  02498	0f b7 4c 24 66	 movzx	 ecx, WORD PTR this$[rsp+2]
  0249d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  024a5	89 48 4c	 mov	 DWORD PTR [rax+76], ecx

; 1024 :             state->extra = (unsigned)(this.op) & 15;

  024a8	0f b6 4c 24 64	 movzx	 ecx, BYTE PTR this$[rsp]
  024ad	83 e1 0f	 and	 ecx, 15
  024b0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  024b8	89 48 50	 mov	 DWORD PTR [rax+80], ecx

; 1025 :             state->mode = DISTEXT;

  024bb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  024c3	c7 00 15 00 00
	00		 mov	 DWORD PTR [rax], 21
$LN74@inflate:

; 1026 :         case DISTEXT:
; 1027 :             if (state->extra) {

  024c9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  024d1	83 78 50 00	 cmp	 DWORD PTR [rax+80], 0
  024d5	0f 84 d2 00 00
	00		 je	 $LN73@inflate
$LN72@inflate:
$LN69@inflate:

; 1028 :                 NEEDBITS(state->extra);

  024db	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  024e3	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  024e6	39 44 24 48	 cmp	 DWORD PTR bits$[rsp], eax
  024ea	73 57		 jae	 SHORT $LN68@inflate
$LN67@inflate:
  024ec	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  024f1	75 05		 jne	 SHORT $LN64@inflate
  024f3	e9 00 06 00 00	 jmp	 $inf_leave$78250
$LN64@inflate:
  024f8	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  024fc	83 e8 01	 sub	 eax, 1
  024ff	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  02503	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02508	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0250b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0250f	0f b6 c8	 movzx	 ecx, al
  02512	8b c2		 mov	 eax, edx
  02514	d3 e0		 shl	 eax, cl
  02516	8b c8		 mov	 ecx, eax
  02518	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0251c	03 c1		 add	 eax, ecx
  0251e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02522	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02527	48 83 c0 01	 add	 rax, 1
  0252b	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  02530	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02534	83 c0 08	 add	 eax, 8
  02537	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0253b	33 c0		 xor	 eax, eax
  0253d	85 c0		 test	 eax, eax
  0253f	75 ab		 jne	 SHORT $LN67@inflate
  02541	eb 98		 jmp	 SHORT $LN69@inflate
$LN68@inflate:
  02543	33 c0		 xor	 eax, eax
  02545	85 c0		 test	 eax, eax
  02547	75 92		 jne	 SHORT $LN72@inflate

; 1029 :                 state->offset += BITS(state->extra);

  02549	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02551	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  02554	b8 01 00 00 00	 mov	 eax, 1
  02559	d3 e0		 shl	 eax, cl
  0255b	83 e8 01	 sub	 eax, 1
  0255e	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  02562	23 c8		 and	 ecx, eax
  02564	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0256c	03 48 4c	 add	 ecx, DWORD PTR [rax+76]
  0256f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02577	89 48 4c	 mov	 DWORD PTR [rax+76], ecx
$LN63@inflate:

; 1030 :                 DROPBITS(state->extra);

  0257a	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02582	8b 40 50	 mov	 eax, DWORD PTR [rax+80]
  02585	0f b6 c8	 movzx	 ecx, al
  02588	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0258c	d3 e8		 shr	 eax, cl
  0258e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02592	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0259a	8b 48 50	 mov	 ecx, DWORD PTR [rax+80]
  0259d	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  025a1	2b c1		 sub	 eax, ecx
  025a3	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  025a7	33 c0		 xor	 eax, eax
  025a9	85 c0		 test	 eax, eax
  025ab	75 cd		 jne	 SHORT $LN63@inflate
$LN73@inflate:

; 1031 :             }
; 1032 : #ifdef INFLATE_STRICT
; 1033 :             if (state->offset > state->dmax) {
; 1034 :                 strm->msg = (char *)"invalid distance too far back";
; 1035 :                 state->mode = BAD;
; 1036 :                 break;
; 1037 :             }
; 1038 : #endif
; 1039 :             if (state->offset > state->whave + out - left) {

  025ad	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  025b5	8b 48 30	 mov	 ecx, DWORD PTR [rax+48]
  025b8	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  025bc	2b 4c 24 4c	 sub	 ecx, DWORD PTR left$[rsp]
  025c0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  025c8	39 48 4c	 cmp	 DWORD PTR [rax+76], ecx
  025cb	76 26		 jbe	 SHORT $LN60@inflate

; 1040 :                 strm->msg = (char *)"invalid distance too far back";

  025cd	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  025d5	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
  025dc	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1041 :                 state->mode = BAD;

  025e0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  025e8	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 1042 :                 break;

  025ee	e9 00 05 00 00	 jmp	 $LN484@inflate
$LN60@inflate:

; 1043 :             }
; 1044 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1045 :             state->mode = MATCH;

  025f3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  025fb	c7 00 16 00 00
	00		 mov	 DWORD PTR [rax], 22
$LN59@inflate:

; 1046 :         case MATCH:
; 1047 :             if (left == 0) goto inf_leave;

  02601	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  02606	75 05		 jne	 SHORT $LN58@inflate
  02608	e9 eb 04 00 00	 jmp	 $inf_leave$78250
$LN58@inflate:

; 1048 :             copy = out - left;

  0260d	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  02611	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02615	2b c1		 sub	 eax, ecx
  02617	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 1049 :             if (state->offset > copy) {         /* copy from window */

  0261b	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02623	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  02627	39 41 4c	 cmp	 DWORD PTR [rcx+76], eax
  0262a	0f 86 a7 00 00
	00		 jbe	 $LN57@inflate

; 1050 :                 copy = state->offset - copy;

  02630	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02638	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  0263c	8b 40 4c	 mov	 eax, DWORD PTR [rax+76]
  0263f	2b c1		 sub	 eax, ecx
  02641	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 1051 :                 if (copy > state->write) {

  02645	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0264d	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  02650	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  02654	76 3b		 jbe	 SHORT $LN56@inflate

; 1052 :                     copy -= state->write;

  02656	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0265e	8b 48 34	 mov	 ecx, DWORD PTR [rax+52]
  02661	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  02665	2b c1		 sub	 eax, ecx
  02667	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax

; 1053 :                     from = state->window + (state->wsize - copy);

  0266b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02673	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  02677	8b 40 2c	 mov	 eax, DWORD PTR [rax+44]
  0267a	2b c1		 sub	 eax, ecx
  0267c	8b c0		 mov	 eax, eax
  0267e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02686	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  0268a	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1054 :                 }
; 1055 :                 else

  0268f	eb 24		 jmp	 SHORT $LN55@inflate
$LN56@inflate:

; 1056 :                     from = state->window + (state->write - copy);

  02691	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02699	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  0269d	8b 40 34	 mov	 eax, DWORD PTR [rax+52]
  026a0	2b c1		 sub	 eax, ecx
  026a2	8b c0		 mov	 eax, eax
  026a4	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  026ac	48 03 41 38	 add	 rax, QWORD PTR [rcx+56]
  026b0	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax
$LN55@inflate:

; 1057 :                 if (copy > state->length) copy = state->length;

  026b5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026bd	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  026c0	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  026c4	76 0f		 jbe	 SHORT $LN54@inflate
  026c6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026ce	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  026d1	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN54@inflate:

; 1058 :             }
; 1059 :             else {                              /* copy from output */

  026d5	eb 27		 jmp	 SHORT $LN53@inflate
$LN57@inflate:

; 1060 :                 from = put - state->offset;

  026d7	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026df	8b 48 4c	 mov	 ecx, DWORD PTR [rax+76]
  026e2	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  026e7	48 2b c1	 sub	 rax, rcx
  026ea	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1061 :                 copy = state->length;

  026ef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  026f7	8b 40 48	 mov	 eax, DWORD PTR [rax+72]
  026fa	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN53@inflate:

; 1062 :             }
; 1063 :             if (copy > left) copy = left;

  026fe	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  02702	39 44 24 68	 cmp	 DWORD PTR copy$[rsp], eax
  02706	76 08		 jbe	 SHORT $LN52@inflate
  02708	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0270c	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
$LN52@inflate:

; 1064 :             left -= copy;

  02710	8b 4c 24 68	 mov	 ecx, DWORD PTR copy$[rsp]
  02714	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  02718	2b c1		 sub	 eax, ecx
  0271a	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 1065 :             state->length -= copy;

  0271e	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02726	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  0272a	8b 49 48	 mov	 ecx, DWORD PTR [rcx+72]
  0272d	2b c8		 sub	 ecx, eax
  0272f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02737	89 48 48	 mov	 DWORD PTR [rax+72], ecx
$LN51@inflate:

; 1066 :             do {
; 1067 :                 *put++ = *from++;

  0273a	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  0273f	48 8b 44 24 70	 mov	 rax, QWORD PTR from$[rsp]
  02744	0f b6 00	 movzx	 eax, BYTE PTR [rax]
  02747	88 01		 mov	 BYTE PTR [rcx], al
  02749	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  0274e	48 83 c0 01	 add	 rax, 1
  02752	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax
  02757	48 8b 44 24 70	 mov	 rax, QWORD PTR from$[rsp]
  0275c	48 83 c0 01	 add	 rax, 1
  02760	48 89 44 24 70	 mov	 QWORD PTR from$[rsp], rax

; 1068 :             } while (--copy);

  02765	8b 44 24 68	 mov	 eax, DWORD PTR copy$[rsp]
  02769	83 e8 01	 sub	 eax, 1
  0276c	89 44 24 68	 mov	 DWORD PTR copy$[rsp], eax
  02770	83 7c 24 68 00	 cmp	 DWORD PTR copy$[rsp], 0
  02775	75 c3		 jne	 SHORT $LN51@inflate

; 1069 :             if (state->length == 0) state->mode = LEN;

  02777	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0277f	83 78 48 00	 cmp	 DWORD PTR [rax+72], 0
  02783	75 0e		 jne	 SHORT $LN48@inflate
  02785	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0278d	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18
$LN48@inflate:

; 1070 :             break;

  02793	e9 5b 03 00 00	 jmp	 $LN484@inflate
$LN47@inflate:

; 1071 :         case LIT:
; 1072 :             if (left == 0) goto inf_leave;

  02798	83 7c 24 4c 00	 cmp	 DWORD PTR left$[rsp], 0
  0279d	75 05		 jne	 SHORT $LN46@inflate
  0279f	e9 54 03 00 00	 jmp	 $inf_leave$78250
$LN46@inflate:

; 1073 :             *put++ = (unsigned char)(state->length);

  027a4	48 8b 4c 24 30	 mov	 rcx, QWORD PTR put$[rsp]
  027a9	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027b1	0f b6 40 48	 movzx	 eax, BYTE PTR [rax+72]
  027b5	88 01		 mov	 BYTE PTR [rcx], al
  027b7	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  027bc	48 83 c0 01	 add	 rax, 1
  027c0	48 89 44 24 30	 mov	 QWORD PTR put$[rsp], rax

; 1074 :             left--;

  027c5	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  027c9	83 e8 01	 sub	 eax, 1
  027cc	89 44 24 4c	 mov	 DWORD PTR left$[rsp], eax

; 1075 :             state->mode = LEN;

  027d0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027d8	c7 00 12 00 00
	00		 mov	 DWORD PTR [rax], 18

; 1076 :             break;

  027de	e9 10 03 00 00	 jmp	 $LN484@inflate
$LN45@inflate:

; 1077 :         case CHECK:
; 1078 :             if (state->wrap) {

  027e3	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  027eb	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  027ef	0f 84 e8 01 00
	00		 je	 $LN44@inflate
$LN43@inflate:
$LN40@inflate:

; 1079 :                 NEEDBITS(32);

  027f5	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  027fa	73 57		 jae	 SHORT $LN39@inflate
$LN38@inflate:
  027fc	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  02801	75 05		 jne	 SHORT $LN35@inflate
  02803	e9 f0 02 00 00	 jmp	 $inf_leave$78250
$LN35@inflate:
  02808	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  0280c	83 e8 01	 sub	 eax, 1
  0280f	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  02813	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02818	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  0281b	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  0281f	0f b6 c8	 movzx	 ecx, al
  02822	8b c2		 mov	 eax, edx
  02824	d3 e0		 shl	 eax, cl
  02826	8b c8		 mov	 ecx, eax
  02828	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  0282c	03 c1		 add	 eax, ecx
  0282e	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02832	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02837	48 83 c0 01	 add	 rax, 1
  0283b	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  02840	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02844	83 c0 08	 add	 eax, 8
  02847	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  0284b	33 c0		 xor	 eax, eax
  0284d	85 c0		 test	 eax, eax
  0284f	75 ab		 jne	 SHORT $LN38@inflate
  02851	eb a2		 jmp	 SHORT $LN40@inflate
$LN39@inflate:
  02853	33 c0		 xor	 eax, eax
  02855	85 c0		 test	 eax, eax
  02857	75 9c		 jne	 SHORT $LN43@inflate

; 1080 :                 out -= left;

  02859	8b 4c 24 4c	 mov	 ecx, DWORD PTR left$[rsp]
  0285d	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02861	2b c1		 sub	 eax, ecx
  02863	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1081 :                 strm->total_out += out;

  02867	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0286f	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02872	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02876	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  0287e	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1082 :                 state->total += out;

  02881	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02889	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  0288c	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02890	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02898	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1083 :                 if (out)

  0289b	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  028a0	0f 84 84 00 00
	00		 je	 $LN34@inflate

; 1084 :                     strm->adler = state->check =
; 1085 :                         UPDATE(state->check, put - out, out);

  028a6	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028ae	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  028b2	74 2a		 je	 SHORT $LN500@inflate
  028b4	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  028b8	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  028bd	48 2b d0	 sub	 rdx, rax
  028c0	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  028c5	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028cd	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  028d0	e8 00 00 00 00	 call	 crc32
  028d5	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv1222[rsp], eax
  028dc	eb 28		 jmp	 SHORT $LN501@inflate
$LN500@inflate:
  028de	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  028e2	48 8b 54 24 30	 mov	 rdx, QWORD PTR put$[rsp]
  028e7	48 2b d0	 sub	 rdx, rax
  028ea	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  028ef	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  028f7	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  028fa	e8 00 00 00 00	 call	 adler32
  028ff	89 84 24 98 00
	00 00		 mov	 DWORD PTR tv1222[rsp], eax
$LN501@inflate:
  02906	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  0290e	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv1222[rsp]
  02915	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  02918	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02920	8b 84 24 98 00
	00 00		 mov	 eax, DWORD PTR tv1222[rsp]
  02927	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN34@inflate:

; 1086 :                 out = left;

  0292a	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  0292e	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1087 :                 if ((
; 1088 : #ifdef GUNZIP
; 1089 :                      state->flags ? hold :
; 1090 : #endif
; 1091 :                      REVERSE(hold)) != state->check) {

  02932	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  0293a	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  0293e	74 0d		 je	 SHORT $LN502@inflate
  02940	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  02944	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv1236[rsp], eax
  0294b	eb 40		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  0294d	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  02951	c1 e8 18	 shr	 eax, 24
  02954	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  02959	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0295d	c1 e9 08	 shr	 ecx, 8
  02960	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02966	03 c1		 add	 eax, ecx
  02968	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0296c	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  02972	c1 e1 08	 shl	 ecx, 8
  02975	03 c1		 add	 eax, ecx
  02977	8b 4c 24 5c	 mov	 ecx, DWORD PTR hold$[rsp]
  0297b	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  02981	c1 e1 18	 shl	 ecx, 24
  02984	03 c1		 add	 eax, ecx
  02986	89 84 24 9c 00
	00 00		 mov	 DWORD PTR tv1236[rsp], eax
$LN503@inflate:
  0298d	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02995	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02998	39 84 24 9c 00
	00 00		 cmp	 DWORD PTR tv1236[rsp], eax
  0299f	74 26		 je	 SHORT $LN33@inflate

; 1092 :                     strm->msg = (char *)"incorrect data check";

  029a1	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  029a9	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
  029b0	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1093 :                     state->mode = BAD;

  029b4	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029bc	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 1094 :                     break;

  029c2	e9 2c 01 00 00	 jmp	 $LN484@inflate
$LN33@inflate:
$LN32@inflate:

; 1095 :                 }
; 1096 :                 INITBITS();

  029c7	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  029cf	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  029d7	33 c0		 xor	 eax, eax
  029d9	85 c0		 test	 eax, eax
  029db	75 ea		 jne	 SHORT $LN32@inflate
$LN44@inflate:

; 1097 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1098 :             }
; 1099 : #ifdef GUNZIP
; 1100 :             state->mode = LENGTH;

  029dd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029e5	c7 00 19 00 00
	00		 mov	 DWORD PTR [rax], 25
$LN29@inflate:

; 1101 :         case LENGTH:
; 1102 :             if (state->wrap && state->flags) {

  029eb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  029f3	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  029f7	0f 84 c0 00 00
	00		 je	 $LN28@inflate
  029fd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a05	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02a09	0f 84 ae 00 00
	00		 je	 $LN28@inflate
$LN27@inflate:
$LN24@inflate:

; 1103 :                 NEEDBITS(32);

  02a0f	83 7c 24 48 20	 cmp	 DWORD PTR bits$[rsp], 32 ; 00000020H
  02a14	73 57		 jae	 SHORT $LN23@inflate
$LN22@inflate:
  02a16	83 7c 24 3c 00	 cmp	 DWORD PTR have$[rsp], 0
  02a1b	75 05		 jne	 SHORT $LN19@inflate
  02a1d	e9 d6 00 00 00	 jmp	 $inf_leave$78250
$LN19@inflate:
  02a22	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  02a26	83 e8 01	 sub	 eax, 1
  02a29	89 44 24 3c	 mov	 DWORD PTR have$[rsp], eax
  02a2d	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02a32	0f b6 10	 movzx	 edx, BYTE PTR [rax]
  02a35	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02a39	0f b6 c8	 movzx	 ecx, al
  02a3c	8b c2		 mov	 eax, edx
  02a3e	d3 e0		 shl	 eax, cl
  02a40	8b c8		 mov	 ecx, eax
  02a42	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  02a46	03 c1		 add	 eax, ecx
  02a48	89 44 24 5c	 mov	 DWORD PTR hold$[rsp], eax
  02a4c	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02a51	48 83 c0 01	 add	 rax, 1
  02a55	48 89 44 24 50	 mov	 QWORD PTR next$[rsp], rax
  02a5a	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02a5e	83 c0 08	 add	 eax, 8
  02a61	89 44 24 48	 mov	 DWORD PTR bits$[rsp], eax
  02a65	33 c0		 xor	 eax, eax
  02a67	85 c0		 test	 eax, eax
  02a69	75 ab		 jne	 SHORT $LN22@inflate
  02a6b	eb a2		 jmp	 SHORT $LN24@inflate
$LN23@inflate:
  02a6d	33 c0		 xor	 eax, eax
  02a6f	85 c0		 test	 eax, eax
  02a71	75 9c		 jne	 SHORT $LN27@inflate

; 1104 :                 if (hold != (state->total & 0xffffffffUL)) {

  02a73	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a7b	8b 40 1c	 mov	 eax, DWORD PTR [rax+28]
  02a7e	39 44 24 5c	 cmp	 DWORD PTR hold$[rsp], eax
  02a82	74 23		 je	 SHORT $LN18@inflate

; 1105 :                     strm->msg = (char *)"incorrect length check";

  02a84	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02a8c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
  02a93	48 89 41 20	 mov	 QWORD PTR [rcx+32], rax

; 1106 :                     state->mode = BAD;

  02a97	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02a9f	c7 00 1b 00 00
	00		 mov	 DWORD PTR [rax], 27

; 1107 :                     break;

  02aa5	eb 4c		 jmp	 SHORT $LN484@inflate
$LN18@inflate:
$LN17@inflate:

; 1108 :                 }
; 1109 :                 INITBITS();

  02aa7	c7 44 24 5c 00
	00 00 00	 mov	 DWORD PTR hold$[rsp], 0
  02aaf	c7 44 24 48 00
	00 00 00	 mov	 DWORD PTR bits$[rsp], 0
  02ab7	33 c0		 xor	 eax, eax
  02ab9	85 c0		 test	 eax, eax
  02abb	75 ea		 jne	 SHORT $LN17@inflate
$LN28@inflate:

; 1110 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1111 :             }
; 1112 : #endif
; 1113 :             state->mode = DONE;

  02abd	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ac5	c7 00 1a 00 00
	00		 mov	 DWORD PTR [rax], 26
$LN14@inflate:

; 1114 :         case DONE:
; 1115 :             ret = Z_STREAM_END;

  02acb	c7 44 24 58 01
	00 00 00	 mov	 DWORD PTR ret$[rsp], 1

; 1116 :             goto inf_leave;

  02ad3	eb 23		 jmp	 SHORT $inf_leave$78250
$LN13@inflate:

; 1117 :         case BAD:
; 1118 :             ret = Z_DATA_ERROR;

  02ad5	c7 44 24 58 fd
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -3

; 1119 :             goto inf_leave;

  02add	eb 19		 jmp	 SHORT $inf_leave$78250
$LN12@inflate:

; 1120 :         case MEM:
; 1121 :             return Z_MEM_ERROR;

  02adf	b8 fc ff ff ff	 mov	 eax, -4
  02ae4	e9 8c 02 00 00	 jmp	 $LN494@inflate
$LN11@inflate:

; 1122 :         case SYNC:
; 1123 :         default:
; 1124 :             return Z_STREAM_ERROR;

  02ae9	b8 fe ff ff ff	 mov	 eax, -2
  02aee	e9 82 02 00 00	 jmp	 $LN494@inflate
$LN484@inflate:

; 1125 :         }

  02af3	e9 11 d6 ff ff	 jmp	 $LN487@inflate
$inf_leave$78250:
$LN10@inflate:

; 1126 : 
; 1127 :     /*
; 1128 :        Return from inflate(), updating the total counts and the check value.
; 1129 :        If there was no progress during the inflate() call, return a buffer
; 1130 :        error.  Call updatewindow() to create and/or update the window state.
; 1131 :        Note: a memory error from inflate() is non-recoverable.
; 1132 :      */
; 1133 :   inf_leave:
; 1134 :     RESTORE();

  02af8	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02b00	48 8b 44 24 30	 mov	 rax, QWORD PTR put$[rsp]
  02b05	48 89 41 10	 mov	 QWORD PTR [rcx+16], rax
  02b09	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02b11	8b 44 24 4c	 mov	 eax, DWORD PTR left$[rsp]
  02b15	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  02b18	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02b20	48 8b 44 24 50	 mov	 rax, QWORD PTR next$[rsp]
  02b25	48 89 01	 mov	 QWORD PTR [rcx], rax
  02b28	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02b30	8b 44 24 3c	 mov	 eax, DWORD PTR have$[rsp]
  02b34	89 41 08	 mov	 DWORD PTR [rcx+8], eax
  02b37	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02b3f	8b 44 24 5c	 mov	 eax, DWORD PTR hold$[rsp]
  02b43	89 41 40	 mov	 DWORD PTR [rcx+64], eax
  02b46	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02b4e	8b 44 24 48	 mov	 eax, DWORD PTR bits$[rsp]
  02b52	89 41 44	 mov	 DWORD PTR [rcx+68], eax
  02b55	33 c0		 xor	 eax, eax
  02b57	85 c0		 test	 eax, eax
  02b59	75 9d		 jne	 SHORT $LN10@inflate

; 1135 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  02b5b	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b63	83 78 2c 00	 cmp	 DWORD PTR [rax+44], 0
  02b67	75 1e		 jne	 SHORT $LN6@inflate
  02b69	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02b71	83 38 18	 cmp	 DWORD PTR [rax], 24
  02b74	7d 3e		 jge	 SHORT $LN7@inflate
  02b76	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02b7e	8b 40 18	 mov	 eax, DWORD PTR [rax+24]
  02b81	39 44 24 78	 cmp	 DWORD PTR out$[rsp], eax
  02b85	74 2d		 je	 SHORT $LN7@inflate
$LN6@inflate:

; 1136 :         if (updatewindow(strm, out)) {

  02b87	8b 54 24 78	 mov	 edx, DWORD PTR out$[rsp]
  02b8b	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02b93	e8 00 00 00 00	 call	 updatewindow
  02b98	85 c0		 test	 eax, eax
  02b9a	74 18		 je	 SHORT $LN5@inflate

; 1137 :             state->mode = MEM;

  02b9c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ba4	c7 00 1c 00 00
	00		 mov	 DWORD PTR [rax], 28

; 1138 :             return Z_MEM_ERROR;

  02baa	b8 fc ff ff ff	 mov	 eax, -4
  02baf	e9 c1 01 00 00	 jmp	 $LN494@inflate
$LN5@inflate:
$LN7@inflate:

; 1139 :         }
; 1140 :     in -= strm->avail_in;

  02bb4	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02bbc	8b 48 08	 mov	 ecx, DWORD PTR [rax+8]
  02bbf	8b 44 24 40	 mov	 eax, DWORD PTR in$[rsp]
  02bc3	2b c1		 sub	 eax, ecx
  02bc5	89 44 24 40	 mov	 DWORD PTR in$[rsp], eax

; 1141 :     out -= strm->avail_out;

  02bc9	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02bd1	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02bd4	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02bd8	2b c1		 sub	 eax, ecx
  02bda	89 44 24 78	 mov	 DWORD PTR out$[rsp], eax

; 1142 :     strm->total_in += in;

  02bde	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02be6	8b 48 0c	 mov	 ecx, DWORD PTR [rax+12]
  02be9	03 4c 24 40	 add	 ecx, DWORD PTR in$[rsp]
  02bed	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02bf5	89 48 0c	 mov	 DWORD PTR [rax+12], ecx

; 1143 :     strm->total_out += out;

  02bf8	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02c00	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02c03	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02c07	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02c0f	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1144 :     state->total += out;

  02c12	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c1a	8b 48 1c	 mov	 ecx, DWORD PTR [rax+28]
  02c1d	03 4c 24 78	 add	 ecx, DWORD PTR out$[rsp]
  02c21	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c29	89 48 1c	 mov	 DWORD PTR [rax+28], ecx

; 1145 :     if (state->wrap && out)

  02c2c	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c34	83 78 08 00	 cmp	 DWORD PTR [rax+8], 0
  02c38	0f 84 9d 00 00
	00		 je	 $LN4@inflate
  02c3e	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02c43	0f 84 92 00 00
	00		 je	 $LN4@inflate

; 1146 :         strm->adler = state->check =
; 1147 :             UPDATE(state->check, strm->next_out - out, out);

  02c49	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c51	83 78 10 00	 cmp	 DWORD PTR [rax+16], 0
  02c55	74 31		 je	 SHORT $LN504@inflate
  02c57	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02c5b	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  02c63	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  02c67	48 2b d0	 sub	 rdx, rax
  02c6a	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02c6f	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02c77	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02c7a	e8 00 00 00 00	 call	 crc32
  02c7f	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv1311[rsp], eax
  02c86	eb 2f		 jmp	 SHORT $LN505@inflate
$LN504@inflate:
  02c88	8b 44 24 78	 mov	 eax, DWORD PTR out$[rsp]
  02c8c	48 8b 94 24 c0
	00 00 00	 mov	 rdx, QWORD PTR strm$[rsp]
  02c94	48 8b 52 10	 mov	 rdx, QWORD PTR [rdx+16]
  02c98	48 2b d0	 sub	 rdx, rax
  02c9b	44 8b 44 24 78	 mov	 r8d, DWORD PTR out$[rsp]
  02ca0	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ca8	8b 48 18	 mov	 ecx, DWORD PTR [rax+24]
  02cab	e8 00 00 00 00	 call	 adler32
  02cb0	89 84 24 a0 00
	00 00		 mov	 DWORD PTR tv1311[rsp], eax
$LN505@inflate:
  02cb7	48 8b 8c 24 80
	00 00 00	 mov	 rcx, QWORD PTR state$[rsp]
  02cbf	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv1311[rsp]
  02cc6	89 41 18	 mov	 DWORD PTR [rcx+24], eax
  02cc9	48 8b 8c 24 c0
	00 00 00	 mov	 rcx, QWORD PTR strm$[rsp]
  02cd1	8b 84 24 a0 00
	00 00		 mov	 eax, DWORD PTR tv1311[rsp]
  02cd8	89 41 4c	 mov	 DWORD PTR [rcx+76], eax
$LN4@inflate:

; 1148 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1149 :                       (state->mode == TYPE ? 128 : 0);

  02cdb	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02ce3	83 78 04 00	 cmp	 DWORD PTR [rax+4], 0
  02ce7	74 0d		 je	 SHORT $LN506@inflate
  02ce9	c7 84 24 a4 00
	00 00 40 00 00
	00		 mov	 DWORD PTR tv1316[rsp], 64 ; 00000040H
  02cf4	eb 0b		 jmp	 SHORT $LN507@inflate
$LN506@inflate:
  02cf6	c7 84 24 a4 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1316[rsp], 0
$LN507@inflate:
  02d01	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d09	83 38 0b	 cmp	 DWORD PTR [rax], 11
  02d0c	75 0d		 jne	 SHORT $LN508@inflate
  02d0e	c7 84 24 a8 00
	00 00 80 00 00
	00		 mov	 DWORD PTR tv1319[rsp], 128 ; 00000080H
  02d19	eb 0b		 jmp	 SHORT $LN509@inflate
$LN508@inflate:
  02d1b	c7 84 24 a8 00
	00 00 00 00 00
	00		 mov	 DWORD PTR tv1319[rsp], 0
$LN509@inflate:
  02d26	48 8b 84 24 80
	00 00 00	 mov	 rax, QWORD PTR state$[rsp]
  02d2e	8b 48 44	 mov	 ecx, DWORD PTR [rax+68]
  02d31	03 8c 24 a4 00
	00 00		 add	 ecx, DWORD PTR tv1316[rsp]
  02d38	03 8c 24 a8 00
	00 00		 add	 ecx, DWORD PTR tv1319[rsp]
  02d3f	48 8b 84 24 c0
	00 00 00	 mov	 rax, QWORD PTR strm$[rsp]
  02d47	89 48 48	 mov	 DWORD PTR [rax+72], ecx

; 1150 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  02d4a	83 7c 24 40 00	 cmp	 DWORD PTR in$[rsp], 0
  02d4f	75 07		 jne	 SHORT $LN1@inflate
  02d51	83 7c 24 78 00	 cmp	 DWORD PTR out$[rsp], 0
  02d56	74 0a		 je	 SHORT $LN2@inflate
$LN1@inflate:
  02d58	83 bc 24 c8 00
	00 00 04	 cmp	 DWORD PTR flush$[rsp], 4
  02d60	75 0f		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  02d62	83 7c 24 58 00	 cmp	 DWORD PTR ret$[rsp], 0
  02d67	75 08		 jne	 SHORT $LN3@inflate

; 1151 :         ret = Z_BUF_ERROR;

  02d69	c7 44 24 58 fb
	ff ff ff	 mov	 DWORD PTR ret$[rsp], -5
$LN3@inflate:

; 1152 :     return ret;

  02d71	8b 44 24 58	 mov	 eax, DWORD PTR ret$[rsp]
$LN494@inflate:

; 1153 : }

  02d75	48 81 c4 b8 00
	00 00		 add	 rsp, 184		; 000000b8H
  02d7c	c3		 ret	 0
  02d7d	0f 1f 00	 npad	 3
$LN510@inflate:
  02d80	00 00 00 00	 DD	 $LN483@inflate
  02d84	00 00 00 00	 DD	 $LN454@inflate
  02d88	00 00 00 00	 DD	 $LN434@inflate
  02d8c	00 00 00 00	 DD	 $LN416@inflate
  02d90	00 00 00 00	 DD	 $LN398@inflate
  02d94	00 00 00 00	 DD	 $LN377@inflate
  02d98	00 00 00 00	 DD	 $LN370@inflate
  02d9c	00 00 00 00	 DD	 $LN358@inflate
  02da0	00 00 00 00	 DD	 $LN346@inflate
  02da4	00 00 00 00	 DD	 $LN330@inflate
  02da8	00 00 00 00	 DD	 $LN317@inflate
  02dac	00 00 00 00	 DD	 $LN312@inflate
  02db0	00 00 00 00	 DD	 $LN310@inflate
  02db4	00 00 00 00	 DD	 $LN284@inflate
  02db8	00 00 00 00	 DD	 $LN267@inflate
  02dbc	00 00 00 00	 DD	 $LN262@inflate
  02dc0	00 00 00 00	 DD	 $LN241@inflate
  02dc4	00 00 00 00	 DD	 $LN223@inflate
  02dc8	00 00 00 00	 DD	 $LN143@inflate
  02dcc	00 00 00 00	 DD	 $LN111@inflate
  02dd0	00 00 00 00	 DD	 $LN97@inflate
  02dd4	00 00 00 00	 DD	 $LN74@inflate
  02dd8	00 00 00 00	 DD	 $LN59@inflate
  02ddc	00 00 00 00	 DD	 $LN47@inflate
  02de0	00 00 00 00	 DD	 $LN45@inflate
  02de4	00 00 00 00	 DD	 $LN29@inflate
  02de8	00 00 00 00	 DD	 $LN14@inflate
  02dec	00 00 00 00	 DD	 $LN13@inflate
  02df0	00 00 00 00	 DD	 $LN12@inflate
inflate	ENDP
_TEXT	ENDS
PUBLIC	inflateInit2_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit2_ DD imagerel $LN14
	DD	imagerel $LN14+395
	DD	imagerel $unwind$inflateInit2_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit2_ DD 011701H
	DD	06217H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateInit2_
_TEXT	SEGMENT
state$ = 32
strm$ = 64
windowBits$ = 72
version$ = 80
stream_size$ = 88
inflateInit2_ PROC					; COMDAT

; 149  : {

$LN14:
  00000	44 89 4c 24 20	 mov	 DWORD PTR [rsp+32], r9d
  00005	4c 89 44 24 18	 mov	 QWORD PTR [rsp+24], r8
  0000a	89 54 24 10	 mov	 DWORD PTR [rsp+16], edx
  0000e	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  00013	48 83 ec 38	 sub	 rsp, 56			; 00000038H

; 150  :     struct inflate_state FAR *state;
; 151  : 
; 152  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 153  :         stream_size != (int)(sizeof(z_stream)))

  00017	48 83 7c 24 50
	00		 cmp	 QWORD PTR version$[rsp], 0
  0001d	74 1a		 je	 SHORT $LN10@inflateIni
  0001f	48 8b 44 24 50	 mov	 rax, QWORD PTR version$[rsp]
  00024	0f be 08	 movsx	 ecx, BYTE PTR [rax]
  00027	0f be 05 00 00
	00 00		 movsx	 eax, BYTE PTR ??_C@_05GDHACFMB@1?42?43?$AA@
  0002e	3b c8		 cmp	 ecx, eax
  00030	75 07		 jne	 SHORT $LN10@inflateIni
  00032	83 7c 24 58 58	 cmp	 DWORD PTR stream_size$[rsp], 88 ; 00000058H
  00037	74 0a		 je	 SHORT $LN11@inflateIni
$LN10@inflateIni:

; 154  :         return Z_VERSION_ERROR;

  00039	b8 fa ff ff ff	 mov	 eax, -6
  0003e	e9 43 01 00 00	 jmp	 $LN12@inflateIni
$LN11@inflateIni:

; 155  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  00043	48 83 7c 24 40
	00		 cmp	 QWORD PTR strm$[rsp], 0
  00049	75 0a		 jne	 SHORT $LN9@inflateIni
  0004b	b8 fe ff ff ff	 mov	 eax, -2
  00050	e9 31 01 00 00	 jmp	 $LN12@inflateIni
$LN9@inflateIni:

; 156  :     strm->msg = Z_NULL;                 /* in case we return an error */

  00055	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0005a	48 c7 40 20 00
	00 00 00	 mov	 QWORD PTR [rax+32], 0

; 157  :     if (strm->zalloc == (alloc_func)0) {

  00062	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00067	48 83 78 30 00	 cmp	 QWORD PTR [rax+48], 0
  0006c	75 1d		 jne	 SHORT $LN8@inflateIni

; 158  :         strm->zalloc = zcalloc;

  0006e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00073	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcalloc
  0007a	48 89 41 30	 mov	 QWORD PTR [rcx+48], rax

; 159  :         strm->opaque = (voidpf)0;

  0007e	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00083	48 c7 40 40 00
	00 00 00	 mov	 QWORD PTR [rax+64], 0
$LN8@inflateIni:

; 160  :     }
; 161  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  0008b	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  00090	48 83 78 38 00	 cmp	 QWORD PTR [rax+56], 0
  00095	75 10		 jne	 SHORT $LN7@inflateIni
  00097	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  0009c	48 8d 05 00 00
	00 00		 lea	 rax, OFFSET FLAT:zcfree
  000a3	48 89 41 38	 mov	 QWORD PTR [rcx+56], rax
$LN7@inflateIni:

; 162  :     state = (struct inflate_state FAR *)
; 163  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  000a7	41 b8 48 25 00
	00		 mov	 r8d, 9544		; 00002548H
  000ad	ba 01 00 00 00	 mov	 edx, 1
  000b2	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000b7	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  000bb	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  000c0	ff 50 30	 call	 QWORD PTR [rax+48]
  000c3	48 89 44 24 20	 mov	 QWORD PTR state$[rsp], rax

; 164  :     if (state == Z_NULL) return Z_MEM_ERROR;

  000c8	48 83 7c 24 20
	00		 cmp	 QWORD PTR state$[rsp], 0
  000ce	75 0a		 jne	 SHORT $LN6@inflateIni
  000d0	b8 fc ff ff ff	 mov	 eax, -4
  000d5	e9 ac 00 00 00	 jmp	 $LN12@inflateIni
$LN6@inflateIni:

; 165  :     Tracev((stderr, "inflate: allocated\n"));
; 166  :     strm->state = (struct internal_state FAR *)state;

  000da	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  000df	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000e4	48 89 41 28	 mov	 QWORD PTR [rcx+40], rax

; 167  :     if (windowBits < 0) {

  000e8	83 7c 24 48 00	 cmp	 DWORD PTR windowBits$[rsp], 0
  000ed	7d 18		 jge	 SHORT $LN5@inflateIni

; 168  :         state->wrap = 0;

  000ef	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  000f4	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [rax+8], 0

; 169  :         windowBits = -windowBits;

  000fb	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  000ff	f7 d8		 neg	 eax
  00101	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax

; 170  :     }
; 171  :     else {

  00105	eb 24		 jmp	 SHORT $LN4@inflateIni
$LN5@inflateIni:

; 172  :         state->wrap = (windowBits >> 4) + 1;

  00107	8b 4c 24 48	 mov	 ecx, DWORD PTR windowBits$[rsp]
  0010b	c1 f9 04	 sar	 ecx, 4
  0010e	83 c1 01	 add	 ecx, 1
  00111	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00116	89 48 08	 mov	 DWORD PTR [rax+8], ecx

; 173  : #ifdef GUNZIP
; 174  :         if (windowBits < 48) windowBits &= 15;

  00119	83 7c 24 48 30	 cmp	 DWORD PTR windowBits$[rsp], 48 ; 00000030H
  0011e	7d 0b		 jge	 SHORT $LN3@inflateIni
  00120	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  00124	83 e0 0f	 and	 eax, 15
  00127	89 44 24 48	 mov	 DWORD PTR windowBits$[rsp], eax
$LN3@inflateIni:
$LN4@inflateIni:

; 175  : #endif
; 176  :     }
; 177  :     if (windowBits < 8 || windowBits > 15) {

  0012b	83 7c 24 48 08	 cmp	 DWORD PTR windowBits$[rsp], 8
  00130	7c 07		 jl	 SHORT $LN1@inflateIni
  00132	83 7c 24 48 0f	 cmp	 DWORD PTR windowBits$[rsp], 15
  00137	7e 2a		 jle	 SHORT $LN2@inflateIni
$LN1@inflateIni:

; 178  :         ZFREE(strm, state);

  00139	48 8b 54 24 20	 mov	 rdx, QWORD PTR state$[rsp]
  0013e	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00143	48 8b 49 40	 mov	 rcx, QWORD PTR [rcx+64]
  00147	48 8b 44 24 40	 mov	 rax, QWORD PTR strm$[rsp]
  0014c	ff 50 38	 call	 QWORD PTR [rax+56]

; 179  :         strm->state = Z_NULL;

  0014f	4c 8b 5c 24 40	 mov	 r11, QWORD PTR strm$[rsp]
  00154	49 c7 43 28 00
	00 00 00	 mov	 QWORD PTR [r11+40], 0

; 180  :         return Z_STREAM_ERROR;

  0015c	b8 fe ff ff ff	 mov	 eax, -2
  00161	eb 23		 jmp	 SHORT $LN12@inflateIni
$LN2@inflateIni:

; 181  :     }
; 182  :     state->wbits = (unsigned)windowBits;

  00163	48 8b 4c 24 20	 mov	 rcx, QWORD PTR state$[rsp]
  00168	8b 44 24 48	 mov	 eax, DWORD PTR windowBits$[rsp]
  0016c	89 41 28	 mov	 DWORD PTR [rcx+40], eax

; 183  :     state->window = Z_NULL;

  0016f	48 8b 44 24 20	 mov	 rax, QWORD PTR state$[rsp]
  00174	48 c7 40 38 00
	00 00 00	 mov	 QWORD PTR [rax+56], 0

; 184  :     return inflateReset(strm);

  0017c	48 8b 4c 24 40	 mov	 rcx, QWORD PTR strm$[rsp]
  00181	e8 00 00 00 00	 call	 inflateReset
$LN12@inflateIni:

; 185  : }

  00186	48 83 c4 38	 add	 rsp, 56			; 00000038H
  0018a	c3		 ret	 0
inflateInit2_ ENDP
PUBLIC	inflateInit_
;	COMDAT pdata
pdata	SEGMENT
$pdata$inflateInit_ DD imagerel $LN3
	DD	imagerel $LN3+49
	DD	imagerel $unwind$inflateInit_
pdata	ENDS
;	COMDAT xdata
xdata	SEGMENT
$unwind$inflateInit_ DD 011301H
	DD	04213H
; Function compile flags: /Odtp
xdata	ENDS
;	COMDAT inflateInit_
_TEXT	SEGMENT
strm$ = 48
version$ = 56
stream_size$ = 64
inflateInit_ PROC					; COMDAT

; 191  : {

$LN3:
  00000	44 89 44 24 18	 mov	 DWORD PTR [rsp+24], r8d
  00005	48 89 54 24 10	 mov	 QWORD PTR [rsp+16], rdx
  0000a	48 89 4c 24 08	 mov	 QWORD PTR [rsp+8], rcx
  0000f	48 83 ec 28	 sub	 rsp, 40			; 00000028H

; 192  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00013	44 8b 4c 24 40	 mov	 r9d, DWORD PTR stream_size$[rsp]
  00018	4c 8b 44 24 38	 mov	 r8, QWORD PTR version$[rsp]
  0001d	ba 0f 00 00 00	 mov	 edx, 15
  00022	48 8b 4c 24 30	 mov	 rcx, QWORD PTR strm$[rsp]
  00027	e8 00 00 00 00	 call	 inflateInit2_

; 193  : }

  0002c	48 83 c4 28	 add	 rsp, 40			; 00000028H
  00030	c3		 ret	 0
inflateInit_ ENDP
END
