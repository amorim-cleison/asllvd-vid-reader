; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\contrib\testzlib\testzlib.cpp
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB LIBCMTD
INCLUDELIB OLDNAMES

PUBLIC	?MyDoMinus64@@YAXPAT_LARGE_INTEGER@@T1@1@Z	; MyDoMinus64
; Function compile flags: /Odtp /ZI
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\contrib\testzlib\testzlib.cpp
;	COMDAT ?MyDoMinus64@@YAXPAT_LARGE_INTEGER@@T1@1@Z
_TEXT	SEGMENT
_R$ = 8							; size = 4
_A$ = 12						; size = 8
_B$ = 20						; size = 8
?MyDoMinus64@@YAXPAT_LARGE_INTEGER@@T1@1@Z PROC		; MyDoMinus64, COMDAT

; 9    : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 10   :     R->HighPart = A.HighPart - B.HighPart;

	mov	eax, DWORD PTR _A$[ebp+4]
	sub	eax, DWORD PTR _B$[ebp+4]
	mov	ecx, DWORD PTR _R$[ebp]
	mov	DWORD PTR [ecx+4], eax

; 11   :     if (A.LowPart >= B.LowPart)

	mov	eax, DWORD PTR _A$[ebp]
	cmp	eax, DWORD PTR _B$[ebp]
	jb	SHORT $LN2@MyDoMinus6

; 12   :         R->LowPart = A.LowPart - B.LowPart;

	mov	eax, DWORD PTR _A$[ebp]
	sub	eax, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _R$[ebp]
	mov	DWORD PTR [ecx], eax

; 13   :     else

	jmp	SHORT $LN3@MyDoMinus6
$LN2@MyDoMinus6:

; 14   :     {
; 15   :         R->LowPart = A.LowPart - B.LowPart;

	mov	eax, DWORD PTR _A$[ebp]
	sub	eax, DWORD PTR _B$[ebp]
	mov	ecx, DWORD PTR _R$[ebp]
	mov	DWORD PTR [ecx], eax

; 16   :         R->HighPart --;

	mov	eax, DWORD PTR _R$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	sub	ecx, 1
	mov	edx, DWORD PTR _R$[ebp]
	mov	DWORD PTR [edx+4], ecx
$LN3@MyDoMinus6:

; 17   :     }
; 18   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?MyDoMinus64@@YAXPAT_LARGE_INTEGER@@T1@1@Z ENDP		; MyDoMinus64
_TEXT	ENDS
PUBLIC	?myGetRDTSC32@@YAXPAT_LARGE_INTEGER@@@Z		; myGetRDTSC32
; Function compile flags: /Odtp /ZI
;	COMDAT ?myGetRDTSC32@@YAXPAT_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
_dwEax$ = -8						; size = 4
_dwEdx$ = -4						; size = 4
_pbeginTime64$ = 8					; size = 4
?myGetRDTSC32@@YAXPAT_LARGE_INTEGER@@@Z PROC		; myGetRDTSC32, COMDAT

; 40   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 72					; 00000048H
	push	ebx
	push	esi
	push	edi

; 41   :     DWORD dwEdx,dwEax;
; 42   :     _asm
; 43   :     {
; 44   :         rdtsc

	rdtsc

; 45   :         mov dwEax,eax

	mov	DWORD PTR _dwEax$[ebp], eax

; 46   :         mov dwEdx,edx

	mov	DWORD PTR _dwEdx$[ebp], edx

; 47   :     }
; 48   :     pbeginTime64->LowPart=dwEax;

	mov	eax, DWORD PTR _pbeginTime64$[ebp]
	mov	ecx, DWORD PTR _dwEax$[ebp]
	mov	DWORD PTR [eax], ecx

; 49   :     pbeginTime64->HighPart=dwEdx;

	mov	eax, DWORD PTR _pbeginTime64$[ebp]
	mov	ecx, DWORD PTR _dwEdx$[ebp]
	mov	DWORD PTR [eax+4], ecx

; 50   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?myGetRDTSC32@@YAXPAT_LARGE_INTEGER@@@Z ENDP		; myGetRDTSC32
_TEXT	ENDS
PUBLIC	?BeginCountRdtsc@@YAXPAT_LARGE_INTEGER@@@Z	; BeginCountRdtsc
; Function compile flags: /Odtp /ZI
;	COMDAT ?BeginCountRdtsc@@YAXPAT_LARGE_INTEGER@@@Z
_TEXT	SEGMENT
_pbeginTime64$ = 8					; size = 4
?BeginCountRdtsc@@YAXPAT_LARGE_INTEGER@@@Z PROC		; BeginCountRdtsc, COMDAT

; 53   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 54   :     myGetRDTSC32(pbeginTime64);

	mov	eax, DWORD PTR _pbeginTime64$[ebp]
	push	eax
	call	?myGetRDTSC32@@YAXPAT_LARGE_INTEGER@@@Z	; myGetRDTSC32
	add	esp, 4

; 55   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BeginCountRdtsc@@YAXPAT_LARGE_INTEGER@@@Z ENDP		; BeginCountRdtsc
_TEXT	ENDS
PUBLIC	?GetResRdtsc@@YA?AT_LARGE_INTEGER@@T1@H@Z	; GetResRdtsc
; Function compile flags: /Odtp /ZI
;	COMDAT ?GetResRdtsc@@YA?AT_LARGE_INTEGER@@T1@H@Z
_TEXT	SEGMENT
_endTime64$ = -16					; size = 8
_LIres$ = -8						; size = 8
_beginTime64$ = 8					; size = 8
_fComputeTimeQueryPerf$ = 16				; size = 4
?GetResRdtsc@@YA?AT_LARGE_INTEGER@@T1@H@Z PROC		; GetResRdtsc, COMDAT

; 58   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 80					; 00000050H
	push	ebx
	push	esi
	push	edi

; 59   :     LARGE_INTEGER LIres,endTime64;
; 60   :     myGetRDTSC32(&endTime64);

	lea	eax, DWORD PTR _endTime64$[ebp]
	push	eax
	call	?myGetRDTSC32@@YAXPAT_LARGE_INTEGER@@@Z	; myGetRDTSC32
	add	esp, 4

; 61   : 
; 62   :     LIres.LowPart=LIres.HighPart=0;

	mov	DWORD PTR _LIres$[ebp+4], 0
	mov	eax, DWORD PTR _LIres$[ebp+4]
	mov	DWORD PTR _LIres$[ebp], eax

; 63   :     MyDoMinus64(&LIres,endTime64,beginTime64);

	mov	eax, DWORD PTR _beginTime64$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _beginTime64$[ebp]
	push	ecx
	mov	edx, DWORD PTR _endTime64$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _endTime64$[ebp]
	push	eax
	lea	ecx, DWORD PTR _LIres$[ebp]
	push	ecx
	call	?MyDoMinus64@@YAXPAT_LARGE_INTEGER@@T1@1@Z ; MyDoMinus64
	add	esp, 20					; 00000014H

; 64   :     return LIres;

	mov	eax, DWORD PTR _LIres$[ebp]
	mov	edx, DWORD PTR _LIres$[ebp+4]

; 65   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetResRdtsc@@YA?AT_LARGE_INTEGER@@T1@H@Z ENDP		; GetResRdtsc
_TEXT	ENDS
PUBLIC	?BeginCountPerfCounter@@YAXPAT_LARGE_INTEGER@@H@Z ; BeginCountPerfCounter
EXTRN	__imp__GetTickCount@0:PROC
EXTRN	__imp__QueryPerformanceCounter@4:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?BeginCountPerfCounter@@YAXPAT_LARGE_INTEGER@@H@Z
_TEXT	SEGMENT
_pbeginTime64$ = 8					; size = 4
_fComputeTimeQueryPerf$ = 12				; size = 4
?BeginCountPerfCounter@@YAXPAT_LARGE_INTEGER@@H@Z PROC	; BeginCountPerfCounter, COMDAT

; 85   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 86   :     if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(pbeginTime64)))

	cmp	DWORD PTR _fComputeTimeQueryPerf$[ebp], 0
	je	SHORT $LN1@BeginCount
	mov	eax, DWORD PTR _pbeginTime64$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	test	eax, eax
	jne	SHORT $LN3@BeginCount
$LN1@BeginCount:

; 87   :     {
; 88   :         pbeginTime64->LowPart = GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	ecx, DWORD PTR _pbeginTime64$[ebp]
	mov	DWORD PTR [ecx], eax

; 89   :         pbeginTime64->HighPart = 0;

	mov	eax, DWORD PTR _pbeginTime64$[ebp]
	mov	DWORD PTR [eax+4], 0
$LN3@BeginCount:

; 90   :     }
; 91   : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?BeginCountPerfCounter@@YAXPAT_LARGE_INTEGER@@H@Z ENDP	; BeginCountPerfCounter
_TEXT	ENDS
PUBLIC	_Int64ShrlMod32@12
PUBLIC	?GetMsecSincePerfCounter@@YAKT_LARGE_INTEGER@@H@Z ; GetMsecSincePerfCounter
EXTRN	__imp__QueryPerformanceFrequency@4:PROC
; Function compile flags: /Odtp /ZI
;	COMDAT ?GetMsecSincePerfCounter@@YAKT_LARGE_INTEGER@@H@Z
_TEXT	SEGMENT
_dwRet$ = -48						; size = 4
_dwLog$ = -44						; size = 4
_tickSecShifted$ = -40					; size = 8
_ticksShifted$ = -32					; size = 8
_ticks$ = -24						; size = 8
_ticksPerSecond$ = -16					; size = 8
_endTime64$ = -8					; size = 8
_beginTime64$ = 8					; size = 8
_fComputeTimeQueryPerf$ = 16				; size = 4
?GetMsecSincePerfCounter@@YAKT_LARGE_INTEGER@@H@Z PROC	; GetMsecSincePerfCounter, COMDAT

; 94   : {

	push	ebp
	mov	ebp, esp
	sub	esp, 112				; 00000070H
	push	ebx
	push	esi
	push	edi

; 95   :     LARGE_INTEGER endTime64,ticksPerSecond,ticks;
; 96   :     DWORDLONG ticksShifted,tickSecShifted;
; 97   :     DWORD dwLog=16+0;

	mov	DWORD PTR _dwLog$[ebp], 16		; 00000010H

; 98   :     DWORD dwRet;
; 99   :     if ((!fComputeTimeQueryPerf) || (!QueryPerformanceCounter(&endTime64)))

	cmp	DWORD PTR _fComputeTimeQueryPerf$[ebp], 0
	je	SHORT $LN2@GetMsecSin
	lea	eax, DWORD PTR _endTime64$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceCounter@4
	test	eax, eax
	jne	SHORT $LN3@GetMsecSin
$LN2@GetMsecSin:

; 100  :         dwRet = (GetTickCount() - beginTime64.LowPart)*1;

	call	DWORD PTR __imp__GetTickCount@0
	sub	eax, DWORD PTR _beginTime64$[ebp]
	mov	DWORD PTR _dwRet$[ebp], eax

; 101  :     else

	jmp	SHORT $LN1@GetMsecSin
$LN3@GetMsecSin:

; 102  :     {
; 103  :         MyDoMinus64(&ticks,endTime64,beginTime64);

	mov	eax, DWORD PTR _beginTime64$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _beginTime64$[ebp]
	push	ecx
	mov	edx, DWORD PTR _endTime64$[ebp+4]
	push	edx
	mov	eax, DWORD PTR _endTime64$[ebp]
	push	eax
	lea	ecx, DWORD PTR _ticks$[ebp]
	push	ecx
	call	?MyDoMinus64@@YAXPAT_LARGE_INTEGER@@T1@1@Z ; MyDoMinus64
	add	esp, 20					; 00000014H

; 104  :         QueryPerformanceFrequency(&ticksPerSecond);

	lea	eax, DWORD PTR _ticksPerSecond$[ebp]
	push	eax
	call	DWORD PTR __imp__QueryPerformanceFrequency@4

; 105  : 
; 106  :     
; 107  :         {
; 108  :             ticksShifted = Int64ShrlMod32(*(DWORDLONG*)&ticks,dwLog);

	mov	eax, DWORD PTR _dwLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ticks$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _ticks$[ebp]
	push	edx
	call	_Int64ShrlMod32@12
	mov	DWORD PTR _ticksShifted$[ebp], eax
	mov	DWORD PTR _ticksShifted$[ebp+4], edx

; 109  :             tickSecShifted = Int64ShrlMod32(*(DWORDLONG*)&ticksPerSecond,dwLog);

	mov	eax, DWORD PTR _dwLog$[ebp]
	push	eax
	mov	ecx, DWORD PTR _ticksPerSecond$[ebp+4]
	push	ecx
	mov	edx, DWORD PTR _ticksPerSecond$[ebp]
	push	edx
	call	_Int64ShrlMod32@12
	mov	DWORD PTR _tickSecShifted$[ebp], eax
	mov	DWORD PTR _tickSecShifted$[ebp+4], edx

; 110  :         
; 111  :         } 
; 112  : 
; 113  :         dwRet = (DWORD)((((DWORD)ticksShifted)*1000)/(DWORD)(tickSecShifted));

	mov	eax, DWORD PTR _ticksShifted$[ebp]
	imul	eax, 1000				; 000003e8H
	mov	ecx, DWORD PTR _tickSecShifted$[ebp]
	xor	edx, edx
	div	ecx
	mov	DWORD PTR _dwRet$[ebp], eax

; 114  :         dwRet *=1;

	mov	eax, DWORD PTR _dwRet$[ebp]
	mov	DWORD PTR _dwRet$[ebp], eax
$LN1@GetMsecSin:

; 115  :     }
; 116  :     return dwRet;

	mov	eax, DWORD PTR _dwRet$[ebp]

; 117  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?GetMsecSincePerfCounter@@YAKT_LARGE_INTEGER@@H@Z ENDP	; GetMsecSincePerfCounter
; Function compile flags: /Odtp /ZI
; File c:\program files\microsoft sdks\windows\v6.0a\include\winnt.h
_TEXT	ENDS
;	COMDAT _Int64ShrlMod32@12
_TEXT	SEGMENT
_Value$ = 8						; size = 8
_ShiftCount$ = 16					; size = 4
_Int64ShrlMod32@12 PROC					; COMDAT

; 716  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 64					; 00000040H
	push	ebx
	push	esi
	push	edi

; 717  :     __asm    {
; 718  :         mov     ecx, ShiftCount

	mov	ecx, DWORD PTR _ShiftCount$[ebp]

; 719  :         mov     eax, dword ptr [Value]

	mov	eax, DWORD PTR _Value$[ebp]

; 720  :         mov     edx, dword ptr [Value+4]

	mov	edx, DWORD PTR _Value$[ebp+4]

; 721  :         shrd    eax, edx, cl

	shrd	eax, edx, cl

; 722  :         shr     edx, cl

	shr	edx, cl

; 723  :     }
; 724  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	12					; 0000000cH
_Int64ShrlMod32@12 ENDP
_TEXT	ENDS
PUBLIC	??_C@_02JDPG@rb?$AA@				; `string'
PUBLIC	?ReadFileMemory@@YAHPBDPAJPAPAX@Z		; ReadFileMemory
EXTRN	_fclose:PROC
EXTRN	_fread:PROC
EXTRN	_malloc:PROC
EXTRN	_ftell:PROC
EXTRN	_fseek:PROC
EXTRN	_fopen:PROC
;	COMDAT ??_C@_02JDPG@rb?$AA@
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\contrib\testzlib\testzlib.cpp
CONST	SEGMENT
??_C@_02JDPG@rb?$AA@ DB 'rb', 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT ?ReadFileMemory@@YAHPBDPAJPAPAX@Z
_TEXT	SEGMENT
_retVal$ = -12						; size = 4
_ptr$ = -8						; size = 4
_stream$ = -4						; size = 4
_filename$ = 8						; size = 4
_plFileSize$ = 12					; size = 4
_pFilePtr$ = 16						; size = 4
?ReadFileMemory@@YAHPBDPAJPAPAX@Z PROC			; ReadFileMemory, COMDAT

; 120  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 76					; 0000004cH
	push	ebx
	push	esi
	push	edi

; 121  :     FILE* stream;
; 122  :     void* ptr;
; 123  :     int retVal=1;

	mov	DWORD PTR _retVal$[ebp], 1

; 124  :     stream=fopen(filename, "rb");

	push	OFFSET ??_C@_02JDPG@rb?$AA@
	mov	eax, DWORD PTR _filename$[ebp]
	push	eax
	call	_fopen
	add	esp, 8
	mov	DWORD PTR _stream$[ebp], eax

; 125  :     if (stream==NULL)

	cmp	DWORD PTR _stream$[ebp], 0
	jne	SHORT $LN4@ReadFileMe

; 126  :         return 0;

	xor	eax, eax
	jmp	$LN5@ReadFileMe
$LN4@ReadFileMe:

; 127  : 
; 128  :     fseek(stream,0,SEEK_END);

	push	2
	push	0
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 129  : 
; 130  :     *plFileSize=ftell(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_ftell
	add	esp, 4
	mov	ecx, DWORD PTR _plFileSize$[ebp]
	mov	DWORD PTR [ecx], eax

; 131  :     fseek(stream,0,SEEK_SET);

	push	0
	push	0
	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_fseek
	add	esp, 12					; 0000000cH

; 132  :     ptr=malloc((*plFileSize)+1);

	mov	eax, DWORD PTR _plFileSize$[ebp]
	mov	ecx, DWORD PTR [eax]
	add	ecx, 1
	push	ecx
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _ptr$[ebp], eax

; 133  :     if (ptr==NULL)

	cmp	DWORD PTR _ptr$[ebp], 0
	jne	SHORT $LN3@ReadFileMe

; 134  :         retVal=0;

	mov	DWORD PTR _retVal$[ebp], 0

; 135  :     else

	jmp	SHORT $LN2@ReadFileMe
$LN3@ReadFileMe:

; 136  :     {
; 137  :         if (fread(ptr, 1, *plFileSize,stream) != (*plFileSize))

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	mov	ecx, DWORD PTR _plFileSize$[ebp]
	mov	edx, DWORD PTR [ecx]
	push	edx
	push	1
	mov	eax, DWORD PTR _ptr$[ebp]
	push	eax
	call	_fread
	add	esp, 16					; 00000010H
	mov	ecx, DWORD PTR _plFileSize$[ebp]
	cmp	eax, DWORD PTR [ecx]
	je	SHORT $LN2@ReadFileMe

; 138  :             retVal=0;

	mov	DWORD PTR _retVal$[ebp], 0
$LN2@ReadFileMe:

; 139  :     }
; 140  :     fclose(stream);

	mov	eax, DWORD PTR _stream$[ebp]
	push	eax
	call	_fclose
	add	esp, 4

; 141  :     *pFilePtr=ptr;

	mov	eax, DWORD PTR _pFilePtr$[ebp]
	mov	ecx, DWORD PTR _ptr$[ebp]
	mov	DWORD PTR [eax], ecx

; 142  :     return retVal;

	mov	eax, DWORD PTR _retVal$[ebp]
$LN5@ReadFileMe:

; 143  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
?ReadFileMemory@@YAHPBDPAJPAPAX@Z ENDP			; ReadFileMemory
_TEXT	ENDS
PUBLIC	??_C@_0M@OPBGFCFH@compare?5ok?6?$AA@		; `string'
PUBLIC	??_C@_0BO@KIEBAEAI@uncpr?5?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@BCIIDHNB@uncpr?5?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@ ; `string'
PUBLIC	??_C@_0CI@CKJMABEN@total?5uncompress?5size?5?$DN?5?$CFu?0?5in?5?$CF@ ; `string'
PUBLIC	??_C@_0BO@GDINCLJG@defcpr?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@ ; `string'
PUBLIC	??_C@_0CD@DEFEHAGJ@defcpr?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@ ; `string'
PUBLIC	??_C@_0BJ@MCACADLP@time?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5sec?6?$AA@ ; `string'
PUBLIC	__real@408f400000000000
PUBLIC	??_C@_0CG@INFMECPM@total?5compress?5size?5?$DN?5?$CFu?0?5in?5?$CFu?5@ ; `string'
PUBLIC	??_C@_05GDHACFMB@1?42?43?$AA@			; `string'
PUBLIC	??_C@_0BI@PFOKBMGM@file?5?$CFs?5read?0?5?$CFu?5bytes?6?$AA@ ; `string'
PUBLIC	??_C@_0BC@PAKDIMBO@error?5reading?5?$CFs?6?$AA@	; `string'
PUBLIC	??_C@_0FA@JGDJCMKF@run?5TestZlib?5?$DMFile?$DO?5?$FLBlockSizeCo@ ; `string'
PUBLIC	_main
EXTRN	_memcmp:PROC
EXTRN	_inflateEnd@4:PROC
EXTRN	_inflate@8:PROC
EXTRN	_inflateInit_@12:PROC
EXTRN	_realloc:PROC
EXTRN	_deflateEnd@4:PROC
EXTRN	_deflate@8:PROC
EXTRN	_deflateInit_@16:PROC
EXTRN	_memset:PROC
EXTRN	_atol:PROC
EXTRN	_printf:PROC
EXTRN	_uncompress@16:PROC
EXTRN	__fltused:DWORD
;	COMDAT ??_C@_0M@OPBGFCFH@compare?5ok?6?$AA@
CONST	SEGMENT
??_C@_0M@OPBGFCFH@compare?5ok?6?$AA@ DB 'compare ok', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@KIEBAEAI@uncpr?5?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@
CONST	SEGMENT
??_C@_0BO@KIEBAEAI@uncpr?5?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@ DB 'un'
	DB	'cpr  result rdtsc = %I64x', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@BCIIDHNB@uncpr?5?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@
CONST	SEGMENT
??_C@_0CD@BCIIDHNB@uncpr?5?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@ DB 'u'
	DB	'ncpr  time QP = %u msec = %f sec', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CI@CKJMABEN@total?5uncompress?5size?5?$DN?5?$CFu?0?5in?5?$CF@
CONST	SEGMENT
??_C@_0CI@CKJMABEN@total?5uncompress?5size?5?$DN?5?$CFu?0?5in?5?$CF@ DB 't'
	DB	'otal uncompress size = %u, in %u step', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BO@GDINCLJG@defcpr?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@
CONST	SEGMENT
??_C@_0BO@GDINCLJG@defcpr?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@ DB 'def'
	DB	'cpr result rdtsc = %I64x', 0aH, 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0CD@DEFEHAGJ@defcpr?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@
CONST	SEGMENT
??_C@_0CD@DEFEHAGJ@defcpr?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@ DB 'd'
	DB	'efcpr time QP = %u msec = %f sec', 0aH, 00H	; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@MCACADLP@time?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5sec?6?$AA@
CONST	SEGMENT
??_C@_0BJ@MCACADLP@time?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5sec?6?$AA@ DB 't'
	DB	'ime = %u msec = %f sec', 0aH, 00H		; `string'
CONST	ENDS
;	COMDAT __real@408f400000000000
CONST	SEGMENT
__real@408f400000000000 DQ 0408f400000000000r	; 1000
CONST	ENDS
;	COMDAT ??_C@_0CG@INFMECPM@total?5compress?5size?5?$DN?5?$CFu?0?5in?5?$CFu?5@
CONST	SEGMENT
??_C@_0CG@INFMECPM@total?5compress?5size?5?$DN?5?$CFu?0?5in?5?$CFu?5@ DB 't'
	DB	'otal compress size = %u, in %u step', 0aH, 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_05GDHACFMB@1?42?43?$AA@
CONST	SEGMENT
??_C@_05GDHACFMB@1?42?43?$AA@ DB '1.2.3', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BI@PFOKBMGM@file?5?$CFs?5read?0?5?$CFu?5bytes?6?$AA@
CONST	SEGMENT
??_C@_0BI@PFOKBMGM@file?5?$CFs?5read?0?5?$CFu?5bytes?6?$AA@ DB 'file %s r'
	DB	'ead, %u bytes', 0aH, 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BC@PAKDIMBO@error?5reading?5?$CFs?6?$AA@
CONST	SEGMENT
??_C@_0BC@PAKDIMBO@error?5reading?5?$CFs?6?$AA@ DB 'error reading %s', 0aH
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0FA@JGDJCMKF@run?5TestZlib?5?$DMFile?$DO?5?$FLBlockSizeCo@
CONST	SEGMENT
??_C@_0FA@JGDJCMKF@run?5TestZlib?5?$DMFile?$DO?5?$FLBlockSizeCo@ DB 'run '
	DB	'TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [co'
	DB	'mpres. level]', 0aH, 00H			; `string'
; Function compile flags: /Odtp /ZI
CONST	ENDS
;	COMDAT _main
_TEXT	SEGMENT
tv452 = -320						; size = 8
tv413 = -320						; size = 8
tv356 = -320						; size = 8
tv349 = -320						; size = 8
tv230 = -316						; size = 4
tv145 = -316						; size = 4
$T64185 = -312						; size = 8
$T64188 = -304						; size = 8
_all_read_before$64116 = -232				; size = 4
_step$64110 = -228					; size = 4
_lOrigDone$64109 = -224					; size = 4
_lOrigToDo$64108 = -220					; size = 4
_ret$64107 = -216					; size = 4
_zcpr$64106 = -212					; size = 56
_all_read_before$64096 = -156				; size = 4
_step$64089 = -152					; size = 4
_lOrigDone$64088 = -148					; size = 4
_lOrigToDo$64087 = -144					; size = 4
_ret$64086 = -140					; size = 4
_zcpr$64085 = -136					; size = 56
_dwResRdtsc$ = -80					; size = 8
_li_rdtsc$ = -72					; size = 8
_li_qp$ = -64						; size = 8
_dwMsecQP$ = -56					; size = 4
_dwGetTick$ = -52					; size = 4
_lSizeUncpr$ = -48					; size = 4
_lSizeCpr$ = -44					; size = 4
_UncprPtr$ = -40					; size = 4
_CprPtr$ = -36						; size = 4
_lCompressedSize$ = -32					; size = 4
_lBufferSizeUncpr$ = -28				; size = 4
_lBufferSizeCpr$ = -24					; size = 4
_FilePtr$ = -20						; size = 4
_lFileSize$ = -16					; size = 4
_cprLevel$ = -12					; size = 4
_BlockSizeUncompress$ = -8				; size = 4
_BlockSizeCompress$ = -4				; size = 4
_argc$ = 8						; size = 4
_argv$ = 12						; size = 4
_main	PROC						; COMDAT

; 146  : {

	push	ebp
	mov	ebp, esp
	sub	esp, 320				; 00000140H
	push	ebx
	push	esi
	push	edi

; 147  :     int BlockSizeCompress=0x8000;

	mov	DWORD PTR _BlockSizeCompress$[ebp], 32768 ; 00008000H

; 148  :     int BlockSizeUncompress=0x8000;

	mov	DWORD PTR _BlockSizeUncompress$[ebp], 32768 ; 00008000H

; 149  :     int cprLevel=Z_DEFAULT_COMPRESSION ;

	mov	DWORD PTR _cprLevel$[ebp], -1

; 150  :     long lFileSize;
; 151  :     unsigned char* FilePtr;
; 152  :     long lBufferSizeCpr;
; 153  :     long lBufferSizeUncpr;
; 154  :     long lCompressedSize=0;

	mov	DWORD PTR _lCompressedSize$[ebp], 0

; 155  :     unsigned char* CprPtr;
; 156  :     unsigned char* UncprPtr;
; 157  :     long lSizeCpr,lSizeUncpr;
; 158  :     DWORD dwGetTick,dwMsecQP;
; 159  :     LARGE_INTEGER li_qp,li_rdtsc,dwResRdtsc;
; 160  : 
; 161  : 	//uncompress(uncompressed_buffer, &uncompressed_size, compressed_buffer, compressed_size);
; 162  : 	uncompress(NULL, NULL, NULL, 0);

	push	0
	push	0
	push	0
	push	0
	call	_uncompress@16

; 163  : 
; 164  :     if (argc<=1)

	cmp	DWORD PTR _argc$[ebp], 1
	jg	SHORT $LN14@main

; 165  :     {
; 166  :         printf("run TestZlib <File> [BlockSizeCompress] [BlockSizeUncompress] [compres. level]\n");

	push	OFFSET ??_C@_0FA@JGDJCMKF@run?5TestZlib?5?$DMFile?$DO?5?$FLBlockSizeCo@
	call	_printf
	add	esp, 4

; 167  :         return 0;

	xor	eax, eax
	jmp	$LN15@main
$LN14@main:

; 168  :     }
; 169  : 
; 170  :     if (ReadFileMemory(argv[1],&lFileSize,(void **)(&FilePtr))==0)

	lea	eax, DWORD PTR _FilePtr$[ebp]
	push	eax
	lea	ecx, DWORD PTR _lFileSize$[ebp]
	push	ecx
	mov	edx, DWORD PTR _argv$[ebp]
	mov	eax, DWORD PTR [edx+4]
	push	eax
	call	?ReadFileMemory@@YAHPBDPAJPAPAX@Z	; ReadFileMemory
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN13@main

; 171  :     {
; 172  :         printf("error reading %s\n",argv[1]);

	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+4]
	push	ecx
	push	OFFSET ??_C@_0BC@PAKDIMBO@error?5reading?5?$CFs?6?$AA@
	call	_printf
	add	esp, 8

; 173  :         return 1;

	mov	eax, 1
	jmp	$LN15@main
	jmp	SHORT $LN12@main
$LN13@main:

; 174  :     }
; 175  :     else printf("file %s read, %u bytes\n",argv[1],lFileSize);

	mov	eax, DWORD PTR _lFileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _argv$[ebp]
	mov	edx, DWORD PTR [ecx+4]
	push	edx
	push	OFFSET ??_C@_0BI@PFOKBMGM@file?5?$CFs?5read?0?5?$CFu?5bytes?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH
$LN12@main:

; 176  : 
; 177  :     if (argc>=3)

	cmp	DWORD PTR _argc$[ebp], 3
	jl	SHORT $LN11@main

; 178  :         BlockSizeCompress=atol(argv[2]);

	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+8]
	push	ecx
	call	_atol
	add	esp, 4
	mov	DWORD PTR _BlockSizeCompress$[ebp], eax
$LN11@main:

; 179  : 
; 180  :     if (argc>=4)

	cmp	DWORD PTR _argc$[ebp], 4
	jl	SHORT $LN10@main

; 181  :         BlockSizeUncompress=atol(argv[3]);

	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+12]
	push	ecx
	call	_atol
	add	esp, 4
	mov	DWORD PTR _BlockSizeUncompress$[ebp], eax
$LN10@main:

; 182  : 
; 183  :     if (argc>=5)

	cmp	DWORD PTR _argc$[ebp], 5
	jl	SHORT $LN9@main

; 184  :         cprLevel=(int)atol(argv[4]);

	mov	eax, DWORD PTR _argv$[ebp]
	mov	ecx, DWORD PTR [eax+16]
	push	ecx
	call	_atol
	add	esp, 4
	mov	DWORD PTR _cprLevel$[ebp], eax
$LN9@main:

; 185  : 
; 186  :     lBufferSizeCpr = lFileSize + (lFileSize/0x10) + 0x200;

	mov	eax, DWORD PTR _lFileSize$[ebp]
	cdq
	and	edx, 15					; 0000000fH
	add	eax, edx
	sar	eax, 4
	mov	ecx, DWORD PTR _lFileSize$[ebp]
	lea	edx, DWORD PTR [ecx+eax+512]
	mov	DWORD PTR _lBufferSizeCpr$[ebp], edx

; 187  :     lBufferSizeUncpr = lBufferSizeCpr;

	mov	eax, DWORD PTR _lBufferSizeCpr$[ebp]
	mov	DWORD PTR _lBufferSizeUncpr$[ebp], eax

; 188  : 
; 189  :     CprPtr=(unsigned char*)malloc(lBufferSizeCpr + BlockSizeCompress);

	mov	eax, DWORD PTR _lBufferSizeCpr$[ebp]
	add	eax, DWORD PTR _BlockSizeCompress$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _CprPtr$[ebp], eax

; 190  : 
; 191  :     BeginCountPerfCounter(&li_qp,TRUE);

	push	1
	lea	eax, DWORD PTR _li_qp$[ebp]
	push	eax
	call	?BeginCountPerfCounter@@YAXPAT_LARGE_INTEGER@@H@Z ; BeginCountPerfCounter
	add	esp, 8

; 192  :     dwGetTick=GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _dwGetTick$[ebp], eax

; 193  :     BeginCountRdtsc(&li_rdtsc);

	lea	eax, DWORD PTR _li_rdtsc$[ebp]
	push	eax
	call	?BeginCountRdtsc@@YAXPAT_LARGE_INTEGER@@@Z ; BeginCountRdtsc
	add	esp, 4

; 194  :     {
; 195  :         z_stream zcpr;
; 196  :         int ret=Z_OK;

	mov	DWORD PTR _ret$64086[ebp], 0

; 197  :         long lOrigToDo = lFileSize;

	mov	eax, DWORD PTR _lFileSize$[ebp]
	mov	DWORD PTR _lOrigToDo$64087[ebp], eax

; 198  :         long lOrigDone = 0;

	mov	DWORD PTR _lOrigDone$64088[ebp], 0

; 199  :         int step=0;

	mov	DWORD PTR _step$64089[ebp], 0

; 200  :         memset(&zcpr,0,sizeof(z_stream));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _zcpr$64085[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 201  :         deflateInit(&zcpr,cprLevel);

	push	56					; 00000038H
	push	OFFSET ??_C@_05GDHACFMB@1?42?43?$AA@
	mov	eax, DWORD PTR _cprLevel$[ebp]
	push	eax
	lea	ecx, DWORD PTR _zcpr$64085[ebp]
	push	ecx
	call	_deflateInit_@16

; 202  : 
; 203  :         zcpr.next_in = FilePtr;

	mov	eax, DWORD PTR _FilePtr$[ebp]
	mov	DWORD PTR _zcpr$64085[ebp], eax

; 204  :         zcpr.next_out = CprPtr;

	mov	eax, DWORD PTR _CprPtr$[ebp]
	mov	DWORD PTR _zcpr$64085[ebp+12], eax
$LN8@main:

; 205  : 
; 206  : 
; 207  :         do
; 208  :         {
; 209  :             long all_read_before = zcpr.total_in;

	mov	eax, DWORD PTR _zcpr$64085[ebp+8]
	mov	DWORD PTR _all_read_before$64096[ebp], eax

; 210  :             zcpr.avail_in = min(lOrigToDo,BlockSizeCompress);

	mov	eax, DWORD PTR _lOrigToDo$64087[ebp]
	cmp	eax, DWORD PTR _BlockSizeCompress$[ebp]
	jge	SHORT $LN17@main
	mov	ecx, DWORD PTR _lOrigToDo$64087[ebp]
	mov	DWORD PTR tv145[ebp], ecx
	jmp	SHORT $LN18@main
$LN17@main:
	mov	edx, DWORD PTR _BlockSizeCompress$[ebp]
	mov	DWORD PTR tv145[ebp], edx
$LN18@main:
	mov	eax, DWORD PTR tv145[ebp]
	mov	DWORD PTR _zcpr$64085[ebp+4], eax

; 211  :             zcpr.avail_out = BlockSizeCompress;

	mov	eax, DWORD PTR _BlockSizeCompress$[ebp]
	mov	DWORD PTR _zcpr$64085[ebp+16], eax

; 212  :             ret=deflate(&zcpr,(zcpr.avail_in==lOrigToDo) ? Z_FINISH : Z_SYNC_FLUSH);

	mov	eax, DWORD PTR _zcpr$64085[ebp+4]
	xor	ecx, ecx
	cmp	eax, DWORD PTR _lOrigToDo$64087[ebp]
	sete	cl
	lea	ecx, DWORD PTR [ecx+ecx+2]
	push	ecx
	lea	edx, DWORD PTR _zcpr$64085[ebp]
	push	edx
	call	_deflate@8
	mov	DWORD PTR _ret$64086[ebp], eax

; 213  :             lOrigDone += (zcpr.total_in-all_read_before);

	mov	eax, DWORD PTR _zcpr$64085[ebp+8]
	sub	eax, DWORD PTR _all_read_before$64096[ebp]
	add	eax, DWORD PTR _lOrigDone$64088[ebp]
	mov	DWORD PTR _lOrigDone$64088[ebp], eax

; 214  :             lOrigToDo -= (zcpr.total_in-all_read_before);

	mov	eax, DWORD PTR _zcpr$64085[ebp+8]
	sub	eax, DWORD PTR _all_read_before$64096[ebp]
	mov	ecx, DWORD PTR _lOrigToDo$64087[ebp]
	sub	ecx, eax
	mov	DWORD PTR _lOrigToDo$64087[ebp], ecx

; 215  :             step++;

	mov	eax, DWORD PTR _step$64089[ebp]
	add	eax, 1
	mov	DWORD PTR _step$64089[ebp], eax

; 216  :         } while (ret==Z_OK);

	cmp	DWORD PTR _ret$64086[ebp], 0
	je	$LN8@main

; 217  : 
; 218  :         lSizeCpr=zcpr.total_out;

	mov	eax, DWORD PTR _zcpr$64085[ebp+20]
	mov	DWORD PTR _lSizeCpr$[ebp], eax

; 219  :         deflateEnd(&zcpr);

	lea	eax, DWORD PTR _zcpr$64085[ebp]
	push	eax
	call	_deflateEnd@4

; 220  :         dwGetTick=GetTickCount()-dwGetTick;

	call	DWORD PTR __imp__GetTickCount@0
	sub	eax, DWORD PTR _dwGetTick$[ebp]
	mov	DWORD PTR _dwGetTick$[ebp], eax

; 221  :         dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);

	push	1
	mov	eax, DWORD PTR _li_qp$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _li_qp$[ebp]
	push	ecx
	call	?GetMsecSincePerfCounter@@YAKT_LARGE_INTEGER@@H@Z ; GetMsecSincePerfCounter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwMsecQP$[ebp], eax

; 222  :         dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);

	push	1
	mov	eax, DWORD PTR _li_rdtsc$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _li_rdtsc$[ebp]
	push	ecx
	call	?GetResRdtsc@@YA?AT_LARGE_INTEGER@@T1@H@Z ; GetResRdtsc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T64185[ebp], eax
	mov	DWORD PTR $T64185[ebp+4], edx
	mov	edx, DWORD PTR $T64185[ebp]
	mov	DWORD PTR _dwResRdtsc$[ebp], edx
	mov	eax, DWORD PTR $T64185[ebp+4]
	mov	DWORD PTR _dwResRdtsc$[ebp+4], eax

; 223  :         printf("total compress size = %u, in %u step\n",lSizeCpr,step);

	mov	eax, DWORD PTR _step$64089[ebp]
	push	eax
	mov	ecx, DWORD PTR _lSizeCpr$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CG@INFMECPM@total?5compress?5size?5?$DN?5?$CFu?0?5in?5?$CFu?5@
	call	_printf
	add	esp, 12					; 0000000cH

; 224  :         printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);

	mov	eax, DWORD PTR _dwGetTick$[ebp]
	mov	DWORD PTR tv349[ebp], eax
	mov	DWORD PTR tv349[ebp+4], 0
	fild	QWORD PTR tv349[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _dwGetTick$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@MCACADLP@time?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5sec?6?$AA@
	call	_printf
	add	esp, 16					; 00000010H

; 225  :         printf("defcpr time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);

	mov	eax, DWORD PTR _dwMsecQP$[ebp]
	mov	DWORD PTR tv356[ebp], eax
	mov	DWORD PTR tv356[ebp+4], 0
	fild	QWORD PTR tv356[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _dwMsecQP$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@DEFEHAGJ@defcpr?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@
	call	_printf
	add	esp, 16					; 00000010H

; 226  :         printf("defcpr result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);

	mov	eax, DWORD PTR _dwResRdtsc$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dwResRdtsc$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@GDINCLJG@defcpr?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH

; 227  :     }
; 228  : 
; 229  :     CprPtr=(unsigned char*)realloc(CprPtr,lSizeCpr);

	mov	eax, DWORD PTR _lSizeCpr$[ebp]
	push	eax
	mov	ecx, DWORD PTR _CprPtr$[ebp]
	push	ecx
	call	_realloc
	add	esp, 8
	mov	DWORD PTR _CprPtr$[ebp], eax

; 230  :     UncprPtr=(unsigned char*)malloc(lBufferSizeUncpr + BlockSizeUncompress);

	mov	eax, DWORD PTR _lBufferSizeUncpr$[ebp]
	add	eax, DWORD PTR _BlockSizeUncompress$[ebp]
	push	eax
	call	_malloc
	add	esp, 4
	mov	DWORD PTR _UncprPtr$[ebp], eax

; 231  : 
; 232  :     BeginCountPerfCounter(&li_qp,TRUE);

	push	1
	lea	eax, DWORD PTR _li_qp$[ebp]
	push	eax
	call	?BeginCountPerfCounter@@YAXPAT_LARGE_INTEGER@@H@Z ; BeginCountPerfCounter
	add	esp, 8

; 233  :     dwGetTick=GetTickCount();

	call	DWORD PTR __imp__GetTickCount@0
	mov	DWORD PTR _dwGetTick$[ebp], eax

; 234  :     BeginCountRdtsc(&li_rdtsc);

	lea	eax, DWORD PTR _li_rdtsc$[ebp]
	push	eax
	call	?BeginCountRdtsc@@YAXPAT_LARGE_INTEGER@@@Z ; BeginCountRdtsc
	add	esp, 4

; 235  :     {
; 236  :         z_stream zcpr;
; 237  :         int ret=Z_OK;

	mov	DWORD PTR _ret$64107[ebp], 0

; 238  :         long lOrigToDo = lSizeCpr;

	mov	eax, DWORD PTR _lSizeCpr$[ebp]
	mov	DWORD PTR _lOrigToDo$64108[ebp], eax

; 239  :         long lOrigDone = 0;

	mov	DWORD PTR _lOrigDone$64109[ebp], 0

; 240  :         int step=0;

	mov	DWORD PTR _step$64110[ebp], 0

; 241  :         memset(&zcpr,0,sizeof(z_stream));

	push	56					; 00000038H
	push	0
	lea	eax, DWORD PTR _zcpr$64106[ebp]
	push	eax
	call	_memset
	add	esp, 12					; 0000000cH

; 242  :         inflateInit(&zcpr);

	push	56					; 00000038H
	push	OFFSET ??_C@_05GDHACFMB@1?42?43?$AA@
	lea	eax, DWORD PTR _zcpr$64106[ebp]
	push	eax
	call	_inflateInit_@12

; 243  : 
; 244  :         zcpr.next_in = CprPtr;

	mov	eax, DWORD PTR _CprPtr$[ebp]
	mov	DWORD PTR _zcpr$64106[ebp], eax

; 245  :         zcpr.next_out = UncprPtr;

	mov	eax, DWORD PTR _UncprPtr$[ebp]
	mov	DWORD PTR _zcpr$64106[ebp+12], eax
$LN5@main:

; 246  : 
; 247  : 
; 248  :         do
; 249  :         {
; 250  :             long all_read_before = zcpr.total_in;

	mov	eax, DWORD PTR _zcpr$64106[ebp+8]
	mov	DWORD PTR _all_read_before$64116[ebp], eax

; 251  :             zcpr.avail_in = min(lOrigToDo,BlockSizeUncompress);

	mov	eax, DWORD PTR _lOrigToDo$64108[ebp]
	cmp	eax, DWORD PTR _BlockSizeUncompress$[ebp]
	jge	SHORT $LN19@main
	mov	ecx, DWORD PTR _lOrigToDo$64108[ebp]
	mov	DWORD PTR tv230[ebp], ecx
	jmp	SHORT $LN20@main
$LN19@main:
	mov	edx, DWORD PTR _BlockSizeUncompress$[ebp]
	mov	DWORD PTR tv230[ebp], edx
$LN20@main:
	mov	eax, DWORD PTR tv230[ebp]
	mov	DWORD PTR _zcpr$64106[ebp+4], eax

; 252  :             zcpr.avail_out = BlockSizeUncompress;

	mov	eax, DWORD PTR _BlockSizeUncompress$[ebp]
	mov	DWORD PTR _zcpr$64106[ebp+16], eax

; 253  :             ret=inflate(&zcpr,Z_SYNC_FLUSH);

	push	2
	lea	eax, DWORD PTR _zcpr$64106[ebp]
	push	eax
	call	_inflate@8
	mov	DWORD PTR _ret$64107[ebp], eax

; 254  :             lOrigDone += (zcpr.total_in-all_read_before);

	mov	eax, DWORD PTR _zcpr$64106[ebp+8]
	sub	eax, DWORD PTR _all_read_before$64116[ebp]
	add	eax, DWORD PTR _lOrigDone$64109[ebp]
	mov	DWORD PTR _lOrigDone$64109[ebp], eax

; 255  :             lOrigToDo -= (zcpr.total_in-all_read_before);

	mov	eax, DWORD PTR _zcpr$64106[ebp+8]
	sub	eax, DWORD PTR _all_read_before$64116[ebp]
	mov	ecx, DWORD PTR _lOrigToDo$64108[ebp]
	sub	ecx, eax
	mov	DWORD PTR _lOrigToDo$64108[ebp], ecx

; 256  :             step++;

	mov	eax, DWORD PTR _step$64110[ebp]
	add	eax, 1
	mov	DWORD PTR _step$64110[ebp], eax

; 257  :         } while (ret==Z_OK);

	cmp	DWORD PTR _ret$64107[ebp], 0
	je	$LN5@main

; 258  : 
; 259  :         lSizeUncpr=zcpr.total_out;

	mov	eax, DWORD PTR _zcpr$64106[ebp+20]
	mov	DWORD PTR _lSizeUncpr$[ebp], eax

; 260  :         inflateEnd(&zcpr);

	lea	eax, DWORD PTR _zcpr$64106[ebp]
	push	eax
	call	_inflateEnd@4

; 261  :         dwGetTick=GetTickCount()-dwGetTick;

	call	DWORD PTR __imp__GetTickCount@0
	sub	eax, DWORD PTR _dwGetTick$[ebp]
	mov	DWORD PTR _dwGetTick$[ebp], eax

; 262  :         dwMsecQP=GetMsecSincePerfCounter(li_qp,TRUE);

	push	1
	mov	eax, DWORD PTR _li_qp$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _li_qp$[ebp]
	push	ecx
	call	?GetMsecSincePerfCounter@@YAKT_LARGE_INTEGER@@H@Z ; GetMsecSincePerfCounter
	add	esp, 12					; 0000000cH
	mov	DWORD PTR _dwMsecQP$[ebp], eax

; 263  :         dwResRdtsc=GetResRdtsc(li_rdtsc,TRUE);

	push	1
	mov	eax, DWORD PTR _li_rdtsc$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _li_rdtsc$[ebp]
	push	ecx
	call	?GetResRdtsc@@YA?AT_LARGE_INTEGER@@T1@H@Z ; GetResRdtsc
	add	esp, 12					; 0000000cH
	mov	DWORD PTR $T64188[ebp], eax
	mov	DWORD PTR $T64188[ebp+4], edx
	mov	edx, DWORD PTR $T64188[ebp]
	mov	DWORD PTR _dwResRdtsc$[ebp], edx
	mov	eax, DWORD PTR $T64188[ebp+4]
	mov	DWORD PTR _dwResRdtsc$[ebp+4], eax

; 264  :         printf("total uncompress size = %u, in %u step\n",lSizeUncpr,step);

	mov	eax, DWORD PTR _step$64110[ebp]
	push	eax
	mov	ecx, DWORD PTR _lSizeUncpr$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CI@CKJMABEN@total?5uncompress?5size?5?$DN?5?$CFu?0?5in?5?$CF@
	call	_printf
	add	esp, 12					; 0000000cH

; 265  :         printf("time = %u msec = %f sec\n",dwGetTick,dwGetTick/(double)1000.);

	mov	eax, DWORD PTR _dwGetTick$[ebp]
	mov	DWORD PTR tv413[ebp], eax
	mov	DWORD PTR tv413[ebp+4], 0
	fild	QWORD PTR tv413[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _dwGetTick$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BJ@MCACADLP@time?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5sec?6?$AA@
	call	_printf
	add	esp, 16					; 00000010H

; 266  :         printf("uncpr  time QP = %u msec = %f sec\n",dwMsecQP,dwMsecQP/(double)1000.);

	mov	eax, DWORD PTR _dwMsecQP$[ebp]
	mov	DWORD PTR tv452[ebp], eax
	mov	DWORD PTR tv452[ebp+4], 0
	fild	QWORD PTR tv452[ebp]
	fdiv	QWORD PTR __real@408f400000000000
	sub	esp, 8
	fstp	QWORD PTR [esp]
	mov	ecx, DWORD PTR _dwMsecQP$[ebp]
	push	ecx
	push	OFFSET ??_C@_0CD@BCIIDHNB@uncpr?5?5time?5QP?5?$DN?5?$CFu?5msec?5?$DN?5?$CFf?5se@
	call	_printf
	add	esp, 16					; 00000010H

; 267  :         printf("uncpr  result rdtsc = %I64x\n\n",dwResRdtsc.QuadPart);

	mov	eax, DWORD PTR _dwResRdtsc$[ebp+4]
	push	eax
	mov	ecx, DWORD PTR _dwResRdtsc$[ebp]
	push	ecx
	push	OFFSET ??_C@_0BO@KIEBAEAI@uncpr?5?5result?5rdtsc?5?$DN?5?$CFI64x?6?6?$AA@
	call	_printf
	add	esp, 12					; 0000000cH

; 268  :     }
; 269  : 
; 270  :     if (lSizeUncpr==lFileSize)

	mov	eax, DWORD PTR _lSizeUncpr$[ebp]
	cmp	eax, DWORD PTR _lFileSize$[ebp]
	jne	SHORT $LN1@main

; 271  :     {
; 272  :         if (memcmp(FilePtr,UncprPtr,lFileSize)==0)

	mov	eax, DWORD PTR _lFileSize$[ebp]
	push	eax
	mov	ecx, DWORD PTR _UncprPtr$[ebp]
	push	ecx
	mov	edx, DWORD PTR _FilePtr$[ebp]
	push	edx
	call	_memcmp
	add	esp, 12					; 0000000cH
	test	eax, eax
	jne	SHORT $LN1@main

; 273  :             printf("compare ok\n");

	push	OFFSET ??_C@_0M@OPBGFCFH@compare?5ok?6?$AA@
	call	_printf
	add	esp, 4
$LN1@main:

; 274  : 
; 275  :     }
; 276  : 
; 277  :     return 0;

	xor	eax, eax
$LN15@main:

; 278  : }

	pop	edi
	pop	esi
	pop	ebx
	mov	esp, ebp
	pop	ebp
	ret	0
_main	ENDP
_TEXT	ENDS
END
