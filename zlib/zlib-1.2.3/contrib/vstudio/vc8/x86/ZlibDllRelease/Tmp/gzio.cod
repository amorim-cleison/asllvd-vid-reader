; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\gzio.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@ ; `string'
PUBLIC	??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@		; `string'
PUBLIC	??_C@_00CNPNBAHC@?$AA@				; `string'
PUBLIC	??_C@_02LMMGGCAJ@?3?5?$AA@			; `string'
EXTRN	__imp__sprintf:PROC
EXTRN	__imp___fdopen:PROC
EXTRN	__imp__fopen:PROC
EXTRN	__imp__fprintf:PROC
EXTRN	__imp__ftell:PROC
EXTRN	__imp__ferror:PROC
EXTRN	__imp__fread:PROC
EXTRN	__imp___vsnprintf:PROC
EXTRN	__imp__fflush:PROC
EXTRN	__imp__fseek:PROC
EXTRN	__imp__fwrite:PROC
EXTRN	__imp__fclose:PROC
EXTRN	__imp__fputc:PROC
EXTRN	_strcpy:PROC
EXTRN	_strcat:PROC
EXTRN	_strlen:PROC
EXTRN	__imp__strerror:PROC
EXTRN	__imp___errno:PROC
EXTRN	__imp__free:PROC
EXTRN	__imp__malloc:PROC
EXTRN	__imp__clearerr:PROC
;	COMDAT ??_C@_02LMMGGCAJ@?3?5?$AA@
CONST	SEGMENT
??_C@_02LMMGGCAJ@?3?5?$AA@ DB ': ', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_00CNPNBAHC@?$AA@
CONST	SEGMENT
??_C@_00CNPNBAHC@?$AA@ DB 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
CONST	SEGMENT
??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@ DB '<fd:%d>', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
CONST	SEGMENT
??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@ DB '%'
	DB	'c%c%c%c%c%c%c%c%c%c', 00H			; `string'
	ORG $+2
_gz_magic DD	01fH
	DD	08bH
PUBLIC	_gzclearerr@4
; Function compile flags: /Odtp
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\gzio.c
;	COMDAT _gzclearerr@4
_TEXT	SEGMENT
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclearerr@4 PROC					; COMDAT

; 1019 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1020 :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 1021 : 
; 1022 :     if (s == NULL) return;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	75 02		 jne	 SHORT $LN2@gzclearerr
  00010	eb 2d		 jmp	 SHORT $LN3@gzclearerr
$LN2@gzclearerr:

; 1023 :     if (s->z_err != Z_STREAM_END) s->z_err = Z_OK;

  00012	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00015	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00019	74 0a		 je	 SHORT $LN1@gzclearerr
  0001b	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0001e	c7 42 38 00 00
	00 00		 mov	 DWORD PTR [edx+56], 0
$LN1@gzclearerr:

; 1024 :     s->z_eof = 0;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00028	c7 40 3c 00 00
	00 00		 mov	 DWORD PTR [eax+60], 0

; 1025 :     clearerr(s->file);

  0002f	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00032	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00035	52		 push	 edx
  00036	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__clearerr
  0003c	83 c4 04	 add	 esp, 4
$LN3@gzclearerr:

; 1026 : }

  0003f	8b e5		 mov	 esp, ebp
  00041	5d		 pop	 ebp
  00042	c2 04 00	 ret	 4
_gzclearerr@4 ENDP
_TEXT	ENDS
PUBLIC	_gzerror@8
; Function compile flags: /Odtp
;	COMDAT _gzerror@8
_TEXT	SEGMENT
tv73 = -12						; size = 4
_m$ = -8						; size = 4
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_errnum$ = 12						; size = 4
_gzerror@8 PROC						; COMDAT

; 990  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH
  00006	56		 push	 esi

; 991  :     char *m;
; 992  :     gz_stream *s = (gz_stream*)file;

  00007	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0000a	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 993  : 
; 994  :     if (s == NULL) {

  0000d	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  00011	75 13		 jne	 SHORT $LN6@gzerror

; 995  :         *errnum = Z_STREAM_ERROR;

  00013	8b 4d 0c	 mov	 ecx, DWORD PTR _errnum$[ebp]
  00016	c7 01 fe ff ff
	ff		 mov	 DWORD PTR [ecx], -2	; fffffffeH

; 996  :         return (const char*)ERR_MSG(Z_STREAM_ERROR);

  0001c	a1 10 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+16
  00021	e9 0d 01 00 00	 jmp	 $LN7@gzerror
$LN6@gzerror:

; 997  :     }
; 998  :     *errnum = s->z_err;

  00026	8b 55 0c	 mov	 edx, DWORD PTR _errnum$[ebp]
  00029	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0002c	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  0002f	89 0a		 mov	 DWORD PTR [edx], ecx

; 999  :     if (*errnum == Z_OK) return (const char*)"";

  00031	8b 55 0c	 mov	 edx, DWORD PTR _errnum$[ebp]
  00034	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00037	75 0a		 jne	 SHORT $LN5@gzerror
  00039	b8 00 00 00 00	 mov	 eax, OFFSET ??_C@_00CNPNBAHC@?$AA@
  0003e	e9 f0 00 00 00	 jmp	 $LN7@gzerror
$LN5@gzerror:

; 1000 : 
; 1001 :     m = (char*)(*errnum == Z_ERRNO ? zstrerror(errno) : s->stream.msg);

  00043	8b 45 0c	 mov	 eax, DWORD PTR _errnum$[ebp]
  00046	83 38 ff	 cmp	 DWORD PTR [eax], -1
  00049	75 17		 jne	 SHORT $LN9@gzerror
  0004b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00051	8b 08		 mov	 ecx, DWORD PTR [eax]
  00053	51		 push	 ecx
  00054	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__strerror
  0005a	83 c4 04	 add	 esp, 4
  0005d	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
  00060	eb 09		 jmp	 SHORT $LN10@gzerror
$LN9@gzerror:
  00062	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00065	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00068	89 45 f4	 mov	 DWORD PTR tv73[ebp], eax
$LN10@gzerror:
  0006b	8b 4d f4	 mov	 ecx, DWORD PTR tv73[ebp]
  0006e	89 4d f8	 mov	 DWORD PTR _m$[ebp], ecx

; 1002 : 
; 1003 :     if (m == NULL || *m == '\0') m = (char*)ERR_MSG(s->z_err);

  00071	83 7d f8 00	 cmp	 DWORD PTR _m$[ebp], 0
  00075	74 0a		 je	 SHORT $LN3@gzerror
  00077	8b 55 f8	 mov	 edx, DWORD PTR _m$[ebp]
  0007a	0f be 02	 movsx	 eax, BYTE PTR [edx]
  0007d	85 c0		 test	 eax, eax
  0007f	75 15		 jne	 SHORT $LN4@gzerror
$LN3@gzerror:
  00081	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00084	ba 02 00 00 00	 mov	 edx, 2
  00089	2b 51 38	 sub	 edx, DWORD PTR [ecx+56]
  0008c	8b 04 95 00 00
	00 00		 mov	 eax, DWORD PTR _z_errmsg[edx*4]
  00093	89 45 f8	 mov	 DWORD PTR _m$[ebp], eax
$LN4@gzerror:

; 1004 : 
; 1005 :     TRYFREE(s->msg);

  00096	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00099	83 79 50 00	 cmp	 DWORD PTR [ecx+80], 0
  0009d	74 10		 je	 SHORT $LN2@gzerror
  0009f	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000a2	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  000a5	50		 push	 eax
  000a6	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000ac	83 c4 04	 add	 esp, 4
$LN2@gzerror:

; 1006 :     s->msg = (char*)ALLOC(strlen(s->path) + strlen(m) + 3);

  000af	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000b2	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000b5	52		 push	 edx
  000b6	e8 00 00 00 00	 call	 _strlen
  000bb	83 c4 04	 add	 esp, 4
  000be	8b f0		 mov	 esi, eax
  000c0	8b 45 f8	 mov	 eax, DWORD PTR _m$[ebp]
  000c3	50		 push	 eax
  000c4	e8 00 00 00 00	 call	 _strlen
  000c9	83 c4 04	 add	 esp, 4
  000cc	8d 4c 06 03	 lea	 ecx, DWORD PTR [esi+eax+3]
  000d0	51		 push	 ecx
  000d1	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  000d7	83 c4 04	 add	 esp, 4
  000da	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000dd	89 42 50	 mov	 DWORD PTR [edx+80], eax

; 1007 :     if (s->msg == Z_NULL) return (const char*)ERR_MSG(Z_MEM_ERROR);

  000e0	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000e3	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  000e7	75 07		 jne	 SHORT $LN1@gzerror
  000e9	a1 18 00 00 00	 mov	 eax, DWORD PTR _z_errmsg+24
  000ee	eb 43		 jmp	 SHORT $LN7@gzerror
$LN1@gzerror:

; 1008 :     strcpy(s->msg, s->path);

  000f0	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000f3	8b 51 54	 mov	 edx, DWORD PTR [ecx+84]
  000f6	52		 push	 edx
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000fa	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000fd	51		 push	 ecx
  000fe	e8 00 00 00 00	 call	 _strcpy
  00103	83 c4 08	 add	 esp, 8

; 1009 :     strcat(s->msg, ": ");

  00106	68 00 00 00 00	 push	 OFFSET ??_C@_02LMMGGCAJ@?3?5?$AA@
  0010b	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0010e	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00111	50		 push	 eax
  00112	e8 00 00 00 00	 call	 _strcat
  00117	83 c4 08	 add	 esp, 8

; 1010 :     strcat(s->msg, m);

  0011a	8b 4d f8	 mov	 ecx, DWORD PTR _m$[ebp]
  0011d	51		 push	 ecx
  0011e	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00121	8b 42 50	 mov	 eax, DWORD PTR [edx+80]
  00124	50		 push	 eax
  00125	e8 00 00 00 00	 call	 _strcat
  0012a	83 c4 08	 add	 esp, 8

; 1011 :     return (const char*)s->msg;

  0012d	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00130	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
$LN7@gzerror:

; 1012 : }

  00133	5e		 pop	 esi
  00134	8b e5		 mov	 esp, ebp
  00136	5d		 pop	 ebp
  00137	c2 08 00	 ret	 8
_gzerror@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _putLong
_TEXT	SEGMENT
_n$ = -4						; size = 4
_file$ = 8						; size = 4
_x$ = 12						; size = 4
_putLong PROC						; COMDAT

; 923  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 924  :     int n;
; 925  :     for (n = 0; n < 4; n++) {

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _n$[ebp], 0
  0000b	eb 09		 jmp	 SHORT $LN3@putLong
$LN2@putLong:
  0000d	8b 45 fc	 mov	 eax, DWORD PTR _n$[ebp]
  00010	83 c0 01	 add	 eax, 1
  00013	89 45 fc	 mov	 DWORD PTR _n$[ebp], eax
$LN3@putLong:
  00016	83 7d fc 04	 cmp	 DWORD PTR _n$[ebp], 4
  0001a	7d 22		 jge	 SHORT $LN4@putLong

; 926  :         fputc((int)(x & 0xff), file);

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0001f	51		 push	 ecx
  00020	8b 55 0c	 mov	 edx, DWORD PTR _x$[ebp]
  00023	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00029	52		 push	 edx
  0002a	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fputc
  00030	83 c4 08	 add	 esp, 8

; 927  :         x >>= 8;

  00033	8b 45 0c	 mov	 eax, DWORD PTR _x$[ebp]
  00036	c1 e8 08	 shr	 eax, 8
  00039	89 45 0c	 mov	 DWORD PTR _x$[ebp], eax

; 928  :     }

  0003c	eb cf		 jmp	 SHORT $LN2@putLong
$LN4@putLong:

; 929  : }

  0003e	8b e5		 mov	 esp, ebp
  00040	5d		 pop	 ebp
  00041	c3		 ret	 0
_putLong ENDP
_TEXT	ENDS
PUBLIC	_gzeof@4
; Function compile flags: /Odtp
;	COMDAT _gzeof@4
_TEXT	SEGMENT
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_gzeof@4 PROC						; COMDAT

; 893  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 894  :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 895  : 
; 896  :     /* With concatenated compressed files that can have embedded
; 897  :      * crc trailers, z_eof is no longer the only/best indicator of EOF
; 898  :      * on a gz_stream. Handle end-of-stream error explicitly here.
; 899  :      */
; 900  :     if (s == NULL || s->mode != 'r') return 0;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	74 0c		 je	 SHORT $LN2@gzeof
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00013	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00017	83 fa 72	 cmp	 edx, 114		; 00000072H
  0001a	74 04		 je	 SHORT $LN3@gzeof
$LN2@gzeof:
  0001c	33 c0		 xor	 eax, eax
  0001e	eb 1c		 jmp	 SHORT $LN4@gzeof
$LN3@gzeof:

; 901  :     if (s->z_eof) return 1;

  00020	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00023	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  00027	74 07		 je	 SHORT $LN1@gzeof
  00029	b8 01 00 00 00	 mov	 eax, 1
  0002e	eb 0c		 jmp	 SHORT $LN4@gzeof
$LN1@gzeof:

; 902  :     return s->z_err == Z_STREAM_END;

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00033	33 c0		 xor	 eax, eax
  00035	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00039	0f 94 c0	 sete	 al
$LN4@gzeof:

; 903  : }

  0003c	8b e5		 mov	 esp, ebp
  0003e	5d		 pop	 ebp
  0003f	c2 04 00	 ret	 4
_gzeof@4 ENDP
_TEXT	ENDS
PUBLIC	_gzungetc@8
; Function compile flags: /Odtp
;	COMDAT _gzungetc@8
_TEXT	SEGMENT
_s$ = -4						; size = 4
_c$ = 8							; size = 4
_file$ = 12						; size = 4
_gzungetc@8 PROC					; COMDAT

; 518  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 519  :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 0c	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 520  : 
; 521  :     if (s == NULL || s->mode != 'r' || c == EOF || s->back != EOF) return EOF;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	74 1b		 je	 SHORT $LN2@gzungetc
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00013	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00017	83 fa 72	 cmp	 edx, 114		; 00000072H
  0001a	75 0f		 jne	 SHORT $LN2@gzungetc
  0001c	83 7d 08 ff	 cmp	 DWORD PTR _c$[ebp], -1
  00020	74 09		 je	 SHORT $LN2@gzungetc
  00022	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00025	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  00029	74 05		 je	 SHORT $LN3@gzungetc
$LN2@gzungetc:
  0002b	83 c8 ff	 or	 eax, -1
  0002e	eb 4a		 jmp	 SHORT $LN4@gzungetc
$LN3@gzungetc:

; 522  :     s->back = c;

  00030	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00033	8b 55 08	 mov	 edx, DWORD PTR _c$[ebp]
  00036	89 51 6c	 mov	 DWORD PTR [ecx+108], edx

; 523  :     s->out--;

  00039	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0003c	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0003f	83 e9 01	 sub	 ecx, 1
  00042	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00045	89 4a 68	 mov	 DWORD PTR [edx+104], ecx

; 524  :     s->last = (s->z_err == Z_STREAM_END);

  00048	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0004b	33 c9		 xor	 ecx, ecx
  0004d	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00051	0f 94 c1	 sete	 cl
  00054	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00057	89 4a 70	 mov	 DWORD PTR [edx+112], ecx

; 525  :     if (s->last) s->z_err = Z_OK;

  0005a	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0005d	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  00061	74 0a		 je	 SHORT $LN1@gzungetc
  00063	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00066	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
$LN1@gzungetc:

; 526  :     s->z_eof = 0;

  0006d	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00070	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 527  :     return c;

  00077	8b 45 08	 mov	 eax, DWORD PTR _c$[ebp]
$LN4@gzungetc:

; 528  : }

  0007a	8b e5		 mov	 esp, ebp
  0007c	5d		 pop	 ebp
  0007d	c2 08 00	 ret	 8
_gzungetc@8 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _get_byte
_TEXT	SEGMENT
tv92 = -1						; size = 1
_s$ = 8							; size = 4
_get_byte PROC						; COMDAT

; 263  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 264  :     if (s->z_eof) return EOF;

  00004	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00007	83 78 3c 00	 cmp	 DWORD PTR [eax+60], 0
  0000b	74 08		 je	 SHORT $LN4@get_byte
  0000d	83 c8 ff	 or	 eax, -1
  00010	e9 a4 00 00 00	 jmp	 $LN5@get_byte
$LN4@get_byte:

; 265  :     if (s->stream.avail_in == 0) {

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00018	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0001c	75 71		 jne	 SHORT $LN3@get_byte

; 266  :         errno = 0;

  0001e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00024	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 267  :         s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);

  0002a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0002d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00030	50		 push	 eax
  00031	68 00 40 00 00	 push	 16384			; 00004000H
  00036	6a 01		 push	 1
  00038	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0003b	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0003e	52		 push	 edx
  0003f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00045	83 c4 10	 add	 esp, 16			; 00000010H
  00048	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0004b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 268  :         if (s->stream.avail_in == 0) {

  0004e	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00051	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00055	75 2d		 jne	 SHORT $LN2@get_byte

; 269  :             s->z_eof = 1;

  00057	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0005a	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1

; 270  :             if (ferror(s->file)) s->z_err = Z_ERRNO;

  00061	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00064	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00067	52		 push	 edx
  00068	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ferror
  0006e	83 c4 04	 add	 esp, 4
  00071	85 c0		 test	 eax, eax
  00073	74 0a		 je	 SHORT $LN1@get_byte
  00075	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00078	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1
$LN1@get_byte:

; 271  :             return EOF;

  0007f	83 c8 ff	 or	 eax, -1
  00082	eb 35		 jmp	 SHORT $LN5@get_byte
$LN2@get_byte:

; 272  :         }
; 273  :         s->stream.next_in = s->inbuf;

  00084	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00087	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0008a	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0008d	89 01		 mov	 DWORD PTR [ecx], eax
$LN3@get_byte:

; 274  :     }
; 275  :     s->stream.avail_in--;

  0008f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00092	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  00095	83 ea 01	 sub	 edx, 1
  00098	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009b	89 50 04	 mov	 DWORD PTR [eax+4], edx

; 276  :     return *(s->stream.next_in)++;

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000a1	8b 11		 mov	 edx, DWORD PTR [ecx]
  000a3	8a 02		 mov	 al, BYTE PTR [edx]
  000a5	88 45 ff	 mov	 BYTE PTR tv92[ebp], al
  000a8	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000ab	8b 11		 mov	 edx, DWORD PTR [ecx]
  000ad	83 c2 01	 add	 edx, 1
  000b0	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000b3	89 10		 mov	 DWORD PTR [eax], edx
  000b5	0f b6 45 ff	 movzx	 eax, BYTE PTR tv92[ebp]
$LN5@get_byte:

; 277  : }

  000b9	8b e5		 mov	 esp, ebp
  000bb	5d		 pop	 ebp
  000bc	c3		 ret	 0
_get_byte ENDP
; Function compile flags: /Odtp
;	COMDAT _getLong
_TEXT	SEGMENT
_c$ = -8						; size = 4
_x$ = -4						; size = 4
_s$ = 8							; size = 4
_getLong PROC						; COMDAT

; 937  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 938  :     uLong x = (uLong)get_byte(s);

  00006	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00009	50		 push	 eax
  0000a	e8 00 00 00 00	 call	 _get_byte
  0000f	83 c4 04	 add	 esp, 4
  00012	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 939  :     int c;
; 940  : 
; 941  :     x += ((uLong)get_byte(s))<<8;

  00015	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00018	51		 push	 ecx
  00019	e8 00 00 00 00	 call	 _get_byte
  0001e	83 c4 04	 add	 esp, 4
  00021	c1 e0 08	 shl	 eax, 8
  00024	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  00027	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 942  :     x += ((uLong)get_byte(s))<<16;

  0002a	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0002d	52		 push	 edx
  0002e	e8 00 00 00 00	 call	 _get_byte
  00033	83 c4 04	 add	 esp, 4
  00036	c1 e0 10	 shl	 eax, 16			; 00000010H
  00039	03 45 fc	 add	 eax, DWORD PTR _x$[ebp]
  0003c	89 45 fc	 mov	 DWORD PTR _x$[ebp], eax

; 943  :     c = get_byte(s);

  0003f	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00042	50		 push	 eax
  00043	e8 00 00 00 00	 call	 _get_byte
  00048	83 c4 04	 add	 esp, 4
  0004b	89 45 f8	 mov	 DWORD PTR _c$[ebp], eax

; 944  :     if (c == EOF) s->z_err = Z_DATA_ERROR;

  0004e	83 7d f8 ff	 cmp	 DWORD PTR _c$[ebp], -1
  00052	75 0a		 jne	 SHORT $LN1@getLong
  00054	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00057	c7 41 38 fd ff
	ff ff		 mov	 DWORD PTR [ecx+56], -3	; fffffffdH
$LN1@getLong:

; 945  :     x += ((uLong)c)<<24;

  0005e	8b 55 f8	 mov	 edx, DWORD PTR _c$[ebp]
  00061	c1 e2 18	 shl	 edx, 24			; 00000018H
  00064	03 55 fc	 add	 edx, DWORD PTR _x$[ebp]
  00067	89 55 fc	 mov	 DWORD PTR _x$[ebp], edx

; 946  :     return x;

  0006a	8b 45 fc	 mov	 eax, DWORD PTR _x$[ebp]

; 947  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_getLong ENDP
_TEXT	ENDS
PUBLIC	_gzrewind@4
; Function compile flags: /Odtp
;	COMDAT _gzrewind@4
_TEXT	SEGMENT
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_gzrewind@4 PROC					; COMDAT

; 859  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 860  :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 861  : 
; 862  :     if (s == NULL || s->mode != 'r') return -1;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	74 0c		 je	 SHORT $LN2@gzrewind
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00013	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00017	83 fa 72	 cmp	 edx, 114		; 00000072H
  0001a	74 08		 je	 SHORT $LN3@gzrewind
$LN2@gzrewind:
  0001c	83 c8 ff	 or	 eax, -1
  0001f	e9 83 00 00 00	 jmp	 $LN4@gzrewind
$LN3@gzrewind:

; 863  : 
; 864  :     s->z_err = Z_OK;

  00024	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00027	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 865  :     s->z_eof = 0;

  0002e	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00031	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 866  :     s->back = EOF;

  00038	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0003b	c7 42 6c ff ff
	ff ff		 mov	 DWORD PTR [edx+108], -1

; 867  :     s->stream.avail_in = 0;

  00042	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00045	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 868  :     s->stream.next_in = s->inbuf;

  0004c	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0004f	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00052	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  00055	89 01		 mov	 DWORD PTR [ecx], eax

; 869  :     s->crc = crc32(0L, Z_NULL, 0);

  00057	6a 00		 push	 0
  00059	6a 00		 push	 0
  0005b	6a 00		 push	 0
  0005d	e8 00 00 00 00	 call	 _crc32@12
  00062	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00065	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 870  :     if (!s->transparent) (void)inflateReset(&s->stream);

  00068	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0006b	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  0006f	75 09		 jne	 SHORT $LN1@gzrewind
  00071	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00074	50		 push	 eax
  00075	e8 00 00 00 00	 call	 _inflateReset@4
$LN1@gzrewind:

; 871  :     s->in = 0;

  0007a	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0007d	c7 41 64 00 00
	00 00		 mov	 DWORD PTR [ecx+100], 0

; 872  :     s->out = 0;

  00084	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00087	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 873  :     return fseek(s->file, s->start, SEEK_SET);

  0008e	6a 00		 push	 0
  00090	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00093	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00096	51		 push	 ecx
  00097	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0009a	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0009d	50		 push	 eax
  0009e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  000a4	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@gzrewind:

; 874  : }

  000a7	8b e5		 mov	 esp, ebp
  000a9	5d		 pop	 ebp
  000aa	c2 04 00	 ret	 4
_gzrewind@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _destroy
_TEXT	SEGMENT
_err$ = -4						; size = 4
_s$ = 8							; size = 4
_destroy PROC						; COMDAT

; 357  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 358  :     int err = Z_OK;

  00004	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _err$[ebp], 0

; 359  : 
; 360  :     if (!s) return Z_STREAM_ERROR;

  0000b	83 7d 08 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000f	75 0a		 jne	 SHORT $LN13@destroy
  00011	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00016	e9 f6 00 00 00	 jmp	 $LN14@destroy
$LN13@destroy:

; 361  : 
; 362  :     TRYFREE(s->msg);

  0001b	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0001e	83 78 50 00	 cmp	 DWORD PTR [eax+80], 0
  00022	74 10		 je	 SHORT $LN12@destroy
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00027	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0002a	52		 push	 edx
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  00031	83 c4 04	 add	 esp, 4
$LN12@destroy:

; 363  : 
; 364  :     if (s->stream.state != NULL) {

  00034	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00037	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  0003b	74 32		 je	 SHORT $LN11@destroy

; 365  :         if (s->mode == 'w') {

  0003d	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00040	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00044	83 fa 77	 cmp	 edx, 119		; 00000077H
  00047	75 0e		 jne	 SHORT $LN10@destroy

; 366  : #ifdef NO_GZCOMPRESS
; 367  :             err = Z_STREAM_ERROR;
; 368  : #else
; 369  :             err = deflateEnd(&(s->stream));

  00049	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	50		 push	 eax
  0004d	e8 00 00 00 00	 call	 _deflateEnd@4
  00052	89 45 fc	 mov	 DWORD PTR _err$[ebp], eax
  00055	eb 18		 jmp	 SHORT $LN11@destroy
$LN10@destroy:

; 370  : #endif
; 371  :         } else if (s->mode == 'r') {

  00057	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0005a	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  0005e	83 fa 72	 cmp	 edx, 114		; 00000072H
  00061	75 0c		 jne	 SHORT $LN11@destroy

; 372  :             err = inflateEnd(&(s->stream));

  00063	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _inflateEnd@4
  0006c	89 45 fc	 mov	 DWORD PTR _err$[ebp], eax
$LN11@destroy:

; 373  :         }
; 374  :     }
; 375  :     if (s->file != NULL && fclose(s->file)) {

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00072	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00076	74 26		 je	 SHORT $LN7@destroy
  00078	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0007b	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  0007e	50		 push	 eax
  0007f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fclose
  00085	83 c4 04	 add	 esp, 4
  00088	85 c0		 test	 eax, eax
  0008a	74 12		 je	 SHORT $LN7@destroy

; 376  : #ifdef ESPIPE
; 377  :         if (errno != ESPIPE) /* fclose is broken for pipes in HP/UX */

  0008c	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00092	83 38 1d	 cmp	 DWORD PTR [eax], 29	; 0000001dH
  00095	74 07		 je	 SHORT $LN7@destroy

; 378  : #endif
; 379  :             err = Z_ERRNO;

  00097	c7 45 fc ff ff
	ff ff		 mov	 DWORD PTR _err$[ebp], -1
$LN7@destroy:

; 380  :     }
; 381  :     if (s->z_err < 0) err = s->z_err;

  0009e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000a1	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000a5	7d 09		 jge	 SHORT $LN5@destroy
  000a7	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000aa	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  000ad	89 45 fc	 mov	 DWORD PTR _err$[ebp], eax
$LN5@destroy:

; 382  : 
; 383  :     TRYFREE(s->inbuf);

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000b3	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  000b7	74 10		 je	 SHORT $LN4@destroy
  000b9	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000bc	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000bf	50		 push	 eax
  000c0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000c6	83 c4 04	 add	 esp, 4
$LN4@destroy:

; 384  :     TRYFREE(s->outbuf);

  000c9	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000cc	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  000d0	74 10		 je	 SHORT $LN3@destroy
  000d2	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000d5	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  000d8	50		 push	 eax
  000d9	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000df	83 c4 04	 add	 esp, 4
$LN3@destroy:

; 385  :     TRYFREE(s->path);

  000e2	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000e5	83 79 54 00	 cmp	 DWORD PTR [ecx+84], 0
  000e9	74 10		 je	 SHORT $LN2@destroy
  000eb	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000ee	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  000f1	50		 push	 eax
  000f2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  000f8	83 c4 04	 add	 esp, 4
$LN2@destroy:

; 386  :     TRYFREE(s);

  000fb	83 7d 08 00	 cmp	 DWORD PTR _s$[ebp], 0
  000ff	74 0d		 je	 SHORT $LN1@destroy
  00101	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00104	51		 push	 ecx
  00105	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__free
  0010b	83 c4 04	 add	 esp, 4
$LN1@destroy:

; 387  :     return err;

  0010e	8b 45 fc	 mov	 eax, DWORD PTR _err$[ebp]
$LN14@destroy:

; 388  : }

  00111	8b e5		 mov	 esp, ebp
  00113	5d		 pop	 ebp
  00114	c3		 ret	 0
_destroy ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _check_header
_TEXT	SEGMENT
_c$ = -16						; size = 4
_len$ = -12						; size = 4
_flags$ = -8						; size = 4
_method$ = -4						; size = 4
_s$ = 8							; size = 4
_check_header PROC					; COMDAT

; 290  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 291  :     int method; /* method byte */
; 292  :     int flags;  /* flags byte */
; 293  :     uInt len;
; 294  :     int c;
; 295  : 
; 296  :     /* Assure two bytes in the buffer so we can peek ahead -- handle case
; 297  :        where first byte of header is at the end of the buffer after the last
; 298  :        gzip segment */
; 299  :     len = s->stream.avail_in;

  00006	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00009	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0000c	89 4d f4	 mov	 DWORD PTR _len$[ebp], ecx

; 300  :     if (len < 2) {

  0000f	83 7d f4 02	 cmp	 DWORD PTR _len$[ebp], 2
  00013	0f 83 a3 00 00
	00		 jae	 $LN24@check_head

; 301  :         if (len) s->inbuf[0] = s->stream.next_in[0];

  00019	83 7d f4 00	 cmp	 DWORD PTR _len$[ebp], 0
  0001d	74 0f		 je	 SHORT $LN23@check_head
  0001f	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00022	8b 02		 mov	 eax, DWORD PTR [edx]
  00024	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00027	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0002a	8a 00		 mov	 al, BYTE PTR [eax]
  0002c	88 02		 mov	 BYTE PTR [edx], al
$LN23@check_head:

; 302  :         errno = 0;

  0002e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00034	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 303  :         len = (uInt)fread(s->inbuf + len, 1, Z_BUFSIZE >> len, s->file);

  0003a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0003d	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00040	52		 push	 edx
  00041	b8 00 40 00 00	 mov	 eax, 16384		; 00004000H
  00046	8b 4d f4	 mov	 ecx, DWORD PTR _len$[ebp]
  00049	d3 f8		 sar	 eax, cl
  0004b	50		 push	 eax
  0004c	6a 01		 push	 1
  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00051	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00054	03 55 f4	 add	 edx, DWORD PTR _len$[ebp]
  00057	52		 push	 edx
  00058	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  0005e	83 c4 10	 add	 esp, 16			; 00000010H
  00061	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax

; 304  :         if (len == 0 && ferror(s->file)) s->z_err = Z_ERRNO;

  00064	83 7d f4 00	 cmp	 DWORD PTR _len$[ebp], 0
  00068	75 1e		 jne	 SHORT $LN22@check_head
  0006a	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0006d	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00070	51		 push	 ecx
  00071	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ferror
  00077	83 c4 04	 add	 esp, 4
  0007a	85 c0		 test	 eax, eax
  0007c	74 0a		 je	 SHORT $LN22@check_head
  0007e	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00081	c7 42 38 ff ff
	ff ff		 mov	 DWORD PTR [edx+56], -1
$LN22@check_head:

; 305  :         s->stream.avail_in += len;

  00088	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0008b	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  0008e	03 4d f4	 add	 ecx, DWORD PTR _len$[ebp]
  00091	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00094	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 306  :         s->stream.next_in = s->inbuf;

  00097	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0009a	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  0009d	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  000a0	89 10		 mov	 DWORD PTR [eax], edx

; 307  :         if (s->stream.avail_in < 2) {

  000a2	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  000a5	83 78 04 02	 cmp	 DWORD PTR [eax+4], 2
  000a9	73 11		 jae	 SHORT $LN24@check_head

; 308  :             s->transparent = s->stream.avail_in;

  000ab	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000ae	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000b1	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000b4	89 41 58	 mov	 DWORD PTR [ecx+88], eax

; 309  :             return;

  000b7	e9 8a 01 00 00	 jmp	 $LN25@check_head
$LN24@check_head:

; 310  :         }
; 311  :     }
; 312  : 
; 313  :     /* Peek ahead to check the gzip magic header */
; 314  :     if (s->stream.next_in[0] != gz_magic[0] ||
; 315  :         s->stream.next_in[1] != gz_magic[1]) {

  000bc	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000bf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000c1	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000c4	3b 05 00 00 00
	00		 cmp	 eax, DWORD PTR _gz_magic
  000ca	75 11		 jne	 SHORT $LN19@check_head
  000cc	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000cf	8b 11		 mov	 edx, DWORD PTR [ecx]
  000d1	0f b6 42 01	 movzx	 eax, BYTE PTR [edx+1]
  000d5	3b 05 04 00 00
	00		 cmp	 eax, DWORD PTR _gz_magic+4
  000db	74 0f		 je	 SHORT $LN20@check_head
$LN19@check_head:

; 316  :         s->transparent = 1;

  000dd	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000e0	c7 41 58 01 00
	00 00		 mov	 DWORD PTR [ecx+88], 1

; 317  :         return;

  000e7	e9 5a 01 00 00	 jmp	 $LN25@check_head
$LN20@check_head:

; 318  :     }
; 319  :     s->stream.avail_in -= 2;

  000ec	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000ef	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  000f2	83 e8 02	 sub	 eax, 2
  000f5	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  000f8	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 320  :     s->stream.next_in += 2;

  000fb	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  000fe	8b 02		 mov	 eax, DWORD PTR [edx]
  00100	83 c0 02	 add	 eax, 2
  00103	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00106	89 01		 mov	 DWORD PTR [ecx], eax

; 321  : 
; 322  :     /* Check the rest of the gzip header */
; 323  :     method = get_byte(s);

  00108	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _get_byte
  00111	83 c4 04	 add	 esp, 4
  00114	89 45 fc	 mov	 DWORD PTR _method$[ebp], eax

; 324  :     flags = get_byte(s);

  00117	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  0011a	50		 push	 eax
  0011b	e8 00 00 00 00	 call	 _get_byte
  00120	83 c4 04	 add	 esp, 4
  00123	89 45 f8	 mov	 DWORD PTR _flags$[ebp], eax

; 325  :     if (method != Z_DEFLATED || (flags & RESERVED) != 0) {

  00126	83 7d fc 08	 cmp	 DWORD PTR _method$[ebp], 8
  0012a	75 0b		 jne	 SHORT $LN17@check_head
  0012c	8b 4d f8	 mov	 ecx, DWORD PTR _flags$[ebp]
  0012f	81 e1 e0 00 00
	00		 and	 ecx, 224		; 000000e0H
  00135	74 0f		 je	 SHORT $LN18@check_head
$LN17@check_head:

; 326  :         s->z_err = Z_DATA_ERROR;

  00137	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  0013a	c7 42 38 fd ff
	ff ff		 mov	 DWORD PTR [edx+56], -3	; fffffffdH

; 327  :         return;

  00141	e9 00 01 00 00	 jmp	 $LN25@check_head
$LN18@check_head:

; 328  :     }
; 329  : 
; 330  :     /* Discard time, xflags and OS code: */
; 331  :     for (len = 0; len < 6; len++) (void)get_byte(s);

  00146	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  0014d	eb 09		 jmp	 SHORT $LN16@check_head
$LN15@check_head:
  0014f	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
  00152	83 c0 01	 add	 eax, 1
  00155	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax
$LN16@check_head:
  00158	83 7d f4 06	 cmp	 DWORD PTR _len$[ebp], 6
  0015c	73 0e		 jae	 SHORT $LN14@check_head
  0015e	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00161	51		 push	 ecx
  00162	e8 00 00 00 00	 call	 _get_byte
  00167	83 c4 04	 add	 esp, 4
  0016a	eb e3		 jmp	 SHORT $LN15@check_head
$LN14@check_head:

; 332  : 
; 333  :     if ((flags & EXTRA_FIELD) != 0) { /* skip the extra field */

  0016c	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  0016f	83 e2 04	 and	 edx, 4
  00172	74 47		 je	 SHORT $LN13@check_head

; 334  :         len  =  (uInt)get_byte(s);

  00174	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00177	50		 push	 eax
  00178	e8 00 00 00 00	 call	 _get_byte
  0017d	83 c4 04	 add	 esp, 4
  00180	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax

; 335  :         len += ((uInt)get_byte(s))<<8;

  00183	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  00186	51		 push	 ecx
  00187	e8 00 00 00 00	 call	 _get_byte
  0018c	83 c4 04	 add	 esp, 4
  0018f	c1 e0 08	 shl	 eax, 8
  00192	03 45 f4	 add	 eax, DWORD PTR _len$[ebp]
  00195	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax
$LN12@check_head:

; 336  :         /* len is garbage if EOF but the loop below will quit anyway */
; 337  :         while (len-- != 0 && get_byte(s) != EOF) ;

  00198	8b 55 f4	 mov	 edx, DWORD PTR _len$[ebp]
  0019b	8b 45 f4	 mov	 eax, DWORD PTR _len$[ebp]
  0019e	83 e8 01	 sub	 eax, 1
  001a1	89 45 f4	 mov	 DWORD PTR _len$[ebp], eax
  001a4	85 d2		 test	 edx, edx
  001a6	74 13		 je	 SHORT $LN13@check_head
  001a8	8b 4d 08	 mov	 ecx, DWORD PTR _s$[ebp]
  001ab	51		 push	 ecx
  001ac	e8 00 00 00 00	 call	 _get_byte
  001b1	83 c4 04	 add	 esp, 4
  001b4	83 f8 ff	 cmp	 eax, -1
  001b7	74 02		 je	 SHORT $LN13@check_head
  001b9	eb dd		 jmp	 SHORT $LN12@check_head
$LN13@check_head:

; 338  :     }
; 339  :     if ((flags & ORIG_NAME) != 0) { /* skip the original file name */

  001bb	8b 55 f8	 mov	 edx, DWORD PTR _flags$[ebp]
  001be	83 e2 08	 and	 edx, 8
  001c1	74 1d		 je	 SHORT $LN10@check_head
$LN9@check_head:

; 340  :         while ((c = get_byte(s)) != 0 && c != EOF) ;

  001c3	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  001c6	50		 push	 eax
  001c7	e8 00 00 00 00	 call	 _get_byte
  001cc	83 c4 04	 add	 esp, 4
  001cf	89 45 f0	 mov	 DWORD PTR _c$[ebp], eax
  001d2	83 7d f0 00	 cmp	 DWORD PTR _c$[ebp], 0
  001d6	74 08		 je	 SHORT $LN10@check_head
  001d8	83 7d f0 ff	 cmp	 DWORD PTR _c$[ebp], -1
  001dc	74 02		 je	 SHORT $LN10@check_head
  001de	eb e3		 jmp	 SHORT $LN9@check_head
$LN10@check_head:

; 341  :     }
; 342  :     if ((flags & COMMENT) != 0) {   /* skip the .gz file comment */

  001e0	8b 4d f8	 mov	 ecx, DWORD PTR _flags$[ebp]
  001e3	83 e1 10	 and	 ecx, 16			; 00000010H
  001e6	74 1d		 je	 SHORT $LN7@check_head
$LN6@check_head:

; 343  :         while ((c = get_byte(s)) != 0 && c != EOF) ;

  001e8	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  001eb	52		 push	 edx
  001ec	e8 00 00 00 00	 call	 _get_byte
  001f1	83 c4 04	 add	 esp, 4
  001f4	89 45 f0	 mov	 DWORD PTR _c$[ebp], eax
  001f7	83 7d f0 00	 cmp	 DWORD PTR _c$[ebp], 0
  001fb	74 08		 je	 SHORT $LN7@check_head
  001fd	83 7d f0 ff	 cmp	 DWORD PTR _c$[ebp], -1
  00201	74 02		 je	 SHORT $LN7@check_head
  00203	eb e3		 jmp	 SHORT $LN6@check_head
$LN7@check_head:

; 344  :     }
; 345  :     if ((flags & HEAD_CRC) != 0) {  /* skip the header crc */

  00205	8b 45 f8	 mov	 eax, DWORD PTR _flags$[ebp]
  00208	83 e0 02	 and	 eax, 2
  0020b	74 26		 je	 SHORT $LN4@check_head

; 346  :         for (len = 0; len < 2; len++) (void)get_byte(s);

  0020d	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  00214	eb 09		 jmp	 SHORT $LN3@check_head
$LN2@check_head:
  00216	8b 4d f4	 mov	 ecx, DWORD PTR _len$[ebp]
  00219	83 c1 01	 add	 ecx, 1
  0021c	89 4d f4	 mov	 DWORD PTR _len$[ebp], ecx
$LN3@check_head:
  0021f	83 7d f4 02	 cmp	 DWORD PTR _len$[ebp], 2
  00223	73 0e		 jae	 SHORT $LN4@check_head
  00225	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00228	52		 push	 edx
  00229	e8 00 00 00 00	 call	 _get_byte
  0022e	83 c4 04	 add	 esp, 4
  00231	eb e3		 jmp	 SHORT $LN2@check_head
$LN4@check_head:

; 347  :     }
; 348  :     s->z_err = s->z_eof ? Z_DATA_ERROR : Z_OK;

  00233	8b 45 08	 mov	 eax, DWORD PTR _s$[ebp]
  00236	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00239	f7 d9		 neg	 ecx
  0023b	1b c9		 sbb	 ecx, ecx
  0023d	83 e1 fd	 and	 ecx, -3			; fffffffdH
  00240	8b 55 08	 mov	 edx, DWORD PTR _s$[ebp]
  00243	89 4a 38	 mov	 DWORD PTR [edx+56], ecx
$LN25@check_head:

; 349  : }

  00246	8b e5		 mov	 esp, ebp
  00248	5d		 pop	 ebp
  00249	c3		 ret	 0
_check_header ENDP
; Function compile flags: /Odtp
;	COMDAT _do_flush
_TEXT	SEGMENT
tv145 = -20						; size = 4
tv137 = -16						; size = 4
_done$ = -12						; size = 4
_len$ = -8						; size = 4
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_do_flush PROC						; COMDAT

; 708  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 709  :     uInt len;
; 710  :     int done = 0;

  00006	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR _done$[ebp], 0

; 711  :     gz_stream *s = (gz_stream*)file;

  0000d	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00010	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 712  : 
; 713  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  00013	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  00017	74 0c		 je	 SHORT $LN8@do_flush
  00019	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0001c	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00020	83 fa 77	 cmp	 edx, 119		; 00000077H
  00023	74 0a		 je	 SHORT $LN9@do_flush
$LN8@do_flush:
  00025	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0002a	e9 1e 01 00 00	 jmp	 $LN10@do_flush
$LN9@do_flush:

; 714  : 
; 715  :     s->stream.avail_in = 0; /* should be zero already anyway */

  0002f	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00032	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0
$LN7@do_flush:

; 716  : 
; 717  :     for (;;) {
; 718  :         len = Z_BUFSIZE - s->stream.avail_out;

  00039	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0003c	ba 00 40 00 00	 mov	 edx, 16384		; 00004000H
  00041	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  00044	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 719  : 
; 720  :         if (len != 0) {

  00047	74 4a		 je	 SHORT $LN5@do_flush

; 721  :             if ((uInt)fwrite(s->outbuf, 1, len, s->file) != len) {

  00049	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0004c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0004f	51		 push	 ecx
  00050	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  00053	52		 push	 edx
  00054	6a 01		 push	 1
  00056	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00059	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0005c	51		 push	 ecx
  0005d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00063	83 c4 10	 add	 esp, 16			; 00000010H
  00066	3b 45 f8	 cmp	 eax, DWORD PTR _len$[ebp]
  00069	74 12		 je	 SHORT $LN4@do_flush

; 722  :                 s->z_err = Z_ERRNO;

  0006b	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0006e	c7 42 38 ff ff
	ff ff		 mov	 DWORD PTR [edx+56], -1

; 723  :                 return Z_ERRNO;

  00075	83 c8 ff	 or	 eax, -1
  00078	e9 d0 00 00 00	 jmp	 $LN10@do_flush
$LN4@do_flush:

; 724  :             }
; 725  :             s->stream.next_out = s->outbuf;

  0007d	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00080	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00083	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00086	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 726  :             s->stream.avail_out = Z_BUFSIZE;

  00089	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0008c	c7 40 10 00 40
	00 00		 mov	 DWORD PTR [eax+16], 16384 ; 00004000H
$LN5@do_flush:

; 727  :         }
; 728  :         if (done) break;

  00093	83 7d f4 00	 cmp	 DWORD PTR _done$[ebp], 0
  00097	74 05		 je	 SHORT $LN3@do_flush
  00099	e9 91 00 00 00	 jmp	 $LN6@do_flush
$LN3@do_flush:

; 729  :         s->out += s->stream.avail_out;

  0009e	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000a1	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  000a4	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000a7	03 50 10	 add	 edx, DWORD PTR [eax+16]
  000aa	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000ad	89 51 68	 mov	 DWORD PTR [ecx+104], edx

; 730  :         s->z_err = deflate(&(s->stream), flush);

  000b0	8b 55 0c	 mov	 edx, DWORD PTR _flush$[ebp]
  000b3	52		 push	 edx
  000b4	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	50		 push	 eax
  000b8	e8 00 00 00 00	 call	 _deflate@8
  000bd	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000c0	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 731  :         s->out -= s->stream.avail_out;

  000c3	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000c6	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000c9	8b 4a 68	 mov	 ecx, DWORD PTR [edx+104]
  000cc	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  000cf	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000d2	89 4a 68	 mov	 DWORD PTR [edx+104], ecx

; 732  : 
; 733  :         /* Ignore the second of two consecutive flushes: */
; 734  :         if (len == 0 && s->z_err == Z_BUF_ERROR) s->z_err = Z_OK;

  000d5	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  000d9	75 13		 jne	 SHORT $LN2@do_flush
  000db	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000de	83 78 38 fb	 cmp	 DWORD PTR [eax+56], -5	; fffffffbH
  000e2	75 0a		 jne	 SHORT $LN2@do_flush
  000e4	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000e7	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0
$LN2@do_flush:

; 735  : 
; 736  :         /* deflate has finished flushing only when it hasn't used up
; 737  :          * all the available space in the output buffer:
; 738  :          */
; 739  :         done = (s->stream.avail_out != 0 || s->z_err == Z_STREAM_END);

  000ee	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000f1	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  000f5	75 12		 jne	 SHORT $LN12@do_flush
  000f7	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000fa	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  000fe	74 09		 je	 SHORT $LN12@do_flush
  00100	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR tv137[ebp], 0
  00107	eb 07		 jmp	 SHORT $LN13@do_flush
$LN12@do_flush:
  00109	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR tv137[ebp], 1
$LN13@do_flush:
  00110	8b 4d f0	 mov	 ecx, DWORD PTR tv137[ebp]
  00113	89 4d f4	 mov	 DWORD PTR _done$[ebp], ecx

; 740  : 
; 741  :         if (s->z_err != Z_OK && s->z_err != Z_STREAM_END) break;

  00116	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00119	83 7a 38 00	 cmp	 DWORD PTR [edx+56], 0
  0011d	74 0b		 je	 SHORT $LN1@do_flush
  0011f	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00122	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  00126	74 02		 je	 SHORT $LN1@do_flush
  00128	eb 05		 jmp	 SHORT $LN6@do_flush
$LN1@do_flush:

; 742  :     }

  0012a	e9 0a ff ff ff	 jmp	 $LN7@do_flush
$LN6@do_flush:

; 743  :     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;

  0012f	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00132	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  00136	75 09		 jne	 SHORT $LN14@do_flush
  00138	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR tv145[ebp], 0
  0013f	eb 09		 jmp	 SHORT $LN15@do_flush
$LN14@do_flush:
  00141	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00144	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00147	89 45 ec	 mov	 DWORD PTR tv145[ebp], eax
$LN15@do_flush:
  0014a	8b 45 ec	 mov	 eax, DWORD PTR tv145[ebp]
$LN10@do_flush:

; 744  : }

  0014d	8b e5		 mov	 esp, ebp
  0014f	5d		 pop	 ebp
  00150	c3		 ret	 0
_do_flush ENDP
_TEXT	ENDS
PUBLIC	_gzwrite@12
; Function compile flags: /Odtp
;	COMDAT _gzwrite@12
_TEXT	SEGMENT
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzwrite@12 PROC					; COMDAT

; 563  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 564  :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 565  : 
; 566  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	74 0c		 je	 SHORT $LN6@gzwrite
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00013	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00017	83 fa 77	 cmp	 edx, 119		; 00000077H
  0001a	74 0a		 je	 SHORT $LN7@gzwrite
$LN6@gzwrite:
  0001c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00021	e9 fa 00 00 00	 jmp	 $LN8@gzwrite
$LN7@gzwrite:

; 567  : 
; 568  :     s->stream.next_in = (Bytef*)buf;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00029	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0002c	89 08		 mov	 DWORD PTR [eax], ecx

; 569  :     s->stream.avail_in = len;

  0002e	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00031	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  00034	89 42 04	 mov	 DWORD PTR [edx+4], eax
$LN5@gzwrite:

; 570  : 
; 571  :     while (s->stream.avail_in != 0) {

  00037	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0003a	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  0003e	0f 84 b9 00 00
	00		 je	 $LN4@gzwrite

; 572  : 
; 573  :         if (s->stream.avail_out == 0) {

  00044	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00047	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0004b	75 47		 jne	 SHORT $LN3@gzwrite

; 574  : 
; 575  :             s->stream.next_out = s->outbuf;

  0004d	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00050	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00053	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00056	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 576  :             if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {

  00059	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0005c	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  0005f	51		 push	 ecx
  00060	68 00 40 00 00	 push	 16384			; 00004000H
  00065	6a 01		 push	 1
  00067	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0006a	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  0006d	50		 push	 eax
  0006e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00074	83 c4 10	 add	 esp, 16			; 00000010H
  00077	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0007c	74 0c		 je	 SHORT $LN2@gzwrite

; 577  :                 s->z_err = Z_ERRNO;

  0007e	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00081	c7 41 38 ff ff
	ff ff		 mov	 DWORD PTR [ecx+56], -1

; 578  :                 break;

  00088	eb 73		 jmp	 SHORT $LN4@gzwrite
$LN2@gzwrite:

; 579  :             }
; 580  :             s->stream.avail_out = Z_BUFSIZE;

  0008a	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0008d	c7 42 10 00 40
	00 00		 mov	 DWORD PTR [edx+16], 16384 ; 00004000H
$LN3@gzwrite:

; 581  :         }
; 582  :         s->in += s->stream.avail_in;

  00094	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00097	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0009a	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0009d	03 4a 04	 add	 ecx, DWORD PTR [edx+4]
  000a0	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000a3	89 48 64	 mov	 DWORD PTR [eax+100], ecx

; 583  :         s->out += s->stream.avail_out;

  000a6	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000a9	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  000ac	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000af	03 50 10	 add	 edx, DWORD PTR [eax+16]
  000b2	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000b5	89 51 68	 mov	 DWORD PTR [ecx+104], edx

; 584  :         s->z_err = deflate(&(s->stream), Z_NO_FLUSH);

  000b8	6a 00		 push	 0
  000ba	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000bd	52		 push	 edx
  000be	e8 00 00 00 00	 call	 _deflate@8
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000c6	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 585  :         s->in -= s->stream.avail_in;

  000c9	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000cf	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  000d2	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000d8	89 4a 64	 mov	 DWORD PTR [edx+100], ecx

; 586  :         s->out -= s->stream.avail_out;

  000db	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000de	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000e1	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  000e4	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  000e7	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000ea	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 587  :         if (s->z_err != Z_OK) break;

  000ed	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  000f0	83 79 38 00	 cmp	 DWORD PTR [ecx+56], 0
  000f4	74 02		 je	 SHORT $LN1@gzwrite
  000f6	eb 05		 jmp	 SHORT $LN4@gzwrite
$LN1@gzwrite:

; 588  :     }

  000f8	e9 3a ff ff ff	 jmp	 $LN5@gzwrite
$LN4@gzwrite:

; 589  :     s->crc = crc32(s->crc, (const Bytef *)buf, len);

  000fd	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00100	52		 push	 edx
  00101	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00104	50		 push	 eax
  00105	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00108	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _crc32@12
  00111	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00114	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 590  : 
; 591  :     return (int)(len - s->stream.avail_in);

  00117	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0011a	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  0011d	2b 42 04	 sub	 eax, DWORD PTR [edx+4]
$LN8@gzwrite:

; 592  : }

  00120	8b e5		 mov	 esp, ebp
  00122	5d		 pop	 ebp
  00123	c2 0c 00	 ret	 12			; 0000000cH
_gzwrite@12 ENDP
_TEXT	ENDS
PUBLIC	_gzread@12
; Function compile flags: /Odtp
;	COMDAT _gzread@12
_TEXT	SEGMENT
_n$79222 = -16						; size = 4
_start$ = -12						; size = 4
_s$ = -8						; size = 4
_next_out$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzread@12 PROC						; COMDAT

; 398  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 399  :     gz_stream *s = (gz_stream*)file;

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	89 45 f8	 mov	 DWORD PTR _s$[ebp], eax

; 400  :     Bytef *start = (Bytef*)buf; /* starting point for crc computation */

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0000f	89 4d f4	 mov	 DWORD PTR _start$[ebp], ecx

; 401  :     Byte  *next_out; /* == stream.next_out but not forced far (for MSDOS) */
; 402  : 
; 403  :     if (s == NULL || s->mode != 'r') return Z_STREAM_ERROR;

  00012	83 7d f8 00	 cmp	 DWORD PTR _s$[ebp], 0
  00016	74 0c		 je	 SHORT $LN24@gzread
  00018	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0001b	0f be 42 5c	 movsx	 eax, BYTE PTR [edx+92]
  0001f	83 f8 72	 cmp	 eax, 114		; 00000072H
  00022	74 0a		 je	 SHORT $LN25@gzread
$LN24@gzread:
  00024	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00029	e9 a1 03 00 00	 jmp	 $LN26@gzread
$LN25@gzread:

; 404  : 
; 405  :     if (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO) return -1;

  0002e	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00031	83 79 38 fd	 cmp	 DWORD PTR [ecx+56], -3	; fffffffdH
  00035	74 09		 je	 SHORT $LN22@gzread
  00037	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0003a	83 7a 38 ff	 cmp	 DWORD PTR [edx+56], -1
  0003e	75 08		 jne	 SHORT $LN23@gzread
$LN22@gzread:
  00040	83 c8 ff	 or	 eax, -1
  00043	e9 87 03 00 00	 jmp	 $LN26@gzread
$LN23@gzread:

; 406  :     if (s->z_err == Z_STREAM_END) return 0;  /* EOF */

  00048	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0004b	83 78 38 01	 cmp	 DWORD PTR [eax+56], 1
  0004f	75 07		 jne	 SHORT $LN21@gzread
  00051	33 c0		 xor	 eax, eax
  00053	e9 77 03 00 00	 jmp	 $LN26@gzread
$LN21@gzread:

; 407  : 
; 408  :     next_out = (Byte*)buf;

  00058	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  0005b	89 4d fc	 mov	 DWORD PTR _next_out$[ebp], ecx

; 409  :     s->stream.next_out = (Bytef*)buf;

  0005e	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00061	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00064	89 42 0c	 mov	 DWORD PTR [edx+12], eax

; 410  :     s->stream.avail_out = len;

  00067	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0006a	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0006d	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 411  : 
; 412  :     if (s->stream.avail_out && s->back != EOF) {

  00070	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00073	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  00077	74 7a		 je	 SHORT $LN18@gzread
  00079	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0007c	83 79 6c ff	 cmp	 DWORD PTR [ecx+108], -1
  00080	74 71		 je	 SHORT $LN18@gzread

; 413  :         *next_out++ = s->back;

  00082	8b 55 fc	 mov	 edx, DWORD PTR _next_out$[ebp]
  00085	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00088	8a 48 6c	 mov	 cl, BYTE PTR [eax+108]
  0008b	88 0a		 mov	 BYTE PTR [edx], cl
  0008d	8b 55 fc	 mov	 edx, DWORD PTR _next_out$[ebp]
  00090	83 c2 01	 add	 edx, 1
  00093	89 55 fc	 mov	 DWORD PTR _next_out$[ebp], edx

; 414  :         s->stream.next_out++;

  00096	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00099	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  0009c	83 c1 01	 add	 ecx, 1
  0009f	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000a2	89 4a 0c	 mov	 DWORD PTR [edx+12], ecx

; 415  :         s->stream.avail_out--;

  000a5	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000a8	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  000ab	83 e9 01	 sub	 ecx, 1
  000ae	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000b1	89 4a 10	 mov	 DWORD PTR [edx+16], ecx

; 416  :         s->back = EOF;

  000b4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000b7	c7 40 6c ff ff
	ff ff		 mov	 DWORD PTR [eax+108], -1

; 417  :         s->out++;

  000be	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000c1	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  000c4	83 c2 01	 add	 edx, 1
  000c7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000ca	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 418  :         start++;

  000cd	8b 4d f4	 mov	 ecx, DWORD PTR _start$[ebp]
  000d0	83 c1 01	 add	 ecx, 1
  000d3	89 4d f4	 mov	 DWORD PTR _start$[ebp], ecx

; 419  :         if (s->last) {

  000d6	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  000d9	83 7a 70 00	 cmp	 DWORD PTR [edx+112], 0
  000dd	74 14		 je	 SHORT $LN18@gzread

; 420  :             s->z_err = Z_STREAM_END;

  000df	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  000e2	c7 40 38 01 00
	00 00		 mov	 DWORD PTR [eax+56], 1

; 421  :             return 1;

  000e9	b8 01 00 00 00	 mov	 eax, 1
  000ee	e9 dc 02 00 00	 jmp	 $LN26@gzread
$LN18@gzread:

; 422  :         }
; 423  :     }
; 424  : 
; 425  :     while (s->stream.avail_out != 0) {

  000f3	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  000f6	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  000fa	0f 84 82 02 00
	00		 je	 $LN17@gzread

; 426  : 
; 427  :         if (s->transparent) {

  00100	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00103	83 7a 58 00	 cmp	 DWORD PTR [edx+88], 0
  00107	0f 84 ef 00 00
	00		 je	 $LN16@gzread

; 428  :             /* Copy first the lookahead bytes: */
; 429  :             uInt n = s->stream.avail_in;

  0010d	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00110	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00113	89 4d f0	 mov	 DWORD PTR _n$79222[ebp], ecx

; 430  :             if (n > s->stream.avail_out) n = s->stream.avail_out;

  00116	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00119	8b 45 f0	 mov	 eax, DWORD PTR _n$79222[ebp]
  0011c	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  0011f	76 09		 jbe	 SHORT $LN15@gzread
  00121	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00124	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00127	89 55 f0	 mov	 DWORD PTR _n$79222[ebp], edx
$LN15@gzread:

; 431  :             if (n > 0) {

  0012a	83 7d f0 00	 cmp	 DWORD PTR _n$79222[ebp], 0
  0012e	76 56		 jbe	 SHORT $LN14@gzread

; 432  :                 zmemcpy(s->stream.next_out, s->stream.next_in, n);

  00130	8b 45 f0	 mov	 eax, DWORD PTR _n$79222[ebp]
  00133	50		 push	 eax
  00134	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00137	8b 11		 mov	 edx, DWORD PTR [ecx]
  00139	52		 push	 edx
  0013a	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0013d	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  00140	51		 push	 ecx
  00141	e8 00 00 00 00	 call	 _memcpy
  00146	83 c4 0c	 add	 esp, 12			; 0000000cH

; 433  :                 next_out += n;

  00149	8b 55 fc	 mov	 edx, DWORD PTR _next_out$[ebp]
  0014c	03 55 f0	 add	 edx, DWORD PTR _n$79222[ebp]
  0014f	89 55 fc	 mov	 DWORD PTR _next_out$[ebp], edx

; 434  :                 s->stream.next_out = next_out;

  00152	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00155	8b 4d fc	 mov	 ecx, DWORD PTR _next_out$[ebp]
  00158	89 48 0c	 mov	 DWORD PTR [eax+12], ecx

; 435  :                 s->stream.next_in   += n;

  0015b	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0015e	8b 02		 mov	 eax, DWORD PTR [edx]
  00160	03 45 f0	 add	 eax, DWORD PTR _n$79222[ebp]
  00163	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00166	89 01		 mov	 DWORD PTR [ecx], eax

; 436  :                 s->stream.avail_out -= n;

  00168	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0016b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0016e	2b 45 f0	 sub	 eax, DWORD PTR _n$79222[ebp]
  00171	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00174	89 41 10	 mov	 DWORD PTR [ecx+16], eax

; 437  :                 s->stream.avail_in  -= n;

  00177	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0017a	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  0017d	2b 45 f0	 sub	 eax, DWORD PTR _n$79222[ebp]
  00180	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00183	89 41 04	 mov	 DWORD PTR [ecx+4], eax
$LN14@gzread:

; 438  :             }
; 439  :             if (s->stream.avail_out > 0) {

  00186	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00189	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  0018d	76 2b		 jbe	 SHORT $LN13@gzread

; 440  :                 s->stream.avail_out -=
; 441  :                     (uInt)fread(next_out, 1, s->stream.avail_out, s->file);

  0018f	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00192	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00195	51		 push	 ecx
  00196	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00199	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0019c	50		 push	 eax
  0019d	6a 01		 push	 1
  0019f	8b 4d fc	 mov	 ecx, DWORD PTR _next_out$[ebp]
  001a2	51		 push	 ecx
  001a3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  001a9	83 c4 10	 add	 esp, 16			; 00000010H
  001ac	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001af	8b 4a 10	 mov	 ecx, DWORD PTR [edx+16]
  001b2	2b c8		 sub	 ecx, eax
  001b4	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001b7	89 4a 10	 mov	 DWORD PTR [edx+16], ecx
$LN13@gzread:

; 442  :             }
; 443  :             len -= s->stream.avail_out;

  001ba	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001bd	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  001c0	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  001c3	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx

; 444  :             s->in  += len;

  001c6	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001c9	8b 42 64	 mov	 eax, DWORD PTR [edx+100]
  001cc	03 45 10	 add	 eax, DWORD PTR _len$[ebp]
  001cf	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  001d2	89 41 64	 mov	 DWORD PTR [ecx+100], eax

; 445  :             s->out += len;

  001d5	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001d8	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  001db	03 45 10	 add	 eax, DWORD PTR _len$[ebp]
  001de	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  001e1	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 446  :             if (len == 0) s->z_eof = 1;

  001e4	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  001e8	75 0a		 jne	 SHORT $LN12@gzread
  001ea	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  001ed	c7 42 3c 01 00
	00 00		 mov	 DWORD PTR [edx+60], 1
$LN12@gzread:

; 447  :             return (int)len;

  001f4	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  001f7	e9 d3 01 00 00	 jmp	 $LN26@gzread
$LN16@gzread:

; 448  :         }
; 449  :         if (s->stream.avail_in == 0 && !s->z_eof) {

  001fc	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  001ff	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  00203	75 7a		 jne	 SHORT $LN11@gzread
  00205	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00208	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  0020c	75 71		 jne	 SHORT $LN11@gzread

; 450  : 
; 451  :             errno = 0;

  0020e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00214	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 452  :             s->stream.avail_in = (uInt)fread(s->inbuf, 1, Z_BUFSIZE, s->file);

  0021a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0021d	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00220	50		 push	 eax
  00221	68 00 40 00 00	 push	 16384			; 00004000H
  00226	6a 01		 push	 1
  00228	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0022b	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0022e	52		 push	 edx
  0022f	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fread
  00235	83 c4 10	 add	 esp, 16			; 00000010H
  00238	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0023b	89 41 04	 mov	 DWORD PTR [ecx+4], eax

; 453  :             if (s->stream.avail_in == 0) {

  0023e	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00241	83 7a 04 00	 cmp	 DWORD PTR [edx+4], 0
  00245	75 2d		 jne	 SHORT $LN10@gzread

; 454  :                 s->z_eof = 1;

  00247	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0024a	c7 40 3c 01 00
	00 00		 mov	 DWORD PTR [eax+60], 1

; 455  :                 if (ferror(s->file)) {

  00251	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00254	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00257	52		 push	 edx
  00258	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ferror
  0025e	83 c4 04	 add	 esp, 4
  00261	85 c0		 test	 eax, eax
  00263	74 0f		 je	 SHORT $LN10@gzread

; 456  :                     s->z_err = Z_ERRNO;

  00265	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00268	c7 40 38 ff ff
	ff ff		 mov	 DWORD PTR [eax+56], -1

; 457  :                     break;

  0026f	e9 0e 01 00 00	 jmp	 $LN17@gzread
$LN10@gzread:

; 458  :                 }
; 459  :             }
; 460  :             s->stream.next_in = s->inbuf;

  00274	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00277	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0027a	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0027d	89 01		 mov	 DWORD PTR [ecx], eax
$LN11@gzread:

; 461  :         }
; 462  :         s->in += s->stream.avail_in;

  0027f	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00282	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00285	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00288	03 50 04	 add	 edx, DWORD PTR [eax+4]
  0028b	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0028e	89 51 64	 mov	 DWORD PTR [ecx+100], edx

; 463  :         s->out += s->stream.avail_out;

  00291	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00294	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00297	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0029a	03 41 10	 add	 eax, DWORD PTR [ecx+16]
  0029d	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  002a0	89 42 68	 mov	 DWORD PTR [edx+104], eax

; 464  :         s->z_err = inflate(&(s->stream), Z_NO_FLUSH);

  002a3	6a 00		 push	 0
  002a5	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  002a8	50		 push	 eax
  002a9	e8 00 00 00 00	 call	 _inflate@8
  002ae	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  002b1	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 465  :         s->in -= s->stream.avail_in;

  002b4	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  002b7	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  002ba	8b 4a 64	 mov	 ecx, DWORD PTR [edx+100]
  002bd	2b 48 04	 sub	 ecx, DWORD PTR [eax+4]
  002c0	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  002c3	89 4a 64	 mov	 DWORD PTR [edx+100], ecx

; 466  :         s->out -= s->stream.avail_out;

  002c6	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  002c9	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  002cc	8b 50 68	 mov	 edx, DWORD PTR [eax+104]
  002cf	2b 51 10	 sub	 edx, DWORD PTR [ecx+16]
  002d2	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  002d5	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 467  : 
; 468  :         if (s->z_err == Z_STREAM_END) {

  002d8	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  002db	83 79 38 01	 cmp	 DWORD PTR [ecx+56], 1
  002df	0f 85 84 00 00
	00		 jne	 $LN8@gzread

; 469  :             /* Check CRC and original size */
; 470  :             s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

  002e5	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  002e8	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  002eb	2b 45 f4	 sub	 eax, DWORD PTR _start$[ebp]
  002ee	50		 push	 eax
  002ef	8b 4d f4	 mov	 ecx, DWORD PTR _start$[ebp]
  002f2	51		 push	 ecx
  002f3	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  002f6	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  002f9	50		 push	 eax
  002fa	e8 00 00 00 00	 call	 _crc32@12
  002ff	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00302	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 471  :             start = s->stream.next_out;

  00305	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00308	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  0030b	89 45 f4	 mov	 DWORD PTR _start$[ebp], eax

; 472  : 
; 473  :             if (getLong(s) != s->crc) {

  0030e	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00311	51		 push	 ecx
  00312	e8 00 00 00 00	 call	 _getLong
  00317	83 c4 04	 add	 esp, 4
  0031a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0031d	3b 42 4c	 cmp	 eax, DWORD PTR [edx+76]
  00320	74 0c		 je	 SHORT $LN7@gzread

; 474  :                 s->z_err = Z_DATA_ERROR;

  00322	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00325	c7 40 38 fd ff
	ff ff		 mov	 DWORD PTR [eax+56], -3	; fffffffdH

; 475  :             } else {

  0032c	eb 3b		 jmp	 SHORT $LN8@gzread
$LN7@gzread:

; 476  :                 (void)getLong(s);

  0032e	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00331	51		 push	 ecx
  00332	e8 00 00 00 00	 call	 _getLong
  00337	83 c4 04	 add	 esp, 4

; 477  :                 /* The uncompressed length returned by above getlong() may be
; 478  :                  * different from s->out in case of concatenated .gz files.
; 479  :                  * Check for such files:
; 480  :                  */
; 481  :                 check_header(s);

  0033a	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  0033d	52		 push	 edx
  0033e	e8 00 00 00 00	 call	 _check_header
  00343	83 c4 04	 add	 esp, 4

; 482  :                 if (s->z_err == Z_OK) {

  00346	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  00349	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  0034d	75 1a		 jne	 SHORT $LN8@gzread

; 483  :                     inflateReset(&(s->stream));

  0034f	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00352	51		 push	 ecx
  00353	e8 00 00 00 00	 call	 _inflateReset@4

; 484  :                     s->crc = crc32(0L, Z_NULL, 0);

  00358	6a 00		 push	 0
  0035a	6a 00		 push	 0
  0035c	6a 00		 push	 0
  0035e	e8 00 00 00 00	 call	 _crc32@12
  00363	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00366	89 42 4c	 mov	 DWORD PTR [edx+76], eax
$LN8@gzread:

; 485  :                 }
; 486  :             }
; 487  :         }
; 488  :         if (s->z_err != Z_OK || s->z_eof) break;

  00369	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  0036c	83 78 38 00	 cmp	 DWORD PTR [eax+56], 0
  00370	75 09		 jne	 SHORT $LN3@gzread
  00372	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  00375	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00379	74 02		 je	 SHORT $LN4@gzread
$LN3@gzread:
  0037b	eb 05		 jmp	 SHORT $LN17@gzread
$LN4@gzread:

; 489  :     }

  0037d	e9 71 fd ff ff	 jmp	 $LN18@gzread
$LN17@gzread:

; 490  :     s->crc = crc32(s->crc, start, (uInt)(s->stream.next_out - start));

  00382	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00385	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00388	2b 45 f4	 sub	 eax, DWORD PTR _start$[ebp]
  0038b	50		 push	 eax
  0038c	8b 4d f4	 mov	 ecx, DWORD PTR _start$[ebp]
  0038f	51		 push	 ecx
  00390	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  00393	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00396	50		 push	 eax
  00397	e8 00 00 00 00	 call	 _crc32@12
  0039c	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  0039f	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 491  : 
; 492  :     if (len == s->stream.avail_out &&
; 493  :         (s->z_err == Z_DATA_ERROR || s->z_err == Z_ERRNO))

  003a2	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  003a5	8b 45 10	 mov	 eax, DWORD PTR _len$[ebp]
  003a8	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  003ab	75 17		 jne	 SHORT $LN2@gzread
  003ad	8b 4d f8	 mov	 ecx, DWORD PTR _s$[ebp]
  003b0	83 79 38 fd	 cmp	 DWORD PTR [ecx+56], -3	; fffffffdH
  003b4	74 09		 je	 SHORT $LN1@gzread
  003b6	8b 55 f8	 mov	 edx, DWORD PTR _s$[ebp]
  003b9	83 7a 38 ff	 cmp	 DWORD PTR [edx+56], -1
  003bd	75 05		 jne	 SHORT $LN2@gzread
$LN1@gzread:

; 494  :         return -1;

  003bf	83 c8 ff	 or	 eax, -1
  003c2	eb 0b		 jmp	 SHORT $LN26@gzread
$LN2@gzread:

; 495  :     return (int)(len - s->stream.avail_out);

  003c4	8b 45 f8	 mov	 eax, DWORD PTR _s$[ebp]
  003c7	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  003ca	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  003cd	8b c1		 mov	 eax, ecx
$LN26@gzread:

; 496  : }

  003cf	8b e5		 mov	 esp, ebp
  003d1	5d		 pop	 ebp
  003d2	c2 0c 00	 ret	 12			; 0000000cH
_gzread@12 ENDP
_TEXT	ENDS
PUBLIC	_gzsetparams@12
; Function compile flags: /Odtp
;	COMDAT _gzsetparams@12
_TEXT	SEGMENT
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_level$ = 12						; size = 4
_strategy$ = 16						; size = 4
_gzsetparams@12 PROC					; COMDAT

; 238  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 239  :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 240  : 
; 241  :     if (s == NULL || s->mode != 'w') return Z_STREAM_ERROR;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	74 0c		 je	 SHORT $LN3@gzsetparam
  00010	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00013	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  00017	83 fa 77	 cmp	 edx, 119		; 00000077H
  0001a	74 07		 je	 SHORT $LN4@gzsetparam
$LN3@gzsetparam:
  0001c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00021	eb 5f		 jmp	 SHORT $LN5@gzsetparam
$LN4@gzsetparam:

; 242  : 
; 243  :     /* Make room to allow flushing */
; 244  :     if (s->stream.avail_out == 0) {

  00023	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00026	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  0002a	75 45		 jne	 SHORT $LN2@gzsetparam

; 245  : 
; 246  :         s->stream.next_out = s->outbuf;

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0002f	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00032	8b 42 48	 mov	 eax, DWORD PTR [edx+72]
  00035	89 41 0c	 mov	 DWORD PTR [ecx+12], eax

; 247  :         if (fwrite(s->outbuf, 1, Z_BUFSIZE, s->file) != Z_BUFSIZE) {

  00038	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0003b	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0003e	52		 push	 edx
  0003f	68 00 40 00 00	 push	 16384			; 00004000H
  00044	6a 01		 push	 1
  00046	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00049	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  0004c	51		 push	 ecx
  0004d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fwrite
  00053	83 c4 10	 add	 esp, 16			; 00000010H
  00056	3d 00 40 00 00	 cmp	 eax, 16384		; 00004000H
  0005b	74 0a		 je	 SHORT $LN1@gzsetparam

; 248  :             s->z_err = Z_ERRNO;

  0005d	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00060	c7 42 38 ff ff
	ff ff		 mov	 DWORD PTR [edx+56], -1
$LN1@gzsetparam:

; 249  :         }
; 250  :         s->stream.avail_out = Z_BUFSIZE;

  00067	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0006a	c7 40 10 00 40
	00 00		 mov	 DWORD PTR [eax+16], 16384 ; 00004000H
$LN2@gzsetparam:

; 251  :     }
; 252  : 
; 253  :     return deflateParams (&(s->stream), level, strategy);

  00071	8b 4d 10	 mov	 ecx, DWORD PTR _strategy$[ebp]
  00074	51		 push	 ecx
  00075	8b 55 0c	 mov	 edx, DWORD PTR _level$[ebp]
  00078	52		 push	 edx
  00079	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0007c	50		 push	 eax
  0007d	e8 00 00 00 00	 call	 _deflateParams@12
$LN5@gzsetparam:

; 254  : }

  00082	8b e5		 mov	 esp, ebp
  00084	5d		 pop	 ebp
  00085	c2 0c 00	 ret	 12			; 0000000cH
_gzsetparams@12 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _gz_open
_TEXT	SEGMENT
tv209 = -108						; size = 4
_fmode$ = -104						; size = 80
_m$ = -24						; size = 4
_err$ = -20						; size = 4
_strategy$ = -16					; size = 4
_s$ = -12						; size = 4
_level$ = -8						; size = 4
_p$ = -4						; size = 4
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_fd$ = 16						; size = 4
_gz_open PROC						; COMDAT

; 97   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 6c	 sub	 esp, 108		; 0000006cH

; 98   :     int err;
; 99   :     int level = Z_DEFAULT_COMPRESSION; /* compression level */

  00006	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR _level$[ebp], -1

; 100  :     int strategy = Z_DEFAULT_STRATEGY; /* compression strategy */

  0000d	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _strategy$[ebp], 0

; 101  :     char *p = (char*)mode;

  00014	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00017	89 45 fc	 mov	 DWORD PTR _p$[ebp], eax

; 102  :     gz_stream *s;
; 103  :     char fmode[80]; /* copy of mode, without the compression level */
; 104  :     char *m = fmode;

  0001a	8d 4d 98	 lea	 ecx, DWORD PTR _fmode$[ebp]
  0001d	89 4d e8	 mov	 DWORD PTR _m$[ebp], ecx

; 105  : 
; 106  :     if (!path || !mode) return Z_NULL;

  00020	83 7d 08 00	 cmp	 DWORD PTR _path$[ebp], 0
  00024	74 06		 je	 SHORT $LN28@gz_open
  00026	83 7d 0c 00	 cmp	 DWORD PTR _mode$[ebp], 0
  0002a	75 07		 jne	 SHORT $LN29@gz_open
$LN28@gz_open:
  0002c	33 c0		 xor	 eax, eax
  0002e	e9 ad 03 00 00	 jmp	 $LN30@gz_open
$LN29@gz_open:

; 107  : 
; 108  :     s = (gz_stream *)ALLOC(sizeof(gz_stream));

  00033	6a 74		 push	 116			; 00000074H
  00035	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0003b	83 c4 04	 add	 esp, 4
  0003e	89 45 f4	 mov	 DWORD PTR _s$[ebp], eax

; 109  :     if (!s) return Z_NULL;

  00041	83 7d f4 00	 cmp	 DWORD PTR _s$[ebp], 0
  00045	75 07		 jne	 SHORT $LN27@gz_open
  00047	33 c0		 xor	 eax, eax
  00049	e9 92 03 00 00	 jmp	 $LN30@gz_open
$LN27@gz_open:

; 110  : 
; 111  :     s->stream.zalloc = (alloc_func)0;

  0004e	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  00051	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], 0

; 112  :     s->stream.zfree = (free_func)0;

  00058	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  0005b	c7 40 24 00 00
	00 00		 mov	 DWORD PTR [eax+36], 0

; 113  :     s->stream.opaque = (voidpf)0;

  00062	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00065	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 114  :     s->stream.next_in = s->inbuf = Z_NULL;

  0006c	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0006f	c7 42 44 00 00
	00 00		 mov	 DWORD PTR [edx+68], 0
  00076	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00079	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 115  :     s->stream.next_out = s->outbuf = Z_NULL;

  0007f	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00082	c7 41 48 00 00
	00 00		 mov	 DWORD PTR [ecx+72], 0
  00089	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0008c	c7 42 0c 00 00
	00 00		 mov	 DWORD PTR [edx+12], 0

; 116  :     s->stream.avail_in = s->stream.avail_out = 0;

  00093	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00096	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
  0009d	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  000a0	c7 41 04 00 00
	00 00		 mov	 DWORD PTR [ecx+4], 0

; 117  :     s->file = NULL;

  000a7	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  000aa	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 118  :     s->z_err = Z_OK;

  000b1	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  000b4	c7 40 38 00 00
	00 00		 mov	 DWORD PTR [eax+56], 0

; 119  :     s->z_eof = 0;

  000bb	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  000be	c7 41 3c 00 00
	00 00		 mov	 DWORD PTR [ecx+60], 0

; 120  :     s->in = 0;

  000c5	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  000c8	c7 42 64 00 00
	00 00		 mov	 DWORD PTR [edx+100], 0

; 121  :     s->out = 0;

  000cf	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  000d2	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 122  :     s->back = EOF;

  000d9	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  000dc	c7 41 6c ff ff
	ff ff		 mov	 DWORD PTR [ecx+108], -1

; 123  :     s->crc = crc32(0L, Z_NULL, 0);

  000e3	6a 00		 push	 0
  000e5	6a 00		 push	 0
  000e7	6a 00		 push	 0
  000e9	e8 00 00 00 00	 call	 _crc32@12
  000ee	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  000f1	89 42 4c	 mov	 DWORD PTR [edx+76], eax

; 124  :     s->msg = NULL;

  000f4	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  000f7	c7 40 50 00 00
	00 00		 mov	 DWORD PTR [eax+80], 0

; 125  :     s->transparent = 0;

  000fe	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00101	c7 41 58 00 00
	00 00		 mov	 DWORD PTR [ecx+88], 0

; 126  : 
; 127  :     s->path = (char*)ALLOC(strlen(path)+1);

  00108	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  0010b	52		 push	 edx
  0010c	e8 00 00 00 00	 call	 _strlen
  00111	83 c4 04	 add	 esp, 4
  00114	83 c0 01	 add	 eax, 1
  00117	50		 push	 eax
  00118	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  0011e	83 c4 04	 add	 esp, 4
  00121	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00124	89 41 54	 mov	 DWORD PTR [ecx+84], eax

; 128  :     if (s->path == NULL) {

  00127	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0012a	83 7a 54 00	 cmp	 DWORD PTR [edx+84], 0
  0012e	75 13		 jne	 SHORT $LN26@gz_open

; 129  :         return destroy(s), (gzFile)Z_NULL;

  00130	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00133	50		 push	 eax
  00134	e8 00 00 00 00	 call	 _destroy
  00139	83 c4 04	 add	 esp, 4
  0013c	33 c0		 xor	 eax, eax
  0013e	e9 9d 02 00 00	 jmp	 $LN30@gz_open
$LN26@gz_open:

; 130  :     }
; 131  :     strcpy(s->path, path); /* do this early for debugging */

  00143	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  00146	51		 push	 ecx
  00147	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0014a	8b 42 54	 mov	 eax, DWORD PTR [edx+84]
  0014d	50		 push	 eax
  0014e	e8 00 00 00 00	 call	 _strcpy
  00153	83 c4 08	 add	 esp, 8

; 132  : 
; 133  :     s->mode = '\0';

  00156	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00159	c6 41 5c 00	 mov	 BYTE PTR [ecx+92], 0
$LN25@gz_open:

; 134  :     do {
; 135  :         if (*p == 'r') s->mode = 'r';

  0015d	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00160	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00163	83 f8 72	 cmp	 eax, 114		; 00000072H
  00166	75 07		 jne	 SHORT $LN22@gz_open
  00168	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  0016b	c6 41 5c 72	 mov	 BYTE PTR [ecx+92], 114	; 00000072H
$LN22@gz_open:

; 136  :         if (*p == 'w' || *p == 'a') s->mode = 'w';

  0016f	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00172	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00175	83 f8 77	 cmp	 eax, 119		; 00000077H
  00178	74 0b		 je	 SHORT $LN20@gz_open
  0017a	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0017d	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00180	83 fa 61	 cmp	 edx, 97			; 00000061H
  00183	75 07		 jne	 SHORT $LN21@gz_open
$LN20@gz_open:
  00185	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00188	c6 40 5c 77	 mov	 BYTE PTR [eax+92], 119	; 00000077H
$LN21@gz_open:

; 137  :         if (*p >= '0' && *p <= '9') {

  0018c	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  0018f	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00192	83 fa 30	 cmp	 edx, 48			; 00000030H
  00195	7c 19		 jl	 SHORT $LN19@gz_open
  00197	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  0019a	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  0019d	83 f9 39	 cmp	 ecx, 57			; 00000039H
  001a0	7f 0e		 jg	 SHORT $LN19@gz_open

; 138  :             level = *p - '0';

  001a2	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  001a5	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001a8	83 e8 30	 sub	 eax, 48			; 00000030H
  001ab	89 45 f8	 mov	 DWORD PTR _level$[ebp], eax
  001ae	eb 4f		 jmp	 SHORT $LN24@gz_open
$LN19@gz_open:

; 139  :         } else if (*p == 'f') {

  001b0	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  001b3	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  001b6	83 fa 66	 cmp	 edx, 102		; 00000066H
  001b9	75 09		 jne	 SHORT $LN17@gz_open

; 140  :           strategy = Z_FILTERED;

  001bb	c7 45 f0 01 00
	00 00		 mov	 DWORD PTR _strategy$[ebp], 1
  001c2	eb 3b		 jmp	 SHORT $LN24@gz_open
$LN17@gz_open:

; 141  :         } else if (*p == 'h') {

  001c4	8b 45 fc	 mov	 eax, DWORD PTR _p$[ebp]
  001c7	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  001ca	83 f9 68	 cmp	 ecx, 104		; 00000068H
  001cd	75 09		 jne	 SHORT $LN15@gz_open

; 142  :           strategy = Z_HUFFMAN_ONLY;

  001cf	c7 45 f0 02 00
	00 00		 mov	 DWORD PTR _strategy$[ebp], 2
  001d6	eb 27		 jmp	 SHORT $LN24@gz_open
$LN15@gz_open:

; 143  :         } else if (*p == 'R') {

  001d8	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  001db	0f be 02	 movsx	 eax, BYTE PTR [edx]
  001de	83 f8 52	 cmp	 eax, 82			; 00000052H
  001e1	75 09		 jne	 SHORT $LN13@gz_open

; 144  :           strategy = Z_RLE;

  001e3	c7 45 f0 03 00
	00 00		 mov	 DWORD PTR _strategy$[ebp], 3

; 145  :         } else {

  001ea	eb 13		 jmp	 SHORT $LN24@gz_open
$LN13@gz_open:

; 146  :             *m++ = *p; /* copy the mode */

  001ec	8b 4d e8	 mov	 ecx, DWORD PTR _m$[ebp]
  001ef	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  001f2	8a 02		 mov	 al, BYTE PTR [edx]
  001f4	88 01		 mov	 BYTE PTR [ecx], al
  001f6	8b 4d e8	 mov	 ecx, DWORD PTR _m$[ebp]
  001f9	83 c1 01	 add	 ecx, 1
  001fc	89 4d e8	 mov	 DWORD PTR _m$[ebp], ecx
$LN24@gz_open:

; 147  :         }
; 148  :     } while (*p++ && m != fmode + sizeof(fmode));

  001ff	8b 55 fc	 mov	 edx, DWORD PTR _p$[ebp]
  00202	0f be 02	 movsx	 eax, BYTE PTR [edx]
  00205	8b 4d fc	 mov	 ecx, DWORD PTR _p$[ebp]
  00208	83 c1 01	 add	 ecx, 1
  0020b	89 4d fc	 mov	 DWORD PTR _p$[ebp], ecx
  0020e	85 c0		 test	 eax, eax
  00210	74 0c		 je	 SHORT $LN23@gz_open
  00212	8d 55 e8	 lea	 edx, DWORD PTR _fmode$[ebp+80]
  00215	39 55 e8	 cmp	 DWORD PTR _m$[ebp], edx
  00218	0f 85 3f ff ff
	ff		 jne	 $LN25@gz_open
$LN23@gz_open:

; 149  :     if (s->mode == '\0') return destroy(s), (gzFile)Z_NULL;

  0021e	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00221	0f be 48 5c	 movsx	 ecx, BYTE PTR [eax+92]
  00225	85 c9		 test	 ecx, ecx
  00227	75 13		 jne	 SHORT $LN10@gz_open
  00229	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0022c	52		 push	 edx
  0022d	e8 00 00 00 00	 call	 _destroy
  00232	83 c4 04	 add	 esp, 4
  00235	33 c0		 xor	 eax, eax
  00237	e9 a4 01 00 00	 jmp	 $LN30@gz_open
$LN10@gz_open:

; 150  : 
; 151  :     if (s->mode == 'w') {

  0023c	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  0023f	0f be 48 5c	 movsx	 ecx, BYTE PTR [eax+92]
  00243	83 f9 77	 cmp	 ecx, 119		; 00000077H
  00246	75 65		 jne	 SHORT $LN9@gz_open

; 152  : #ifdef NO_GZCOMPRESS
; 153  :         err = Z_STREAM_ERROR;
; 154  : #else
; 155  :         err = deflateInit2(&(s->stream), level,
; 156  :                            Z_DEFLATED, -MAX_WBITS, DEF_MEM_LEVEL, strategy);

  00248	6a 38		 push	 56			; 00000038H
  0024a	68 00 00 00 00	 push	 OFFSET ??_C@_05GDHACFMB@1?42?43?$AA@
  0024f	8b 55 f0	 mov	 edx, DWORD PTR _strategy$[ebp]
  00252	52		 push	 edx
  00253	6a 08		 push	 8
  00255	6a f1		 push	 -15			; fffffff1H
  00257	6a 08		 push	 8
  00259	8b 45 f8	 mov	 eax, DWORD PTR _level$[ebp]
  0025c	50		 push	 eax
  0025d	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00260	51		 push	 ecx
  00261	e8 00 00 00 00	 call	 _deflateInit2_@32
  00266	89 45 ec	 mov	 DWORD PTR _err$[ebp], eax

; 157  :         /* windowBits is passed < 0 to suppress zlib header */
; 158  : 
; 159  :         s->stream.next_out = s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);

  00269	68 00 40 00 00	 push	 16384			; 00004000H
  0026e	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00274	83 c4 04	 add	 esp, 4
  00277	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0027a	89 42 48	 mov	 DWORD PTR [edx+72], eax
  0027d	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00280	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00283	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  00286	89 50 0c	 mov	 DWORD PTR [eax+12], edx

; 160  : #endif
; 161  :         if (err != Z_OK || s->outbuf == Z_NULL) {

  00289	83 7d ec 00	 cmp	 DWORD PTR _err$[ebp], 0
  0028d	75 09		 jne	 SHORT $LN7@gz_open
  0028f	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00292	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00296	75 13		 jne	 SHORT $LN8@gz_open
$LN7@gz_open:

; 162  :             return destroy(s), (gzFile)Z_NULL;

  00298	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  0029b	51		 push	 ecx
  0029c	e8 00 00 00 00	 call	 _destroy
  002a1	83 c4 04	 add	 esp, 4
  002a4	33 c0		 xor	 eax, eax
  002a6	e9 35 01 00 00	 jmp	 $LN30@gz_open
$LN8@gz_open:

; 163  :         }
; 164  :     } else {

  002ab	eb 56		 jmp	 SHORT $LN6@gz_open
$LN9@gz_open:

; 165  :         s->stream.next_in  = s->inbuf = (Byte*)ALLOC(Z_BUFSIZE);

  002ad	68 00 40 00 00	 push	 16384			; 00004000H
  002b2	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  002b8	83 c4 04	 add	 esp, 4
  002bb	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  002be	89 42 44	 mov	 DWORD PTR [edx+68], eax
  002c1	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  002c4	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  002c7	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  002ca	89 10		 mov	 DWORD PTR [eax], edx

; 166  : 
; 167  :         err = inflateInit2(&(s->stream), -MAX_WBITS);

  002cc	6a 38		 push	 56			; 00000038H
  002ce	68 00 00 00 00	 push	 OFFSET ??_C@_05GDHACFMB@1?42?43?$AA@
  002d3	6a f1		 push	 -15			; fffffff1H
  002d5	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  002d8	50		 push	 eax
  002d9	e8 00 00 00 00	 call	 _inflateInit2_@16
  002de	89 45 ec	 mov	 DWORD PTR _err$[ebp], eax

; 168  :         /* windowBits is passed < 0 to tell that there is no zlib header.
; 169  :          * Note that in this case inflate *requires* an extra "dummy" byte
; 170  :          * after the compressed stream in order to complete decompression and
; 171  :          * return Z_STREAM_END. Here the gzip CRC32 ensures that 4 bytes are
; 172  :          * present after the compressed stream.
; 173  :          */
; 174  :         if (err != Z_OK || s->inbuf == Z_NULL) {

  002e1	83 7d ec 00	 cmp	 DWORD PTR _err$[ebp], 0
  002e5	75 09		 jne	 SHORT $LN4@gz_open
  002e7	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  002ea	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  002ee	75 13		 jne	 SHORT $LN6@gz_open
$LN4@gz_open:

; 175  :             return destroy(s), (gzFile)Z_NULL;

  002f0	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  002f3	52		 push	 edx
  002f4	e8 00 00 00 00	 call	 _destroy
  002f9	83 c4 04	 add	 esp, 4
  002fc	33 c0		 xor	 eax, eax
  002fe	e9 dd 00 00 00	 jmp	 $LN30@gz_open
$LN6@gz_open:

; 176  :         }
; 177  :     }
; 178  :     s->stream.avail_out = Z_BUFSIZE;

  00303	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  00306	c7 40 10 00 40
	00 00		 mov	 DWORD PTR [eax+16], 16384 ; 00004000H

; 179  : 
; 180  :     errno = 0;

  0030d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___errno
  00313	c7 00 00 00 00
	00		 mov	 DWORD PTR [eax], 0

; 181  :     s->file = fd < 0 ? F_OPEN(path, fmode) : (FILE*)fdopen(fd, fmode);

  00319	83 7d 10 00	 cmp	 DWORD PTR _fd$[ebp], 0
  0031d	7d 16		 jge	 SHORT $LN32@gz_open
  0031f	8d 4d 98	 lea	 ecx, DWORD PTR _fmode$[ebp]
  00322	51		 push	 ecx
  00323	8b 55 08	 mov	 edx, DWORD PTR _path$[ebp]
  00326	52		 push	 edx
  00327	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fopen
  0032d	83 c4 08	 add	 esp, 8
  00330	89 45 94	 mov	 DWORD PTR tv209[ebp], eax
  00333	eb 14		 jmp	 SHORT $LN33@gz_open
$LN32@gz_open:
  00335	8d 45 98	 lea	 eax, DWORD PTR _fmode$[ebp]
  00338	50		 push	 eax
  00339	8b 4d 10	 mov	 ecx, DWORD PTR _fd$[ebp]
  0033c	51		 push	 ecx
  0033d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___fdopen
  00343	83 c4 08	 add	 esp, 8
  00346	89 45 94	 mov	 DWORD PTR tv209[ebp], eax
$LN33@gz_open:
  00349	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0034c	8b 45 94	 mov	 eax, DWORD PTR tv209[ebp]
  0034f	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 182  : 
; 183  :     if (s->file == NULL) {

  00352	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  00355	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00359	75 10		 jne	 SHORT $LN3@gz_open

; 184  :         return destroy(s), (gzFile)Z_NULL;

  0035b	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  0035e	52		 push	 edx
  0035f	e8 00 00 00 00	 call	 _destroy
  00364	83 c4 04	 add	 esp, 4
  00367	33 c0		 xor	 eax, eax
  00369	eb 75		 jmp	 SHORT $LN30@gz_open
$LN3@gz_open:

; 185  :     }
; 186  :     if (s->mode == 'w') {

  0036b	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  0036e	0f be 48 5c	 movsx	 ecx, BYTE PTR [eax+92]
  00372	83 f9 77	 cmp	 ecx, 119		; 00000077H
  00375	75 3e		 jne	 SHORT $LN2@gz_open

; 187  :         /* Write a very simple .gz header:
; 188  :          */
; 189  :         fprintf(s->file, "%c%c%c%c%c%c%c%c%c%c", gz_magic[0], gz_magic[1],
; 190  :              Z_DEFLATED, 0 /*flags*/, 0,0,0,0 /*time*/, 0 /*xflags*/, OS_CODE);

  00377	6a 0b		 push	 11			; 0000000bH
  00379	6a 00		 push	 0
  0037b	6a 00		 push	 0
  0037d	6a 00		 push	 0
  0037f	6a 00		 push	 0
  00381	6a 00		 push	 0
  00383	6a 00		 push	 0
  00385	6a 08		 push	 8
  00387	8b 15 04 00 00
	00		 mov	 edx, DWORD PTR _gz_magic+4
  0038d	52		 push	 edx
  0038e	a1 00 00 00 00	 mov	 eax, DWORD PTR _gz_magic
  00393	50		 push	 eax
  00394	68 00 00 00 00	 push	 OFFSET ??_C@_0BF@FJABJDFD@?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$CFc?$AA@
  00399	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  0039c	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  0039f	52		 push	 edx
  003a0	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fprintf
  003a6	83 c4 30	 add	 esp, 48			; 00000030H

; 191  :         s->start = 10L;

  003a9	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
  003ac	c7 40 60 0a 00
	00 00		 mov	 DWORD PTR [eax+96], 10	; 0000000aH

; 192  :         /* We use 10L instead of ftell(s->file) to because ftell causes an
; 193  :          * fflush on some systems. This version of the library doesn't use
; 194  :          * start anyway in write mode, so this initialization is not
; 195  :          * necessary.
; 196  :          */
; 197  :     } else {

  003b3	eb 28		 jmp	 SHORT $LN1@gz_open
$LN2@gz_open:

; 198  :         check_header(s); /* skip the .gz header */

  003b5	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  003b8	51		 push	 ecx
  003b9	e8 00 00 00 00	 call	 _check_header
  003be	83 c4 04	 add	 esp, 4

; 199  :         s->start = ftell(s->file) - s->stream.avail_in;

  003c1	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  003c4	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  003c7	50		 push	 eax
  003c8	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__ftell
  003ce	83 c4 04	 add	 esp, 4
  003d1	8b 4d f4	 mov	 ecx, DWORD PTR _s$[ebp]
  003d4	2b 41 04	 sub	 eax, DWORD PTR [ecx+4]
  003d7	8b 55 f4	 mov	 edx, DWORD PTR _s$[ebp]
  003da	89 42 60	 mov	 DWORD PTR [edx+96], eax
$LN1@gz_open:

; 200  :     }
; 201  : 
; 202  :     return (gzFile)s;

  003dd	8b 45 f4	 mov	 eax, DWORD PTR _s$[ebp]
$LN30@gz_open:

; 203  : }

  003e0	8b e5		 mov	 esp, ebp
  003e2	5d		 pop	 ebp
  003e3	c3		 ret	 0
_gz_open ENDP
PUBLIC	_gzclose@4
; Function compile flags: /Odtp
;	COMDAT _gzclose@4
_TEXT	SEGMENT
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_gzclose@4 PROC						; COMDAT

; 955  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 956  :     gz_stream *s = (gz_stream*)file;

  00004	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00007	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 957  : 
; 958  :     if (s == NULL) return Z_STREAM_ERROR;

  0000a	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  0000e	75 07		 jne	 SHORT $LN3@gzclose
  00010	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00015	eb 64		 jmp	 SHORT $LN4@gzclose
$LN3@gzclose:

; 959  : 
; 960  :     if (s->mode == 'w') {

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0001a	0f be 51 5c	 movsx	 edx, BYTE PTR [ecx+92]
  0001e	83 fa 77	 cmp	 edx, 119		; 00000077H
  00021	75 4c		 jne	 SHORT $LN2@gzclose

; 961  : #ifdef NO_GZCOMPRESS
; 962  :         return Z_STREAM_ERROR;
; 963  : #else
; 964  :         if (do_flush (file, Z_FINISH) != Z_OK)

  00023	6a 04		 push	 4
  00025	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00028	50		 push	 eax
  00029	e8 00 00 00 00	 call	 _do_flush
  0002e	83 c4 08	 add	 esp, 8
  00031	85 c0		 test	 eax, eax
  00033	74 0e		 je	 SHORT $LN1@gzclose

; 965  :             return destroy((gz_stream*)file);

  00035	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00038	51		 push	 ecx
  00039	e8 00 00 00 00	 call	 _destroy
  0003e	83 c4 04	 add	 esp, 4
  00041	eb 38		 jmp	 SHORT $LN4@gzclose
$LN1@gzclose:

; 966  : 
; 967  :         putLong (s->file, s->crc);

  00043	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00046	8b 42 4c	 mov	 eax, DWORD PTR [edx+76]
  00049	50		 push	 eax
  0004a	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0004d	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00050	52		 push	 edx
  00051	e8 00 00 00 00	 call	 _putLong
  00056	83 c4 08	 add	 esp, 8

; 968  :         putLong (s->file, (uLong)(s->in & 0xffffffff));

  00059	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0005c	8b 48 64	 mov	 ecx, DWORD PTR [eax+100]
  0005f	51		 push	 ecx
  00060	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00063	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00066	50		 push	 eax
  00067	e8 00 00 00 00	 call	 _putLong
  0006c	83 c4 08	 add	 esp, 8
$LN2@gzclose:

; 969  : #endif
; 970  :     }
; 971  :     return destroy((gz_stream*)file);

  0006f	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00072	51		 push	 ecx
  00073	e8 00 00 00 00	 call	 _destroy
  00078	83 c4 04	 add	 esp, 4
$LN4@gzclose:

; 972  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 04 00	 ret	 4
_gzclose@4 ENDP
_TEXT	ENDS
PUBLIC	_gzseek@12
; Function compile flags: /Odtp
;	COMDAT _gzseek@12
_TEXT	SEGMENT
_size$79384 = -12					; size = 4
_size$79365 = -8					; size = 4
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_offset$ = 12						; size = 4
_whence$ = 16						; size = 4
_gzseek@12 PROC						; COMDAT

; 771  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 772  :     gz_stream *s = (gz_stream*)file;

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 773  : 
; 774  :     if (s == NULL || whence == SEEK_END ||
; 775  :         s->z_err == Z_ERRNO || s->z_err == Z_DATA_ERROR) {

  0000c	83 7d fc 00	 cmp	 DWORD PTR _s$[ebp], 0
  00010	74 18		 je	 SHORT $LN25@gzseek
  00012	83 7d 10 02	 cmp	 DWORD PTR _whence$[ebp], 2
  00016	74 12		 je	 SHORT $LN25@gzseek
  00018	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0001b	83 79 38 ff	 cmp	 DWORD PTR [ecx+56], -1
  0001f	74 09		 je	 SHORT $LN25@gzseek
  00021	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00024	83 7a 38 fd	 cmp	 DWORD PTR [edx+56], -3	; fffffffdH
  00028	75 08		 jne	 SHORT $LN26@gzseek
$LN25@gzseek:

; 776  :         return -1L;

  0002a	83 c8 ff	 or	 eax, -1
  0002d	e9 44 02 00 00	 jmp	 $LN27@gzseek
$LN26@gzseek:

; 777  :     }
; 778  : 
; 779  :     if (s->mode == 'w') {

  00032	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00035	0f be 48 5c	 movsx	 ecx, BYTE PTR [eax+92]
  00039	83 f9 77	 cmp	 ecx, 119		; 00000077H
  0003c	0f 85 bb 00 00
	00		 jne	 $LN24@gzseek

; 780  : #ifdef NO_GZCOMPRESS
; 781  :         return -1L;
; 782  : #else
; 783  :         if (whence == SEEK_SET) {

  00042	83 7d 10 00	 cmp	 DWORD PTR _whence$[ebp], 0
  00046	75 0c		 jne	 SHORT $LN23@gzseek

; 784  :             offset -= s->in;

  00048	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0004b	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0004e	2b 42 64	 sub	 eax, DWORD PTR [edx+100]
  00051	89 45 0c	 mov	 DWORD PTR _offset$[ebp], eax
$LN23@gzseek:

; 785  :         }
; 786  :         if (offset < 0) return -1L;

  00054	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  00058	7d 08		 jge	 SHORT $LN22@gzseek
  0005a	83 c8 ff	 or	 eax, -1
  0005d	e9 14 02 00 00	 jmp	 $LN27@gzseek
$LN22@gzseek:

; 787  : 
; 788  :         /* At this point, offset is the number of zero bytes to write. */
; 789  :         if (s->inbuf == Z_NULL) {

  00062	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00065	83 79 44 00	 cmp	 DWORD PTR [ecx+68], 0
  00069	75 3b		 jne	 SHORT $LN19@gzseek

; 790  :             s->inbuf = (Byte*)ALLOC(Z_BUFSIZE); /* for seeking */

  0006b	68 00 40 00 00	 push	 16384			; 00004000H
  00070	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  00076	83 c4 04	 add	 esp, 4
  00079	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0007c	89 42 44	 mov	 DWORD PTR [edx+68], eax

; 791  :             if (s->inbuf == Z_NULL) return -1L;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00082	83 78 44 00	 cmp	 DWORD PTR [eax+68], 0
  00086	75 08		 jne	 SHORT $LN20@gzseek
  00088	83 c8 ff	 or	 eax, -1
  0008b	e9 e6 01 00 00	 jmp	 $LN27@gzseek
$LN20@gzseek:

; 792  :             zmemzero(s->inbuf, Z_BUFSIZE);

  00090	68 00 40 00 00	 push	 16384			; 00004000H
  00095	6a 00		 push	 0
  00097	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0009a	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  0009d	52		 push	 edx
  0009e	e8 00 00 00 00	 call	 _memset
  000a3	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN19@gzseek:

; 793  :         }
; 794  :         while (offset > 0)  {

  000a6	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  000aa	7e 46		 jle	 SHORT $LN18@gzseek

; 795  :             uInt size = Z_BUFSIZE;

  000ac	c7 45 f8 00 40
	00 00		 mov	 DWORD PTR _size$79365[ebp], 16384 ; 00004000H

; 796  :             if (offset < Z_BUFSIZE) size = (uInt)offset;

  000b3	81 7d 0c 00 40
	00 00		 cmp	 DWORD PTR _offset$[ebp], 16384 ; 00004000H
  000ba	7d 06		 jge	 SHORT $LN17@gzseek
  000bc	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  000bf	89 45 f8	 mov	 DWORD PTR _size$79365[ebp], eax
$LN17@gzseek:

; 797  : 
; 798  :             size = gzwrite(file, s->inbuf, size);

  000c2	8b 4d f8	 mov	 ecx, DWORD PTR _size$79365[ebp]
  000c5	51		 push	 ecx
  000c6	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  000c9	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _gzwrite@12
  000d6	89 45 f8	 mov	 DWORD PTR _size$79365[ebp], eax

; 799  :             if (size == 0) return -1L;

  000d9	83 7d f8 00	 cmp	 DWORD PTR _size$79365[ebp], 0
  000dd	75 08		 jne	 SHORT $LN16@gzseek
  000df	83 c8 ff	 or	 eax, -1
  000e2	e9 8f 01 00 00	 jmp	 $LN27@gzseek
$LN16@gzseek:

; 800  : 
; 801  :             offset -= size;

  000e7	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  000ea	2b 55 f8	 sub	 edx, DWORD PTR _size$79365[ebp]
  000ed	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx

; 802  :         }

  000f0	eb b4		 jmp	 SHORT $LN19@gzseek
$LN18@gzseek:

; 803  :         return s->in;

  000f2	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  000f5	8b 40 64	 mov	 eax, DWORD PTR [eax+100]
  000f8	e9 79 01 00 00	 jmp	 $LN27@gzseek
$LN24@gzseek:

; 804  : #endif
; 805  :     }
; 806  :     /* Rest of function is for reading only */
; 807  : 
; 808  :     /* compute absolute position */
; 809  :     if (whence == SEEK_CUR) {

  000fd	83 7d 10 01	 cmp	 DWORD PTR _whence$[ebp], 1
  00101	75 0c		 jne	 SHORT $LN15@gzseek

; 810  :         offset += s->out;

  00103	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00106	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00109	03 51 68	 add	 edx, DWORD PTR [ecx+104]
  0010c	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx
$LN15@gzseek:

; 811  :     }
; 812  :     if (offset < 0) return -1L;

  0010f	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  00113	7d 08		 jge	 SHORT $LN14@gzseek
  00115	83 c8 ff	 or	 eax, -1
  00118	e9 59 01 00 00	 jmp	 $LN27@gzseek
$LN14@gzseek:

; 813  : 
; 814  :     if (s->transparent) {

  0011d	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00120	83 78 58 00	 cmp	 DWORD PTR [eax+88], 0
  00124	74 5b		 je	 SHORT $LN13@gzseek

; 815  :         /* map to fseek */
; 816  :         s->back = EOF;

  00126	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00129	c7 41 6c ff ff
	ff ff		 mov	 DWORD PTR [ecx+108], -1

; 817  :         s->stream.avail_in = 0;

  00130	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00133	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 818  :         s->stream.next_in = s->inbuf;

  0013a	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0013d	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00140	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  00143	89 10		 mov	 DWORD PTR [eax], edx

; 819  :         if (fseek(s->file, offset, SEEK_SET) < 0) return -1L;

  00145	6a 00		 push	 0
  00147	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0014a	50		 push	 eax
  0014b	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0014e	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00151	52		 push	 edx
  00152	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fseek
  00158	83 c4 0c	 add	 esp, 12			; 0000000cH
  0015b	85 c0		 test	 eax, eax
  0015d	7d 08		 jge	 SHORT $LN12@gzseek
  0015f	83 c8 ff	 or	 eax, -1
  00162	e9 0f 01 00 00	 jmp	 $LN27@gzseek
$LN12@gzseek:

; 820  : 
; 821  :         s->in = s->out = offset;

  00167	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0016a	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  0016d	89 48 68	 mov	 DWORD PTR [eax+104], ecx
  00170	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00173	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  00176	89 42 64	 mov	 DWORD PTR [edx+100], eax

; 822  :         return offset;

  00179	8b 45 0c	 mov	 eax, DWORD PTR _offset$[ebp]
  0017c	e9 f5 00 00 00	 jmp	 $LN27@gzseek
$LN13@gzseek:

; 823  :     }
; 824  : 
; 825  :     /* For a negative seek, rewind and use positive seek */
; 826  :     if (offset >= s->out) {

  00181	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00184	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00187	3b 51 68	 cmp	 edx, DWORD PTR [ecx+104]
  0018a	7c 0e		 jl	 SHORT $LN11@gzseek

; 827  :         offset -= s->out;

  0018c	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0018f	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00192	2b 48 68	 sub	 ecx, DWORD PTR [eax+104]
  00195	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx
  00198	eb 15		 jmp	 SHORT $LN10@gzseek
$LN11@gzseek:

; 828  :     } else if (gzrewind(file) < 0) {

  0019a	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  0019d	52		 push	 edx
  0019e	e8 00 00 00 00	 call	 _gzrewind@4
  001a3	85 c0		 test	 eax, eax
  001a5	7d 08		 jge	 SHORT $LN10@gzseek

; 829  :         return -1L;

  001a7	83 c8 ff	 or	 eax, -1
  001aa	e9 c7 00 00 00	 jmp	 $LN27@gzseek
$LN10@gzseek:

; 830  :     }
; 831  :     /* offset is now the number of bytes to skip. */
; 832  : 
; 833  :     if (offset != 0 && s->outbuf == Z_NULL) {

  001af	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001b3	74 2e		 je	 SHORT $LN8@gzseek
  001b5	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  001b8	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  001bc	75 25		 jne	 SHORT $LN8@gzseek

; 834  :         s->outbuf = (Byte*)ALLOC(Z_BUFSIZE);

  001be	68 00 40 00 00	 push	 16384			; 00004000H
  001c3	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__malloc
  001c9	83 c4 04	 add	 esp, 4
  001cc	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  001cf	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 835  :         if (s->outbuf == Z_NULL) return -1L;

  001d2	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  001d5	83 7a 48 00	 cmp	 DWORD PTR [edx+72], 0
  001d9	75 08		 jne	 SHORT $LN8@gzseek
  001db	83 c8 ff	 or	 eax, -1
  001de	e9 93 00 00 00	 jmp	 $LN27@gzseek
$LN8@gzseek:

; 836  :     }
; 837  :     if (offset && s->back != EOF) {

  001e3	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  001e7	74 3e		 je	 SHORT $LN4@gzseek
  001e9	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  001ec	83 78 6c ff	 cmp	 DWORD PTR [eax+108], -1
  001f0	74 35		 je	 SHORT $LN4@gzseek

; 838  :         s->back = EOF;

  001f2	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  001f5	c7 41 6c ff ff
	ff ff		 mov	 DWORD PTR [ecx+108], -1

; 839  :         s->out++;

  001fc	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  001ff	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00202	83 c0 01	 add	 eax, 1
  00205	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00208	89 41 68	 mov	 DWORD PTR [ecx+104], eax

; 840  :         offset--;

  0020b	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  0020e	83 ea 01	 sub	 edx, 1
  00211	89 55 0c	 mov	 DWORD PTR _offset$[ebp], edx

; 841  :         if (s->last) s->z_err = Z_STREAM_END;

  00214	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  00217	83 78 70 00	 cmp	 DWORD PTR [eax+112], 0
  0021b	74 0a		 je	 SHORT $LN4@gzseek
  0021d	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  00220	c7 41 38 01 00
	00 00		 mov	 DWORD PTR [ecx+56], 1
$LN4@gzseek:

; 842  :     }
; 843  :     while (offset > 0)  {

  00227	83 7d 0c 00	 cmp	 DWORD PTR _offset$[ebp], 0
  0022b	7e 43		 jle	 SHORT $LN3@gzseek

; 844  :         int size = Z_BUFSIZE;

  0022d	c7 45 f4 00 40
	00 00		 mov	 DWORD PTR _size$79384[ebp], 16384 ; 00004000H

; 845  :         if (offset < Z_BUFSIZE) size = (int)offset;

  00234	81 7d 0c 00 40
	00 00		 cmp	 DWORD PTR _offset$[ebp], 16384 ; 00004000H
  0023b	7d 06		 jge	 SHORT $LN2@gzseek
  0023d	8b 55 0c	 mov	 edx, DWORD PTR _offset$[ebp]
  00240	89 55 f4	 mov	 DWORD PTR _size$79384[ebp], edx
$LN2@gzseek:

; 846  : 
; 847  :         size = gzread(file, s->outbuf, (uInt)size);

  00243	8b 45 f4	 mov	 eax, DWORD PTR _size$79384[ebp]
  00246	50		 push	 eax
  00247	8b 4d fc	 mov	 ecx, DWORD PTR _s$[ebp]
  0024a	8b 51 48	 mov	 edx, DWORD PTR [ecx+72]
  0024d	52		 push	 edx
  0024e	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00251	50		 push	 eax
  00252	e8 00 00 00 00	 call	 _gzread@12
  00257	89 45 f4	 mov	 DWORD PTR _size$79384[ebp], eax

; 848  :         if (size <= 0) return -1L;

  0025a	83 7d f4 00	 cmp	 DWORD PTR _size$79384[ebp], 0
  0025e	7f 05		 jg	 SHORT $LN1@gzseek
  00260	83 c8 ff	 or	 eax, -1
  00263	eb 11		 jmp	 SHORT $LN27@gzseek
$LN1@gzseek:

; 849  :         offset -= size;

  00265	8b 4d 0c	 mov	 ecx, DWORD PTR _offset$[ebp]
  00268	2b 4d f4	 sub	 ecx, DWORD PTR _size$79384[ebp]
  0026b	89 4d 0c	 mov	 DWORD PTR _offset$[ebp], ecx

; 850  :     }

  0026e	eb b7		 jmp	 SHORT $LN4@gzseek
$LN3@gzseek:

; 851  :     return s->out;

  00270	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  00273	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
$LN27@gzseek:

; 852  : }

  00276	8b e5		 mov	 esp, ebp
  00278	5d		 pop	 ebp
  00279	c2 0c 00	 ret	 12			; 0000000cH
_gzseek@12 ENDP
_TEXT	ENDS
PUBLIC	_gzflush@8
; Function compile flags: /Odtp
;	COMDAT _gzflush@8
_TEXT	SEGMENT
tv73 = -12						; size = 4
_err$ = -8						; size = 4
_s$ = -4						; size = 4
_file$ = 8						; size = 4
_flush$ = 12						; size = 4
_gzflush@8 PROC						; COMDAT

; 749  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 750  :     gz_stream *s = (gz_stream*)file;

  00006	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _s$[ebp], eax

; 751  :     int err = do_flush (file, flush);

  0000c	8b 4d 0c	 mov	 ecx, DWORD PTR _flush$[ebp]
  0000f	51		 push	 ecx
  00010	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00013	52		 push	 edx
  00014	e8 00 00 00 00	 call	 _do_flush
  00019	83 c4 08	 add	 esp, 8
  0001c	89 45 f8	 mov	 DWORD PTR _err$[ebp], eax

; 752  : 
; 753  :     if (err) return err;

  0001f	83 7d f8 00	 cmp	 DWORD PTR _err$[ebp], 0
  00023	74 05		 je	 SHORT $LN1@gzflush
  00025	8b 45 f8	 mov	 eax, DWORD PTR _err$[ebp]
  00028	eb 2e		 jmp	 SHORT $LN2@gzflush
$LN1@gzflush:

; 754  :     fflush(s->file);

  0002a	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0002d	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00030	51		 push	 ecx
  00031	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__fflush
  00037	83 c4 04	 add	 esp, 4

; 755  :     return  s->z_err == Z_STREAM_END ? Z_OK : s->z_err;

  0003a	8b 55 fc	 mov	 edx, DWORD PTR _s$[ebp]
  0003d	83 7a 38 01	 cmp	 DWORD PTR [edx+56], 1
  00041	75 09		 jne	 SHORT $LN4@gzflush
  00043	c7 45 f4 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
  0004a	eb 09		 jmp	 SHORT $LN5@gzflush
$LN4@gzflush:
  0004c	8b 45 fc	 mov	 eax, DWORD PTR _s$[ebp]
  0004f	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  00052	89 4d f4	 mov	 DWORD PTR tv73[ebp], ecx
$LN5@gzflush:
  00055	8b 45 f4	 mov	 eax, DWORD PTR tv73[ebp]
$LN2@gzflush:

; 756  : }

  00058	8b e5		 mov	 esp, ebp
  0005a	5d		 pop	 ebp
  0005b	c2 08 00	 ret	 8
_gzflush@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputs@8
; Function compile flags: /Odtp
;	COMDAT _gzputs@8
_TEXT	SEGMENT
_file$ = 8						; size = 4
_s$ = 12						; size = 4
_gzputs@8 PROC						; COMDAT

; 696  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 697  :     return gzwrite(file, (char*)s, (unsigned)strlen(s));

  00003	8b 45 0c	 mov	 eax, DWORD PTR _s$[ebp]
  00006	50		 push	 eax
  00007	e8 00 00 00 00	 call	 _strlen
  0000c	83 c4 04	 add	 esp, 4
  0000f	50		 push	 eax
  00010	8b 4d 0c	 mov	 ecx, DWORD PTR _s$[ebp]
  00013	51		 push	 ecx
  00014	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00017	52		 push	 edx
  00018	e8 00 00 00 00	 call	 _gzwrite@12

; 698  : }

  0001d	5d		 pop	 ebp
  0001e	c2 08 00	 ret	 8
_gzputs@8 ENDP
_TEXT	ENDS
PUBLIC	_gzputc@8
; Function compile flags: /Odtp
;	COMDAT _gzputc@8
_TEXT	SEGMENT
tv70 = -8						; size = 4
_cc$ = -1						; size = 1
_file$ = 8						; size = 4
_c$ = 12						; size = 4
_gzputc@8 PROC						; COMDAT

; 681  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 682  :     unsigned char cc = (unsigned char) c; /* required for big endian systems */

  00006	8a 45 0c	 mov	 al, BYTE PTR _c$[ebp]
  00009	88 45 ff	 mov	 BYTE PTR _cc$[ebp], al

; 683  : 
; 684  :     return gzwrite(file, &cc, 1) == 1 ? (int)cc : -1;

  0000c	6a 01		 push	 1
  0000e	8d 4d ff	 lea	 ecx, DWORD PTR _cc$[ebp]
  00011	51		 push	 ecx
  00012	8b 55 08	 mov	 edx, DWORD PTR _file$[ebp]
  00015	52		 push	 edx
  00016	e8 00 00 00 00	 call	 _gzwrite@12
  0001b	83 f8 01	 cmp	 eax, 1
  0001e	75 09		 jne	 SHORT $LN3@gzputc
  00020	0f b6 45 ff	 movzx	 eax, BYTE PTR _cc$[ebp]
  00024	89 45 f8	 mov	 DWORD PTR tv70[ebp], eax
  00027	eb 07		 jmp	 SHORT $LN4@gzputc
$LN3@gzputc:
  00029	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gzputc:
  00030	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 685  : }

  00033	8b e5		 mov	 esp, ebp
  00035	5d		 pop	 ebp
  00036	c2 08 00	 ret	 8
_gzputc@8 ENDP
_TEXT	ENDS
PUBLIC	_gzprintf
; Function compile flags: /Odtp
;	COMDAT _gzprintf
_TEXT	SEGMENT
_buf$ = -4104						; size = 4096
_len$ = -8						; size = 4
_va$ = -4						; size = 4
_file$ = 8						; size = 4
_format$ = 12						; size = 4
_gzprintf PROC						; COMDAT

; 604  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	b8 08 10 00 00	 mov	 eax, 4104		; 00001008H
  00008	e8 00 00 00 00	 call	 __chkstk

; 605  :     char buf[Z_PRINTF_BUFSIZE];
; 606  :     va_list va;
; 607  :     int len;
; 608  : 
; 609  :     buf[sizeof(buf) - 1] = 0;

  0000d	c6 45 f7 00	 mov	 BYTE PTR _buf$[ebp+4095], 0

; 610  :     va_start(va, format);

  00011	8d 45 10	 lea	 eax, DWORD PTR _format$[ebp+4]
  00014	89 45 fc	 mov	 DWORD PTR _va$[ebp], eax

; 611  : #ifdef NO_vsnprintf
; 612  : #  ifdef HAS_vsprintf_void
; 613  :     (void)vsprintf(buf, format, va);
; 614  :     va_end(va);
; 615  :     for (len = 0; len < sizeof(buf); len++)
; 616  :         if (buf[len] == 0) break;
; 617  : #  else
; 618  :     len = vsprintf(buf, format, va);
; 619  :     va_end(va);
; 620  : #  endif
; 621  : #else
; 622  : #  ifdef HAS_vsnprintf_void
; 623  :     (void)vsnprintf(buf, sizeof(buf), format, va);
; 624  :     va_end(va);
; 625  :     len = strlen(buf);
; 626  : #  else
; 627  :     len = vsnprintf(buf, sizeof(buf), format, va);

  00017	8b 4d fc	 mov	 ecx, DWORD PTR _va$[ebp]
  0001a	51		 push	 ecx
  0001b	8b 55 0c	 mov	 edx, DWORD PTR _format$[ebp]
  0001e	52		 push	 edx
  0001f	68 00 10 00 00	 push	 4096			; 00001000H
  00024	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  0002a	50		 push	 eax
  0002b	ff 15 00 00 00
	00		 call	 DWORD PTR __imp___vsnprintf
  00031	83 c4 10	 add	 esp, 16			; 00000010H
  00034	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 628  :     va_end(va);

  00037	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _va$[ebp], 0

; 629  : #  endif
; 630  : #endif
; 631  :     if (len <= 0 || len >= (int)sizeof(buf) || buf[sizeof(buf) - 1] != 0)

  0003e	83 7d f8 00	 cmp	 DWORD PTR _len$[ebp], 0
  00042	7e 11		 jle	 SHORT $LN1@gzprintf
  00044	81 7d f8 00 10
	00 00		 cmp	 DWORD PTR _len$[ebp], 4096 ; 00001000H
  0004b	7d 08		 jge	 SHORT $LN1@gzprintf
  0004d	0f be 4d f7	 movsx	 ecx, BYTE PTR _buf$[ebp+4095]
  00051	85 c9		 test	 ecx, ecx
  00053	74 04		 je	 SHORT $LN2@gzprintf
$LN1@gzprintf:

; 632  :         return 0;

  00055	33 c0		 xor	 eax, eax
  00057	eb 14		 jmp	 SHORT $LN3@gzprintf
$LN2@gzprintf:

; 633  :     return gzwrite(file, buf, (unsigned)len);

  00059	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0005c	52		 push	 edx
  0005d	8d 85 f8 ef ff
	ff		 lea	 eax, DWORD PTR _buf$[ebp]
  00063	50		 push	 eax
  00064	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  00067	51		 push	 ecx
  00068	e8 00 00 00 00	 call	 _gzwrite@12
$LN3@gzprintf:

; 634  : }

  0006d	8b e5		 mov	 esp, ebp
  0006f	5d		 pop	 ebp
  00070	c3		 ret	 0
_gzprintf ENDP
_TEXT	ENDS
PUBLIC	_gzgets@12
; Function compile flags: /Odtp
;	COMDAT _gzgets@12
_TEXT	SEGMENT
tv78 = -8						; size = 4
_b$ = -4						; size = 4
_file$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_gzgets@12 PROC						; COMDAT

; 544  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 545  :     char *b = buf;

  00006	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00009	89 45 fc	 mov	 DWORD PTR _b$[ebp], eax

; 546  :     if (buf == Z_NULL || len <= 0) return Z_NULL;

  0000c	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00010	74 06		 je	 SHORT $LN3@gzgets
  00012	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00016	7f 04		 jg	 SHORT $LN2@gzgets
$LN3@gzgets:
  00018	33 c0		 xor	 eax, eax
  0001a	eb 5f		 jmp	 SHORT $LN5@gzgets
$LN2@gzgets:

; 547  : 
; 548  :     while (--len > 0 && gzread(file, buf, 1) == 1 && *buf++ != '\n') ;

  0001c	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0001f	83 e9 01	 sub	 ecx, 1
  00022	89 4d 10	 mov	 DWORD PTR _len$[ebp], ecx
  00025	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00029	7e 2a		 jle	 SHORT $LN1@gzgets
  0002b	6a 01		 push	 1
  0002d	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00030	52		 push	 edx
  00031	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  00034	50		 push	 eax
  00035	e8 00 00 00 00	 call	 _gzread@12
  0003a	83 f8 01	 cmp	 eax, 1
  0003d	75 16		 jne	 SHORT $LN1@gzgets
  0003f	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00042	0f be 11	 movsx	 edx, BYTE PTR [ecx]
  00045	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00048	83 c0 01	 add	 eax, 1
  0004b	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax
  0004e	83 fa 0a	 cmp	 edx, 10			; 0000000aH
  00051	74 02		 je	 SHORT $LN1@gzgets
  00053	eb c7		 jmp	 SHORT $LN2@gzgets
$LN1@gzgets:

; 549  :     *buf = '\0';

  00055	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00058	c6 01 00	 mov	 BYTE PTR [ecx], 0

; 550  :     return b == buf && len > 0 ? Z_NULL : b;

  0005b	8b 55 fc	 mov	 edx, DWORD PTR _b$[ebp]
  0005e	3b 55 0c	 cmp	 edx, DWORD PTR _buf$[ebp]
  00061	75 0f		 jne	 SHORT $LN7@gzgets
  00063	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  00067	7e 09		 jle	 SHORT $LN7@gzgets
  00069	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv78[ebp], 0
  00070	eb 06		 jmp	 SHORT $LN8@gzgets
$LN7@gzgets:
  00072	8b 45 fc	 mov	 eax, DWORD PTR _b$[ebp]
  00075	89 45 f8	 mov	 DWORD PTR tv78[ebp], eax
$LN8@gzgets:
  00078	8b 45 f8	 mov	 eax, DWORD PTR tv78[ebp]
$LN5@gzgets:

; 551  : }

  0007b	8b e5		 mov	 esp, ebp
  0007d	5d		 pop	 ebp
  0007e	c2 0c 00	 ret	 12			; 0000000cH
_gzgets@12 ENDP
_TEXT	ENDS
PUBLIC	_gzgetc@4
; Function compile flags: /Odtp
;	COMDAT _gzgetc@4
_TEXT	SEGMENT
tv70 = -8						; size = 4
_c$ = -1						; size = 1
_file$ = 8						; size = 4
_gzgetc@4 PROC						; COMDAT

; 505  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 506  :     unsigned char c;
; 507  : 
; 508  :     return gzread(file, &c, 1) == 1 ? c : -1;

  00006	6a 01		 push	 1
  00008	8d 45 ff	 lea	 eax, DWORD PTR _c$[ebp]
  0000b	50		 push	 eax
  0000c	8b 4d 08	 mov	 ecx, DWORD PTR _file$[ebp]
  0000f	51		 push	 ecx
  00010	e8 00 00 00 00	 call	 _gzread@12
  00015	83 f8 01	 cmp	 eax, 1
  00018	75 09		 jne	 SHORT $LN3@gzgetc
  0001a	0f b6 55 ff	 movzx	 edx, BYTE PTR _c$[ebp]
  0001e	89 55 f8	 mov	 DWORD PTR tv70[ebp], edx
  00021	eb 07		 jmp	 SHORT $LN4@gzgetc
$LN3@gzgetc:
  00023	c7 45 f8 ff ff
	ff ff		 mov	 DWORD PTR tv70[ebp], -1
$LN4@gzgetc:
  0002a	8b 45 f8	 mov	 eax, DWORD PTR tv70[ebp]

; 509  : }

  0002d	8b e5		 mov	 esp, ebp
  0002f	5d		 pop	 ebp
  00030	c2 04 00	 ret	 4
_gzgetc@4 ENDP
_TEXT	ENDS
PUBLIC	_gzdopen@8
; Function compile flags: /Odtp
;	COMDAT _gzdopen@8
_TEXT	SEGMENT
_name$ = -48						; size = 46
_fd$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzdopen@8 PROC						; COMDAT

; 222  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 30	 sub	 esp, 48			; 00000030H

; 223  :     char name[46];      /* allow for up to 128-bit integers */
; 224  : 
; 225  :     if (fd < 0) return (gzFile)Z_NULL;

  00006	83 7d 08 00	 cmp	 DWORD PTR _fd$[ebp], 0
  0000a	7d 04		 jge	 SHORT $LN1@gzdopen
  0000c	33 c0		 xor	 eax, eax
  0000e	eb 2a		 jmp	 SHORT $LN2@gzdopen
$LN1@gzdopen:

; 226  :     sprintf(name, "<fd:%d>", fd); /* for debugging */

  00010	8b 45 08	 mov	 eax, DWORD PTR _fd$[ebp]
  00013	50		 push	 eax
  00014	68 00 00 00 00	 push	 OFFSET ??_C@_07EBNKNFJN@?$DMfd?3?$CFd?$DO?$AA@
  00019	8d 4d d0	 lea	 ecx, DWORD PTR _name$[ebp]
  0001c	51		 push	 ecx
  0001d	ff 15 00 00 00
	00		 call	 DWORD PTR __imp__sprintf
  00023	83 c4 0c	 add	 esp, 12			; 0000000cH

; 227  : 
; 228  :     return gz_open (name, mode, fd);

  00026	8b 55 08	 mov	 edx, DWORD PTR _fd$[ebp]
  00029	52		 push	 edx
  0002a	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  0002d	50		 push	 eax
  0002e	8d 4d d0	 lea	 ecx, DWORD PTR _name$[ebp]
  00031	51		 push	 ecx
  00032	e8 00 00 00 00	 call	 _gz_open
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN2@gzdopen:

; 229  : }

  0003a	8b e5		 mov	 esp, ebp
  0003c	5d		 pop	 ebp
  0003d	c2 08 00	 ret	 8
_gzdopen@8 ENDP
_TEXT	ENDS
PUBLIC	_gzopen@8
; Function compile flags: /Odtp
;	COMDAT _gzopen@8
_TEXT	SEGMENT
_path$ = 8						; size = 4
_mode$ = 12						; size = 4
_gzopen@8 PROC						; COMDAT

; 211  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 212  :     return gz_open (path, mode, -1);

  00003	6a ff		 push	 -1
  00005	8b 45 0c	 mov	 eax, DWORD PTR _mode$[ebp]
  00008	50		 push	 eax
  00009	8b 4d 08	 mov	 ecx, DWORD PTR _path$[ebp]
  0000c	51		 push	 ecx
  0000d	e8 00 00 00 00	 call	 _gz_open
  00012	83 c4 0c	 add	 esp, 12			; 0000000cH

; 213  : }

  00015	5d		 pop	 ebp
  00016	c2 08 00	 ret	 8
_gzopen@8 ENDP
PUBLIC	_gztell@4
; Function compile flags: /Odtp
;	COMDAT _gztell@4
_TEXT	SEGMENT
_file$ = 8						; size = 4
_gztell@4 PROC						; COMDAT

; 883  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 884  :     return gzseek(file, 0L, SEEK_CUR);

  00003	6a 01		 push	 1
  00005	6a 00		 push	 0
  00007	8b 45 08	 mov	 eax, DWORD PTR _file$[ebp]
  0000a	50		 push	 eax
  0000b	e8 00 00 00 00	 call	 _gzseek@12

; 885  : }

  00010	5d		 pop	 ebp
  00011	c2 04 00	 ret	 4
_gztell@4 ENDP
END
