; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\inftrees.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_inflate_copyright
_inflate_copyright DB ' inflate 1.2.3 Copyright 1995-2005 Mark Adler ', 00H
	ORG $+1
?lbase@?1??inflate_table@@9@9 DW 03H			; `inflate_table'::`2'::lbase
	DW	04H
	DW	05H
	DW	06H
	DW	07H
	DW	08H
	DW	09H
	DW	0aH
	DW	0bH
	DW	0dH
	DW	0fH
	DW	011H
	DW	013H
	DW	017H
	DW	01bH
	DW	01fH
	DW	023H
	DW	02bH
	DW	033H
	DW	03bH
	DW	043H
	DW	053H
	DW	063H
	DW	073H
	DW	083H
	DW	0a3H
	DW	0c3H
	DW	0e3H
	DW	0102H
	DW	00H
	DW	00H
	ORG $+2
?lext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::lext
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	015H
	DW	015H
	DW	010H
	DW	0c9H
	DW	0c4H
	ORG $+2
?dbase@?1??inflate_table@@9@9 DW 01H			; `inflate_table'::`2'::dbase
	DW	02H
	DW	03H
	DW	04H
	DW	05H
	DW	07H
	DW	09H
	DW	0dH
	DW	011H
	DW	019H
	DW	021H
	DW	031H
	DW	041H
	DW	061H
	DW	081H
	DW	0c1H
	DW	0101H
	DW	0181H
	DW	0201H
	DW	0301H
	DW	0401H
	DW	0601H
	DW	0801H
	DW	0c01H
	DW	01001H
	DW	01801H
	DW	02001H
	DW	03001H
	DW	04001H
	DW	06001H
	DW	00H
	DW	00H
?dext@?1??inflate_table@@9@9 DW 010H			; `inflate_table'::`2'::dext
	DW	010H
	DW	010H
	DW	010H
	DW	011H
	DW	011H
	DW	012H
	DW	012H
	DW	013H
	DW	013H
	DW	014H
	DW	014H
	DW	015H
	DW	015H
	DW	016H
	DW	016H
	DW	017H
	DW	017H
	DW	018H
	DW	018H
	DW	019H
	DW	019H
	DW	01aH
	DW	01aH
	DW	01bH
	DW	01bH
	DW	01cH
	DW	01cH
	DW	01dH
	DW	01dH
	DW	040H
	DW	040H
PUBLIC	_inflate_table
; Function compile flags: /Odtp
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\inftrees.c
;	COMDAT _inflate_table
_TEXT	SEGMENT
tv187 = -144						; size = 4
_max$ = -140						; size = 4
_used$ = -136						; size = 4
_low$ = -132						; size = 4
_this$ = -128						; size = 4
_sym$ = -124						; size = 4
_fill$ = -120						; size = 4
_offs$ = -116						; size = 32
_incr$ = -84						; size = 4
_end$ = -80						; size = 4
_len$ = -76						; size = 4
_left$ = -72						; size = 4
_next$ = -68						; size = 4
_root$ = -64						; size = 4
_curr$ = -60						; size = 4
_drop$ = -56						; size = 4
_mask$ = -52						; size = 4
_min$ = -48						; size = 4
_huff$ = -44						; size = 4
_base$ = -40						; size = 4
_extra$ = -36						; size = 4
_count$ = -32						; size = 32
_type$ = 8						; size = 4
_lens$ = 12						; size = 4
_codes$ = 16						; size = 4
_table$ = 20						; size = 4
_bits$ = 24						; size = 4
_work$ = 28						; size = 4
_inflate_table PROC					; COMDAT

; 39   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	81 ec 90 00 00
	00		 sub	 esp, 144		; 00000090H

; 40   :     unsigned len;               /* a code's length in bits */
; 41   :     unsigned sym;               /* index of code symbols */
; 42   :     unsigned min, max;          /* minimum and maximum code lengths */
; 43   :     unsigned root;              /* number of index bits for root table */
; 44   :     unsigned curr;              /* number of index bits for current table */
; 45   :     unsigned drop;              /* code bits to drop for sub-table */
; 46   :     int left;                   /* number of prefix codes available */
; 47   :     unsigned used;              /* code entries in table used */
; 48   :     unsigned huff;              /* Huffman code */
; 49   :     unsigned incr;              /* for incrementing code, index */
; 50   :     unsigned fill;              /* index for replicating entries */
; 51   :     unsigned low;               /* low bits for current root entry */
; 52   :     unsigned mask;              /* mask for low root bits */
; 53   :     code this;                  /* table entry for duplication */
; 54   :     code FAR *next;             /* next available space in table */
; 55   :     const unsigned short FAR *base;     /* base value table to use */
; 56   :     const unsigned short FAR *extra;    /* extra bits table to use */
; 57   :     int end;                    /* use base and extra for symbol > end */
; 58   :     unsigned short count[MAXBITS+1];    /* number of codes of each length */
; 59   :     unsigned short offs[MAXBITS+1];     /* offsets in table for each length */
; 60   :     static const unsigned short lbase[31] = { /* Length codes 257..285 base */
; 61   :         3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,
; 62   :         35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0};
; 63   :     static const unsigned short lext[31] = { /* Length codes 257..285 extra */
; 64   :         16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,
; 65   :         19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 201, 196};
; 66   :     static const unsigned short dbase[32] = { /* Distance codes 0..29 base */
; 67   :         1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,
; 68   :         257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,
; 69   :         8193, 12289, 16385, 24577, 0, 0};
; 70   :     static const unsigned short dext[32] = { /* Distance codes 0..29 extra */
; 71   :         16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,
; 72   :         23, 23, 24, 24, 25, 25, 26, 26, 27, 27,
; 73   :         28, 28, 29, 29, 64, 64};
; 74   : 
; 75   :     /*
; 76   :        Process a set of code lengths to create a canonical Huffman code.  The
; 77   :        code lengths are lens[0..codes-1].  Each length corresponds to the
; 78   :        symbols 0..codes-1.  The Huffman code is generated by first sorting the
; 79   :        symbols by length from short to long, and retaining the symbol order
; 80   :        for codes with equal lengths.  Then the code starts with all zero bits
; 81   :        for the first code of the shortest length, and the codes are integer
; 82   :        increments for the same length, and zeros are appended as the length
; 83   :        increases.  For the deflate format, these bits are stored backwards
; 84   :        from their more natural integer increment ordering, and so when the
; 85   :        decoding tables are built in the large loop below, the integer codes
; 86   :        are incremented backwards.
; 87   : 
; 88   :        This routine assumes, but does not check, that all of the entries in
; 89   :        lens[] are in the range 0..MAXBITS.  The caller must assure this.
; 90   :        1..MAXBITS is interpreted as that code length.  zero means that that
; 91   :        symbol does not occur in this code.
; 92   : 
; 93   :        The codes are sorted by computing a count of codes for each length,
; 94   :        creating from that a table of starting indices for each length in the
; 95   :        sorted table, and then entering the symbols in order in the sorted
; 96   :        table.  The sorted table is work[], with that space being provided by
; 97   :        the caller.
; 98   : 
; 99   :        The length counts are used for other purposes as well, i.e. finding
; 100  :        the minimum and maximum length codes, determining if there are any
; 101  :        codes at all, checking for a valid set of lengths, and looking ahead
; 102  :        at length counts to determine sub-table sizes when building the
; 103  :        decoding tables.
; 104  :      */
; 105  : 
; 106  :     /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
; 107  :     for (len = 0; len <= MAXBITS; len++)

  00009	c7 45 b4 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
  00010	eb 09		 jmp	 SHORT $LN64@inflate_ta
$LN63@inflate_ta:
  00012	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  00015	83 c0 01	 add	 eax, 1
  00018	89 45 b4	 mov	 DWORD PTR _len$[ebp], eax
$LN64@inflate_ta:
  0001b	83 7d b4 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  0001f	77 0c		 ja	 SHORT $LN62@inflate_ta

; 108  :         count[len] = 0;

  00021	33 c9		 xor	 ecx, ecx
  00023	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  00026	66 89 4c 55 e0	 mov	 WORD PTR _count$[ebp+edx*2], cx
  0002b	eb e5		 jmp	 SHORT $LN63@inflate_ta
$LN62@inflate_ta:

; 109  :     for (sym = 0; sym < codes; sym++)

  0002d	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  00034	eb 09		 jmp	 SHORT $LN61@inflate_ta
$LN60@inflate_ta:
  00036	8b 45 84	 mov	 eax, DWORD PTR _sym$[ebp]
  00039	83 c0 01	 add	 eax, 1
  0003c	89 45 84	 mov	 DWORD PTR _sym$[ebp], eax
$LN61@inflate_ta:
  0003f	8b 4d 84	 mov	 ecx, DWORD PTR _sym$[ebp]
  00042	3b 4d 10	 cmp	 ecx, DWORD PTR _codes$[ebp]
  00045	73 24		 jae	 SHORT $LN59@inflate_ta

; 110  :         count[lens[sym]]++;

  00047	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  0004a	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0004d	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  00051	66 8b 54 4d e0	 mov	 dx, WORD PTR _count$[ebp+ecx*2]
  00056	66 83 c2 01	 add	 dx, 1
  0005a	8b 45 84	 mov	 eax, DWORD PTR _sym$[ebp]
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  00060	0f b7 04 41	 movzx	 eax, WORD PTR [ecx+eax*2]
  00064	66 89 54 45 e0	 mov	 WORD PTR _count$[ebp+eax*2], dx
  00069	eb cb		 jmp	 SHORT $LN60@inflate_ta
$LN59@inflate_ta:

; 111  : 
; 112  :     /* bound code lengths, force root to be within code lengths */
; 113  :     root = *bits;

  0006b	8b 4d 18	 mov	 ecx, DWORD PTR _bits$[ebp]
  0006e	8b 11		 mov	 edx, DWORD PTR [ecx]
  00070	89 55 c0	 mov	 DWORD PTR _root$[ebp], edx

; 114  :     for (max = MAXBITS; max >= 1; max--)

  00073	c7 85 74 ff ff
	ff 0f 00 00 00	 mov	 DWORD PTR _max$[ebp], 15 ; 0000000fH
  0007d	eb 0f		 jmp	 SHORT $LN58@inflate_ta
$LN57@inflate_ta:
  0007f	8b 85 74 ff ff
	ff		 mov	 eax, DWORD PTR _max$[ebp]
  00085	83 e8 01	 sub	 eax, 1
  00088	89 85 74 ff ff
	ff		 mov	 DWORD PTR _max$[ebp], eax
$LN58@inflate_ta:
  0008e	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _max$[ebp], 1
  00095	72 13		 jb	 SHORT $LN56@inflate_ta

; 115  :         if (count[max] != 0) break;

  00097	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _max$[ebp]
  0009d	0f b7 54 4d e0	 movzx	 edx, WORD PTR _count$[ebp+ecx*2]
  000a2	85 d2		 test	 edx, edx
  000a4	74 02		 je	 SHORT $LN55@inflate_ta
  000a6	eb 02		 jmp	 SHORT $LN56@inflate_ta
$LN55@inflate_ta:

; 116  :     if (root > max) root = max;

  000a8	eb d5		 jmp	 SHORT $LN57@inflate_ta
$LN56@inflate_ta:
  000aa	8b 45 c0	 mov	 eax, DWORD PTR _root$[ebp]
  000ad	3b 85 74 ff ff
	ff		 cmp	 eax, DWORD PTR _max$[ebp]
  000b3	76 09		 jbe	 SHORT $LN54@inflate_ta
  000b5	8b 8d 74 ff ff
	ff		 mov	 ecx, DWORD PTR _max$[ebp]
  000bb	89 4d c0	 mov	 DWORD PTR _root$[ebp], ecx
$LN54@inflate_ta:

; 117  :     if (max == 0) {                     /* no symbols to code at all */

  000be	83 bd 74 ff ff
	ff 00		 cmp	 DWORD PTR _max$[ebp], 0
  000c5	75 4c		 jne	 SHORT $LN53@inflate_ta

; 118  :         this.op = (unsigned char)64;    /* invalid code marker */

  000c7	c6 45 80 40	 mov	 BYTE PTR _this$[ebp], 64 ; 00000040H

; 119  :         this.bits = (unsigned char)1;

  000cb	c6 45 81 01	 mov	 BYTE PTR _this$[ebp+1], 1

; 120  :         this.val = (unsigned short)0;

  000cf	33 d2		 xor	 edx, edx
  000d1	66 89 55 82	 mov	 WORD PTR _this$[ebp+2], dx

; 121  :         *(*table)++ = this;             /* make a table to force an error */

  000d5	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000d8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000da	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  000dd	89 11		 mov	 DWORD PTR [ecx], edx
  000df	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000e2	8b 08		 mov	 ecx, DWORD PTR [eax]
  000e4	83 c1 04	 add	 ecx, 4
  000e7	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  000ea	89 0a		 mov	 DWORD PTR [edx], ecx

; 122  :         *(*table)++ = this;

  000ec	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000ef	8b 08		 mov	 ecx, DWORD PTR [eax]
  000f1	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  000f4	89 11		 mov	 DWORD PTR [ecx], edx
  000f6	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  000f9	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fb	83 c1 04	 add	 ecx, 4
  000fe	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00101	89 0a		 mov	 DWORD PTR [edx], ecx

; 123  :         *bits = 1;

  00103	8b 45 18	 mov	 eax, DWORD PTR _bits$[ebp]
  00106	c7 00 01 00 00
	00		 mov	 DWORD PTR [eax], 1

; 124  :         return 0;     /* no symbols, but wait for decoding to report error */

  0010c	33 c0		 xor	 eax, eax
  0010e	e9 2c 05 00 00	 jmp	 $LN65@inflate_ta
$LN53@inflate_ta:

; 125  :     }
; 126  :     for (min = 1; min <= MAXBITS; min++)

  00113	c7 45 d0 01 00
	00 00		 mov	 DWORD PTR _min$[ebp], 1
  0011a	eb 09		 jmp	 SHORT $LN52@inflate_ta
$LN51@inflate_ta:
  0011c	8b 4d d0	 mov	 ecx, DWORD PTR _min$[ebp]
  0011f	83 c1 01	 add	 ecx, 1
  00122	89 4d d0	 mov	 DWORD PTR _min$[ebp], ecx
$LN52@inflate_ta:
  00125	83 7d d0 0f	 cmp	 DWORD PTR _min$[ebp], 15 ; 0000000fH
  00129	77 10		 ja	 SHORT $LN50@inflate_ta

; 127  :         if (count[min] != 0) break;

  0012b	8b 55 d0	 mov	 edx, DWORD PTR _min$[ebp]
  0012e	0f b7 44 55 e0	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  00133	85 c0		 test	 eax, eax
  00135	74 02		 je	 SHORT $LN49@inflate_ta
  00137	eb 02		 jmp	 SHORT $LN50@inflate_ta
$LN49@inflate_ta:

; 128  :     if (root < min) root = min;

  00139	eb e1		 jmp	 SHORT $LN51@inflate_ta
$LN50@inflate_ta:
  0013b	8b 4d c0	 mov	 ecx, DWORD PTR _root$[ebp]
  0013e	3b 4d d0	 cmp	 ecx, DWORD PTR _min$[ebp]
  00141	73 06		 jae	 SHORT $LN48@inflate_ta
  00143	8b 55 d0	 mov	 edx, DWORD PTR _min$[ebp]
  00146	89 55 c0	 mov	 DWORD PTR _root$[ebp], edx
$LN48@inflate_ta:

; 129  : 
; 130  :     /* check for an over-subscribed or incomplete set of lengths */
; 131  :     left = 1;

  00149	c7 45 b8 01 00
	00 00		 mov	 DWORD PTR _left$[ebp], 1

; 132  :     for (len = 1; len <= MAXBITS; len++) {

  00150	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  00157	eb 09		 jmp	 SHORT $LN47@inflate_ta
$LN46@inflate_ta:
  00159	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  0015c	83 c0 01	 add	 eax, 1
  0015f	89 45 b4	 mov	 DWORD PTR _len$[ebp], eax
$LN47@inflate_ta:
  00162	83 7d b4 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  00166	77 24		 ja	 SHORT $LN45@inflate_ta

; 133  :         left <<= 1;

  00168	8b 4d b8	 mov	 ecx, DWORD PTR _left$[ebp]
  0016b	d1 e1		 shl	 ecx, 1
  0016d	89 4d b8	 mov	 DWORD PTR _left$[ebp], ecx

; 134  :         left -= count[len];

  00170	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  00173	0f b7 44 55 e0	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  00178	8b 4d b8	 mov	 ecx, DWORD PTR _left$[ebp]
  0017b	2b c8		 sub	 ecx, eax
  0017d	89 4d b8	 mov	 DWORD PTR _left$[ebp], ecx

; 135  :         if (left < 0) return -1;        /* over-subscribed */

  00180	79 08		 jns	 SHORT $LN44@inflate_ta
  00182	83 c8 ff	 or	 eax, -1
  00185	e9 b5 04 00 00	 jmp	 $LN65@inflate_ta
$LN44@inflate_ta:

; 136  :     }

  0018a	eb cd		 jmp	 SHORT $LN46@inflate_ta
$LN45@inflate_ta:

; 137  :     if (left > 0 && (type == CODES || max != 1))

  0018c	83 7d b8 00	 cmp	 DWORD PTR _left$[ebp], 0
  00190	7e 17		 jle	 SHORT $LN43@inflate_ta
  00192	83 7d 08 00	 cmp	 DWORD PTR _type$[ebp], 0
  00196	74 09		 je	 SHORT $LN42@inflate_ta
  00198	83 bd 74 ff ff
	ff 01		 cmp	 DWORD PTR _max$[ebp], 1
  0019f	74 08		 je	 SHORT $LN43@inflate_ta
$LN42@inflate_ta:

; 138  :         return -1;                      /* incomplete set */

  001a1	83 c8 ff	 or	 eax, -1
  001a4	e9 96 04 00 00	 jmp	 $LN65@inflate_ta
$LN43@inflate_ta:

; 139  : 
; 140  :     /* generate offsets into symbol table for each length for sorting */
; 141  :     offs[1] = 0;

  001a9	33 d2		 xor	 edx, edx
  001ab	66 89 55 8e	 mov	 WORD PTR _offs$[ebp+2], dx

; 142  :     for (len = 1; len < MAXBITS; len++)

  001af	c7 45 b4 01 00
	00 00		 mov	 DWORD PTR _len$[ebp], 1
  001b6	eb 09		 jmp	 SHORT $LN41@inflate_ta
$LN40@inflate_ta:
  001b8	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  001bb	83 c0 01	 add	 eax, 1
  001be	89 45 b4	 mov	 DWORD PTR _len$[ebp], eax
$LN41@inflate_ta:
  001c1	83 7d b4 0f	 cmp	 DWORD PTR _len$[ebp], 15 ; 0000000fH
  001c5	73 1c		 jae	 SHORT $LN39@inflate_ta

; 143  :         offs[len + 1] = offs[len] + count[len];

  001c7	8b 4d b4	 mov	 ecx, DWORD PTR _len$[ebp]
  001ca	0f b7 54 4d 8c	 movzx	 edx, WORD PTR _offs$[ebp+ecx*2]
  001cf	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  001d2	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  001d7	03 d1		 add	 edx, ecx
  001d9	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  001dc	66 89 54 45 8e	 mov	 WORD PTR _offs$[ebp+eax*2+2], dx
  001e1	eb d5		 jmp	 SHORT $LN40@inflate_ta
$LN39@inflate_ta:

; 144  : 
; 145  :     /* sort symbols by length, by symbol order within each length */
; 146  :     for (sym = 0; sym < codes; sym++)

  001e3	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0
  001ea	eb 09		 jmp	 SHORT $LN38@inflate_ta
$LN37@inflate_ta:
  001ec	8b 4d 84	 mov	 ecx, DWORD PTR _sym$[ebp]
  001ef	83 c1 01	 add	 ecx, 1
  001f2	89 4d 84	 mov	 DWORD PTR _sym$[ebp], ecx
$LN38@inflate_ta:
  001f5	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  001f8	3b 55 10	 cmp	 edx, DWORD PTR _codes$[ebp]
  001fb	73 4c		 jae	 SHORT $LN36@inflate_ta

; 147  :         if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;

  001fd	8b 45 84	 mov	 eax, DWORD PTR _sym$[ebp]
  00200	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  00203	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00207	85 d2		 test	 edx, edx
  00209	74 3c		 je	 SHORT $LN35@inflate_ta
  0020b	8b 45 84	 mov	 eax, DWORD PTR _sym$[ebp]
  0020e	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  00211	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00215	0f b7 44 55 8c	 movzx	 eax, WORD PTR _offs$[ebp+edx*2]
  0021a	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  0021d	66 8b 55 84	 mov	 dx, WORD PTR _sym$[ebp]
  00221	66 89 14 41	 mov	 WORD PTR [ecx+eax*2], dx
  00225	8b 45 84	 mov	 eax, DWORD PTR _sym$[ebp]
  00228	8b 4d 0c	 mov	 ecx, DWORD PTR _lens$[ebp]
  0022b	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  0022f	66 8b 44 55 8c	 mov	 ax, WORD PTR _offs$[ebp+edx*2]
  00234	66 83 c0 01	 add	 ax, 1
  00238	8b 4d 84	 mov	 ecx, DWORD PTR _sym$[ebp]
  0023b	8b 55 0c	 mov	 edx, DWORD PTR _lens$[ebp]
  0023e	0f b7 0c 4a	 movzx	 ecx, WORD PTR [edx+ecx*2]
  00242	66 89 44 4d 8c	 mov	 WORD PTR _offs$[ebp+ecx*2], ax
$LN35@inflate_ta:

; 148  : 
; 149  :     /*
; 150  :        Create and fill in decoding tables.  In this loop, the table being
; 151  :        filled is at next and has curr index bits.  The code being used is huff
; 152  :        with length len.  That code is converted to an index by dropping drop
; 153  :        bits off of the bottom.  For codes where len is less than drop + curr,
; 154  :        those top drop + curr - len bits are incremented through all values to
; 155  :        fill the table with replicated entries.
; 156  : 
; 157  :        root is the number of index bits for the root table.  When len exceeds
; 158  :        root, sub-tables are created pointed to by the root entry with an index
; 159  :        of the low root bits of huff.  This is saved in low to check for when a
; 160  :        new sub-table should be started.  drop is zero when the root table is
; 161  :        being filled, and drop is root when sub-tables are being filled.
; 162  : 
; 163  :        When a new sub-table is needed, it is necessary to look ahead in the
; 164  :        code lengths to determine what size sub-table is needed.  The length
; 165  :        counts are used for this, and so count[] is decremented as codes are
; 166  :        entered in the tables.
; 167  : 
; 168  :        used keeps track of how many table entries have been allocated from the
; 169  :        provided *table space.  It is checked when a LENS table is being made
; 170  :        against the space in *table, ENOUGH, minus the maximum space needed by
; 171  :        the worst case distance code, MAXD.  This should never happen, but the
; 172  :        sufficiency of ENOUGH has not been proven exhaustively, hence the check.
; 173  :        This assumes that when type == LENS, bits == 9.
; 174  : 
; 175  :        sym increments through all symbols, and the loop terminates when
; 176  :        all codes of length max, i.e. all codes, have been processed.  This
; 177  :        routine permits incomplete codes, so another loop after this one fills
; 178  :        in the rest of the decoding tables with invalid code markers.
; 179  :      */
; 180  : 
; 181  :     /* set up for code type */
; 182  :     switch (type) {

  00247	eb a3		 jmp	 SHORT $LN37@inflate_ta
$LN36@inflate_ta:
  00249	8b 55 08	 mov	 edx, DWORD PTR _type$[ebp]
  0024c	89 95 70 ff ff
	ff		 mov	 DWORD PTR tv187[ebp], edx
  00252	83 bd 70 ff ff
	ff 00		 cmp	 DWORD PTR tv187[ebp], 0
  00259	74 0b		 je	 SHORT $LN32@inflate_ta
  0025b	83 bd 70 ff ff
	ff 01		 cmp	 DWORD PTR tv187[ebp], 1
  00262	74 17		 je	 SHORT $LN31@inflate_ta
  00264	eb 43		 jmp	 SHORT $LN30@inflate_ta
$LN32@inflate_ta:

; 183  :     case CODES:
; 184  :         base = extra = work;    /* dummy value--not used */

  00266	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00269	89 45 dc	 mov	 DWORD PTR _extra$[ebp], eax
  0026c	8b 4d dc	 mov	 ecx, DWORD PTR _extra$[ebp]
  0026f	89 4d d8	 mov	 DWORD PTR _base$[ebp], ecx

; 185  :         end = 19;

  00272	c7 45 b0 13 00
	00 00		 mov	 DWORD PTR _end$[ebp], 19 ; 00000013H

; 186  :         break;

  00279	eb 43		 jmp	 SHORT $LN33@inflate_ta
$LN31@inflate_ta:

; 187  :     case LENS:
; 188  :         base = lbase;

  0027b	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?lbase@?1??inflate_table@@9@9

; 189  :         base -= 257;

  00282	8b 55 d8	 mov	 edx, DWORD PTR _base$[ebp]
  00285	81 ea 02 02 00
	00		 sub	 edx, 514		; 00000202H
  0028b	89 55 d8	 mov	 DWORD PTR _base$[ebp], edx

; 190  :         extra = lext;

  0028e	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?lext@?1??inflate_table@@9@9

; 191  :         extra -= 257;

  00295	8b 45 dc	 mov	 eax, DWORD PTR _extra$[ebp]
  00298	2d 02 02 00 00	 sub	 eax, 514		; 00000202H
  0029d	89 45 dc	 mov	 DWORD PTR _extra$[ebp], eax

; 192  :         end = 256;

  002a0	c7 45 b0 00 01
	00 00		 mov	 DWORD PTR _end$[ebp], 256 ; 00000100H

; 193  :         break;

  002a7	eb 15		 jmp	 SHORT $LN33@inflate_ta
$LN30@inflate_ta:

; 194  :     default:            /* DISTS */
; 195  :         base = dbase;

  002a9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _base$[ebp], OFFSET ?dbase@?1??inflate_table@@9@9

; 196  :         extra = dext;

  002b0	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _extra$[ebp], OFFSET ?dext@?1??inflate_table@@9@9

; 197  :         end = -1;

  002b7	c7 45 b0 ff ff
	ff ff		 mov	 DWORD PTR _end$[ebp], -1
$LN33@inflate_ta:

; 198  :     }
; 199  : 
; 200  :     /* initialize state for loop */
; 201  :     huff = 0;                   /* starting code */

  002be	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0

; 202  :     sym = 0;                    /* starting code symbol */

  002c5	c7 45 84 00 00
	00 00		 mov	 DWORD PTR _sym$[ebp], 0

; 203  :     len = min;                  /* starting code length */

  002cc	8b 4d d0	 mov	 ecx, DWORD PTR _min$[ebp]
  002cf	89 4d b4	 mov	 DWORD PTR _len$[ebp], ecx

; 204  :     next = *table;              /* current table to fill in */

  002d2	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  002d5	8b 02		 mov	 eax, DWORD PTR [edx]
  002d7	89 45 bc	 mov	 DWORD PTR _next$[ebp], eax

; 205  :     curr = root;                /* current table index bits */

  002da	8b 4d c0	 mov	 ecx, DWORD PTR _root$[ebp]
  002dd	89 4d c4	 mov	 DWORD PTR _curr$[ebp], ecx

; 206  :     drop = 0;                   /* current bits to drop from code for index */

  002e0	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _drop$[ebp], 0

; 207  :     low = (unsigned)(-1);       /* trigger new sub-table when len > root */

  002e7	c7 85 7c ff ff
	ff ff ff ff ff	 mov	 DWORD PTR _low$[ebp], -1

; 208  :     used = 1U << root;          /* use root table entries */

  002f1	ba 01 00 00 00	 mov	 edx, 1
  002f6	8b 4d c0	 mov	 ecx, DWORD PTR _root$[ebp]
  002f9	d3 e2		 shl	 edx, cl
  002fb	89 95 78 ff ff
	ff		 mov	 DWORD PTR _used$[ebp], edx

; 209  :     mask = used - 1;            /* mask for comparing low */

  00301	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _used$[ebp]
  00307	83 e8 01	 sub	 eax, 1
  0030a	89 45 cc	 mov	 DWORD PTR _mask$[ebp], eax

; 210  : 
; 211  :     /* check available table space */
; 212  :     if (type == LENS && used >= ENOUGH - MAXD)

  0030d	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  00311	75 16		 jne	 SHORT $LN28@inflate_ta
  00313	81 bd 78 ff ff
	ff b0 05 00 00	 cmp	 DWORD PTR _used$[ebp], 1456 ; 000005b0H
  0031d	72 0a		 jb	 SHORT $LN28@inflate_ta

; 213  :         return 1;

  0031f	b8 01 00 00 00	 mov	 eax, 1
  00324	e9 16 03 00 00	 jmp	 $LN65@inflate_ta
$LN28@inflate_ta:

; 214  : 
; 215  :     /* process all codes and make table entries */
; 216  :     for (;;) {
; 217  :         /* create table entry */
; 218  :         this.bits = (unsigned char)(len - drop);

  00329	8b 4d b4	 mov	 ecx, DWORD PTR _len$[ebp]
  0032c	2b 4d c8	 sub	 ecx, DWORD PTR _drop$[ebp]
  0032f	88 4d 81	 mov	 BYTE PTR _this$[ebp+1], cl

; 219  :         if ((int)(work[sym]) < end) {

  00332	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  00335	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  00338	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0033c	3b 4d b0	 cmp	 ecx, DWORD PTR _end$[ebp]
  0033f	7d 14		 jge	 SHORT $LN26@inflate_ta

; 220  :             this.op = (unsigned char)0;

  00341	c6 45 80 00	 mov	 BYTE PTR _this$[ebp], 0

; 221  :             this.val = work[sym];

  00345	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  00348	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0034b	66 8b 0c 50	 mov	 cx, WORD PTR [eax+edx*2]
  0034f	66 89 4d 82	 mov	 WORD PTR _this$[ebp+2], cx
  00353	eb 43		 jmp	 SHORT $LN25@inflate_ta
$LN26@inflate_ta:

; 222  :         }
; 223  :         else if ((int)(work[sym]) > end) {

  00355	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  00358	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0035b	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0035f	3b 4d b0	 cmp	 ecx, DWORD PTR _end$[ebp]
  00362	7e 2a		 jle	 SHORT $LN24@inflate_ta

; 224  :             this.op = (unsigned char)(extra[work[sym]]);

  00364	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  00367	8b 45 1c	 mov	 eax, DWORD PTR _work$[ebp]
  0036a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0036e	8b 55 dc	 mov	 edx, DWORD PTR _extra$[ebp]
  00371	8a 04 4a	 mov	 al, BYTE PTR [edx+ecx*2]
  00374	88 45 80	 mov	 BYTE PTR _this$[ebp], al

; 225  :             this.val = base[work[sym]];

  00377	8b 4d 84	 mov	 ecx, DWORD PTR _sym$[ebp]
  0037a	8b 55 1c	 mov	 edx, DWORD PTR _work$[ebp]
  0037d	0f b7 04 4a	 movzx	 eax, WORD PTR [edx+ecx*2]
  00381	8b 4d d8	 mov	 ecx, DWORD PTR _base$[ebp]
  00384	66 8b 14 41	 mov	 dx, WORD PTR [ecx+eax*2]
  00388	66 89 55 82	 mov	 WORD PTR _this$[ebp+2], dx

; 226  :         }
; 227  :         else {

  0038c	eb 0a		 jmp	 SHORT $LN25@inflate_ta
$LN24@inflate_ta:

; 228  :             this.op = (unsigned char)(32 + 64);         /* end of block */

  0038e	c6 45 80 60	 mov	 BYTE PTR _this$[ebp], 96 ; 00000060H

; 229  :             this.val = 0;

  00392	33 c0		 xor	 eax, eax
  00394	66 89 45 82	 mov	 WORD PTR _this$[ebp+2], ax
$LN25@inflate_ta:

; 230  :         }
; 231  : 
; 232  :         /* replicate for those indices with low len bits equal to huff */
; 233  :         incr = 1U << (len - drop);

  00398	8b 4d b4	 mov	 ecx, DWORD PTR _len$[ebp]
  0039b	2b 4d c8	 sub	 ecx, DWORD PTR _drop$[ebp]
  0039e	ba 01 00 00 00	 mov	 edx, 1
  003a3	d3 e2		 shl	 edx, cl
  003a5	89 55 ac	 mov	 DWORD PTR _incr$[ebp], edx

; 234  :         fill = 1U << curr;

  003a8	b8 01 00 00 00	 mov	 eax, 1
  003ad	8b 4d c4	 mov	 ecx, DWORD PTR _curr$[ebp]
  003b0	d3 e0		 shl	 eax, cl
  003b2	89 45 88	 mov	 DWORD PTR _fill$[ebp], eax

; 235  :         min = fill;                 /* save offset to next table */

  003b5	8b 4d 88	 mov	 ecx, DWORD PTR _fill$[ebp]
  003b8	89 4d d0	 mov	 DWORD PTR _min$[ebp], ecx
$LN22@inflate_ta:

; 236  :         do {
; 237  :             fill -= incr;

  003bb	8b 55 88	 mov	 edx, DWORD PTR _fill$[ebp]
  003be	2b 55 ac	 sub	 edx, DWORD PTR _incr$[ebp]
  003c1	89 55 88	 mov	 DWORD PTR _fill$[ebp], edx

; 238  :             next[(huff >> drop) + fill] = this;

  003c4	8b 45 d4	 mov	 eax, DWORD PTR _huff$[ebp]
  003c7	8b 4d c8	 mov	 ecx, DWORD PTR _drop$[ebp]
  003ca	d3 e8		 shr	 eax, cl
  003cc	03 45 88	 add	 eax, DWORD PTR _fill$[ebp]
  003cf	8b 4d bc	 mov	 ecx, DWORD PTR _next$[ebp]
  003d2	8b 55 80	 mov	 edx, DWORD PTR _this$[ebp]
  003d5	89 14 81	 mov	 DWORD PTR [ecx+eax*4], edx

; 239  :         } while (fill != 0);

  003d8	83 7d 88 00	 cmp	 DWORD PTR _fill$[ebp], 0
  003dc	75 dd		 jne	 SHORT $LN22@inflate_ta

; 240  : 
; 241  :         /* backwards increment the len-bit code huff */
; 242  :         incr = 1U << (len - 1);

  003de	8b 4d b4	 mov	 ecx, DWORD PTR _len$[ebp]
  003e1	83 e9 01	 sub	 ecx, 1
  003e4	b8 01 00 00 00	 mov	 eax, 1
  003e9	d3 e0		 shl	 eax, cl
  003eb	89 45 ac	 mov	 DWORD PTR _incr$[ebp], eax
$LN19@inflate_ta:

; 243  :         while (huff & incr)

  003ee	8b 4d d4	 mov	 ecx, DWORD PTR _huff$[ebp]
  003f1	23 4d ac	 and	 ecx, DWORD PTR _incr$[ebp]
  003f4	74 0a		 je	 SHORT $LN18@inflate_ta

; 244  :             incr >>= 1;

  003f6	8b 55 ac	 mov	 edx, DWORD PTR _incr$[ebp]
  003f9	d1 ea		 shr	 edx, 1
  003fb	89 55 ac	 mov	 DWORD PTR _incr$[ebp], edx
  003fe	eb ee		 jmp	 SHORT $LN19@inflate_ta
$LN18@inflate_ta:

; 245  :         if (incr != 0) {

  00400	83 7d ac 00	 cmp	 DWORD PTR _incr$[ebp], 0
  00404	74 17		 je	 SHORT $LN17@inflate_ta

; 246  :             huff &= incr - 1;

  00406	8b 45 ac	 mov	 eax, DWORD PTR _incr$[ebp]
  00409	83 e8 01	 sub	 eax, 1
  0040c	23 45 d4	 and	 eax, DWORD PTR _huff$[ebp]
  0040f	89 45 d4	 mov	 DWORD PTR _huff$[ebp], eax

; 247  :             huff += incr;

  00412	8b 4d d4	 mov	 ecx, DWORD PTR _huff$[ebp]
  00415	03 4d ac	 add	 ecx, DWORD PTR _incr$[ebp]
  00418	89 4d d4	 mov	 DWORD PTR _huff$[ebp], ecx

; 248  :         }
; 249  :         else

  0041b	eb 07		 jmp	 SHORT $LN16@inflate_ta
$LN17@inflate_ta:

; 250  :             huff = 0;

  0041d	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0
$LN16@inflate_ta:

; 251  : 
; 252  :         /* go to next symbol, update count, len */
; 253  :         sym++;

  00424	8b 55 84	 mov	 edx, DWORD PTR _sym$[ebp]
  00427	83 c2 01	 add	 edx, 1
  0042a	89 55 84	 mov	 DWORD PTR _sym$[ebp], edx

; 254  :         if (--(count[len]) == 0) {

  0042d	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  00430	66 8b 4c 45 e0	 mov	 cx, WORD PTR _count$[ebp+eax*2]
  00435	66 83 e9 01	 sub	 cx, 1
  00439	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  0043c	66 89 4c 55 e0	 mov	 WORD PTR _count$[ebp+edx*2], cx
  00441	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  00444	0f b7 4c 45 e0	 movzx	 ecx, WORD PTR _count$[ebp+eax*2]
  00449	85 c9		 test	 ecx, ecx
  0044b	75 24		 jne	 SHORT $LN15@inflate_ta

; 255  :             if (len == max) break;

  0044d	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  00450	3b 95 74 ff ff
	ff		 cmp	 edx, DWORD PTR _max$[ebp]
  00456	75 05		 jne	 SHORT $LN14@inflate_ta
  00458	e9 1d 01 00 00	 jmp	 $LN27@inflate_ta
$LN14@inflate_ta:

; 256  :             len = lens[work[sym]];

  0045d	8b 45 84	 mov	 eax, DWORD PTR _sym$[ebp]
  00460	8b 4d 1c	 mov	 ecx, DWORD PTR _work$[ebp]
  00463	0f b7 14 41	 movzx	 edx, WORD PTR [ecx+eax*2]
  00467	8b 45 0c	 mov	 eax, DWORD PTR _lens$[ebp]
  0046a	0f b7 0c 50	 movzx	 ecx, WORD PTR [eax+edx*2]
  0046e	89 4d b4	 mov	 DWORD PTR _len$[ebp], ecx
$LN15@inflate_ta:

; 257  :         }
; 258  : 
; 259  :         /* create new sub-table if needed */
; 260  :         if (len > root && (huff & mask) != low) {

  00471	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  00474	3b 55 c0	 cmp	 edx, DWORD PTR _root$[ebp]
  00477	0f 86 f8 00 00
	00		 jbe	 $LN13@inflate_ta
  0047d	8b 45 d4	 mov	 eax, DWORD PTR _huff$[ebp]
  00480	23 45 cc	 and	 eax, DWORD PTR _mask$[ebp]
  00483	3b 85 7c ff ff
	ff		 cmp	 eax, DWORD PTR _low$[ebp]
  00489	0f 84 e6 00 00
	00		 je	 $LN13@inflate_ta

; 261  :             /* if first time, transition to sub-tables */
; 262  :             if (drop == 0)

  0048f	83 7d c8 00	 cmp	 DWORD PTR _drop$[ebp], 0
  00493	75 06		 jne	 SHORT $LN12@inflate_ta

; 263  :                 drop = root;

  00495	8b 4d c0	 mov	 ecx, DWORD PTR _root$[ebp]
  00498	89 4d c8	 mov	 DWORD PTR _drop$[ebp], ecx
$LN12@inflate_ta:

; 264  : 
; 265  :             /* increment past last table */
; 266  :             next += min;            /* here min is 1 << curr */

  0049b	8b 55 d0	 mov	 edx, DWORD PTR _min$[ebp]
  0049e	8b 45 bc	 mov	 eax, DWORD PTR _next$[ebp]
  004a1	8d 0c 90	 lea	 ecx, DWORD PTR [eax+edx*4]
  004a4	89 4d bc	 mov	 DWORD PTR _next$[ebp], ecx

; 267  : 
; 268  :             /* determine length of next table */
; 269  :             curr = len - drop;

  004a7	8b 55 b4	 mov	 edx, DWORD PTR _len$[ebp]
  004aa	2b 55 c8	 sub	 edx, DWORD PTR _drop$[ebp]
  004ad	89 55 c4	 mov	 DWORD PTR _curr$[ebp], edx

; 270  :             left = (int)(1 << curr);

  004b0	b8 01 00 00 00	 mov	 eax, 1
  004b5	8b 4d c4	 mov	 ecx, DWORD PTR _curr$[ebp]
  004b8	d3 e0		 shl	 eax, cl
  004ba	89 45 b8	 mov	 DWORD PTR _left$[ebp], eax
$LN11@inflate_ta:

; 271  :             while (curr + drop < max) {

  004bd	8b 4d c4	 mov	 ecx, DWORD PTR _curr$[ebp]
  004c0	03 4d c8	 add	 ecx, DWORD PTR _drop$[ebp]
  004c3	3b 8d 74 ff ff
	ff		 cmp	 ecx, DWORD PTR _max$[ebp]
  004c9	73 2e		 jae	 SHORT $LN10@inflate_ta

; 272  :                 left -= count[curr + drop];

  004cb	8b 55 c4	 mov	 edx, DWORD PTR _curr$[ebp]
  004ce	03 55 c8	 add	 edx, DWORD PTR _drop$[ebp]
  004d1	0f b7 44 55 e0	 movzx	 eax, WORD PTR _count$[ebp+edx*2]
  004d6	8b 4d b8	 mov	 ecx, DWORD PTR _left$[ebp]
  004d9	2b c8		 sub	 ecx, eax
  004db	89 4d b8	 mov	 DWORD PTR _left$[ebp], ecx

; 273  :                 if (left <= 0) break;

  004de	83 7d b8 00	 cmp	 DWORD PTR _left$[ebp], 0
  004e2	7f 02		 jg	 SHORT $LN9@inflate_ta
  004e4	eb 13		 jmp	 SHORT $LN10@inflate_ta
$LN9@inflate_ta:

; 274  :                 curr++;

  004e6	8b 55 c4	 mov	 edx, DWORD PTR _curr$[ebp]
  004e9	83 c2 01	 add	 edx, 1
  004ec	89 55 c4	 mov	 DWORD PTR _curr$[ebp], edx

; 275  :                 left <<= 1;

  004ef	8b 45 b8	 mov	 eax, DWORD PTR _left$[ebp]
  004f2	d1 e0		 shl	 eax, 1
  004f4	89 45 b8	 mov	 DWORD PTR _left$[ebp], eax

; 276  :             }

  004f7	eb c4		 jmp	 SHORT $LN11@inflate_ta
$LN10@inflate_ta:

; 277  : 
; 278  :             /* check for enough space */
; 279  :             used += 1U << curr;

  004f9	ba 01 00 00 00	 mov	 edx, 1
  004fe	8b 4d c4	 mov	 ecx, DWORD PTR _curr$[ebp]
  00501	d3 e2		 shl	 edx, cl
  00503	03 95 78 ff ff
	ff		 add	 edx, DWORD PTR _used$[ebp]
  00509	89 95 78 ff ff
	ff		 mov	 DWORD PTR _used$[ebp], edx

; 280  :             if (type == LENS && used >= ENOUGH - MAXD)

  0050f	83 7d 08 01	 cmp	 DWORD PTR _type$[ebp], 1
  00513	75 16		 jne	 SHORT $LN8@inflate_ta
  00515	81 bd 78 ff ff
	ff b0 05 00 00	 cmp	 DWORD PTR _used$[ebp], 1456 ; 000005b0H
  0051f	72 0a		 jb	 SHORT $LN8@inflate_ta

; 281  :                 return 1;

  00521	b8 01 00 00 00	 mov	 eax, 1
  00526	e9 14 01 00 00	 jmp	 $LN65@inflate_ta
$LN8@inflate_ta:

; 282  : 
; 283  :             /* point entry in root table to sub-table */
; 284  :             low = huff & mask;

  0052b	8b 45 d4	 mov	 eax, DWORD PTR _huff$[ebp]
  0052e	23 45 cc	 and	 eax, DWORD PTR _mask$[ebp]
  00531	89 85 7c ff ff
	ff		 mov	 DWORD PTR _low$[ebp], eax

; 285  :             (*table)[low].op = (unsigned char)curr;

  00537	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  0053a	8b 11		 mov	 edx, DWORD PTR [ecx]
  0053c	8b 85 7c ff ff
	ff		 mov	 eax, DWORD PTR _low$[ebp]
  00542	8a 4d c4	 mov	 cl, BYTE PTR _curr$[ebp]
  00545	88 0c 82	 mov	 BYTE PTR [edx+eax*4], cl

; 286  :             (*table)[low].bits = (unsigned char)root;

  00548	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  0054b	8b 02		 mov	 eax, DWORD PTR [edx]
  0054d	8b 8d 7c ff ff
	ff		 mov	 ecx, DWORD PTR _low$[ebp]
  00553	8a 55 c0	 mov	 dl, BYTE PTR _root$[ebp]
  00556	88 54 88 01	 mov	 BYTE PTR [eax+ecx*4+1], dl

; 287  :             (*table)[low].val = (unsigned short)(next - *table);

  0055a	8b 45 14	 mov	 eax, DWORD PTR _table$[ebp]
  0055d	8b 4d bc	 mov	 ecx, DWORD PTR _next$[ebp]
  00560	2b 08		 sub	 ecx, DWORD PTR [eax]
  00562	c1 f9 02	 sar	 ecx, 2
  00565	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00568	8b 02		 mov	 eax, DWORD PTR [edx]
  0056a	8b 95 7c ff ff
	ff		 mov	 edx, DWORD PTR _low$[ebp]
  00570	66 89 4c 90 02	 mov	 WORD PTR [eax+edx*4+2], cx
$LN13@inflate_ta:

; 288  :         }
; 289  :     }

  00575	e9 af fd ff ff	 jmp	 $LN28@inflate_ta
$LN27@inflate_ta:

; 290  : 
; 291  :     /*
; 292  :        Fill in rest of table for incomplete codes.  This loop is similar to the
; 293  :        loop above in incrementing huff for table indices.  It is assumed that
; 294  :        len is equal to curr + drop, so there is no loop needed to increment
; 295  :        through high index bits.  When the current sub-table is filled, the loop
; 296  :        drops back to the root table to fill in any remaining entries there.
; 297  :      */
; 298  :     this.op = (unsigned char)64;                /* invalid code marker */

  0057a	c6 45 80 40	 mov	 BYTE PTR _this$[ebp], 64 ; 00000040H

; 299  :     this.bits = (unsigned char)(len - drop);

  0057e	8b 45 b4	 mov	 eax, DWORD PTR _len$[ebp]
  00581	2b 45 c8	 sub	 eax, DWORD PTR _drop$[ebp]
  00584	88 45 81	 mov	 BYTE PTR _this$[ebp+1], al

; 300  :     this.val = (unsigned short)0;

  00587	33 c9		 xor	 ecx, ecx
  00589	66 89 4d 82	 mov	 WORD PTR _this$[ebp+2], cx
$LN7@inflate_ta:

; 301  :     while (huff != 0) {

  0058d	83 7d d4 00	 cmp	 DWORD PTR _huff$[ebp], 0
  00591	0f 84 8b 00 00
	00		 je	 $LN6@inflate_ta

; 302  :         /* when done with sub-table, drop back to root table */
; 303  :         if (drop != 0 && (huff & mask) != low) {

  00597	83 7d c8 00	 cmp	 DWORD PTR _drop$[ebp], 0
  0059b	74 29		 je	 SHORT $LN5@inflate_ta
  0059d	8b 55 d4	 mov	 edx, DWORD PTR _huff$[ebp]
  005a0	23 55 cc	 and	 edx, DWORD PTR _mask$[ebp]
  005a3	3b 95 7c ff ff
	ff		 cmp	 edx, DWORD PTR _low$[ebp]
  005a9	74 1b		 je	 SHORT $LN5@inflate_ta

; 304  :             drop = 0;

  005ab	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR _drop$[ebp], 0

; 305  :             len = root;

  005b2	8b 45 c0	 mov	 eax, DWORD PTR _root$[ebp]
  005b5	89 45 b4	 mov	 DWORD PTR _len$[ebp], eax

; 306  :             next = *table;

  005b8	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  005bb	8b 11		 mov	 edx, DWORD PTR [ecx]
  005bd	89 55 bc	 mov	 DWORD PTR _next$[ebp], edx

; 307  :             this.bits = (unsigned char)len;

  005c0	8a 45 b4	 mov	 al, BYTE PTR _len$[ebp]
  005c3	88 45 81	 mov	 BYTE PTR _this$[ebp+1], al
$LN5@inflate_ta:

; 308  :         }
; 309  : 
; 310  :         /* put invalid code marker in table */
; 311  :         next[huff >> drop] = this;

  005c6	8b 55 d4	 mov	 edx, DWORD PTR _huff$[ebp]
  005c9	8b 4d c8	 mov	 ecx, DWORD PTR _drop$[ebp]
  005cc	d3 ea		 shr	 edx, cl
  005ce	8b 45 bc	 mov	 eax, DWORD PTR _next$[ebp]
  005d1	8b 4d 80	 mov	 ecx, DWORD PTR _this$[ebp]
  005d4	89 0c 90	 mov	 DWORD PTR [eax+edx*4], ecx

; 312  : 
; 313  :         /* backwards increment the len-bit code huff */
; 314  :         incr = 1U << (len - 1);

  005d7	8b 4d b4	 mov	 ecx, DWORD PTR _len$[ebp]
  005da	83 e9 01	 sub	 ecx, 1
  005dd	ba 01 00 00 00	 mov	 edx, 1
  005e2	d3 e2		 shl	 edx, cl
  005e4	89 55 ac	 mov	 DWORD PTR _incr$[ebp], edx
$LN4@inflate_ta:

; 315  :         while (huff & incr)

  005e7	8b 45 d4	 mov	 eax, DWORD PTR _huff$[ebp]
  005ea	23 45 ac	 and	 eax, DWORD PTR _incr$[ebp]
  005ed	74 0a		 je	 SHORT $LN3@inflate_ta

; 316  :             incr >>= 1;

  005ef	8b 4d ac	 mov	 ecx, DWORD PTR _incr$[ebp]
  005f2	d1 e9		 shr	 ecx, 1
  005f4	89 4d ac	 mov	 DWORD PTR _incr$[ebp], ecx
  005f7	eb ee		 jmp	 SHORT $LN4@inflate_ta
$LN3@inflate_ta:

; 317  :         if (incr != 0) {

  005f9	83 7d ac 00	 cmp	 DWORD PTR _incr$[ebp], 0
  005fd	74 17		 je	 SHORT $LN2@inflate_ta

; 318  :             huff &= incr - 1;

  005ff	8b 55 ac	 mov	 edx, DWORD PTR _incr$[ebp]
  00602	83 ea 01	 sub	 edx, 1
  00605	23 55 d4	 and	 edx, DWORD PTR _huff$[ebp]
  00608	89 55 d4	 mov	 DWORD PTR _huff$[ebp], edx

; 319  :             huff += incr;

  0060b	8b 45 d4	 mov	 eax, DWORD PTR _huff$[ebp]
  0060e	03 45 ac	 add	 eax, DWORD PTR _incr$[ebp]
  00611	89 45 d4	 mov	 DWORD PTR _huff$[ebp], eax

; 320  :         }
; 321  :         else

  00614	eb 07		 jmp	 SHORT $LN1@inflate_ta
$LN2@inflate_ta:

; 322  :             huff = 0;

  00616	c7 45 d4 00 00
	00 00		 mov	 DWORD PTR _huff$[ebp], 0
$LN1@inflate_ta:

; 323  :     }

  0061d	e9 6b ff ff ff	 jmp	 $LN7@inflate_ta
$LN6@inflate_ta:

; 324  : 
; 325  :     /* set return parameters */
; 326  :     *table += used;

  00622	8b 4d 14	 mov	 ecx, DWORD PTR _table$[ebp]
  00625	8b 11		 mov	 edx, DWORD PTR [ecx]
  00627	8b 85 78 ff ff
	ff		 mov	 eax, DWORD PTR _used$[ebp]
  0062d	8d 0c 82	 lea	 ecx, DWORD PTR [edx+eax*4]
  00630	8b 55 14	 mov	 edx, DWORD PTR _table$[ebp]
  00633	89 0a		 mov	 DWORD PTR [edx], ecx

; 327  :     *bits = root;

  00635	8b 45 18	 mov	 eax, DWORD PTR _bits$[ebp]
  00638	8b 4d c0	 mov	 ecx, DWORD PTR _root$[ebp]
  0063b	89 08		 mov	 DWORD PTR [eax], ecx

; 328  :     return 0;

  0063d	33 c0		 xor	 eax, eax
$LN65@inflate_ta:

; 329  : }

  0063f	8b e5		 mov	 esp, ebp
  00641	5d		 pop	 ebp
  00642	c3		 ret	 0
_inflate_table ENDP
END
