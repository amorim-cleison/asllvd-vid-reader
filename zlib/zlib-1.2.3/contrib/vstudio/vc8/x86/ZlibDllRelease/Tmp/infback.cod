; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\infback.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@	; `string'
PUBLIC	??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ ; `string'
PUBLIC	??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ ; `string'
PUBLIC	??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ ; `string'
PUBLIC	??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ ; `string'
PUBLIC	??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@	; `string'
PUBLIC	??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ ; `string'
PUBLIC	??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@	; `string'
PUBLIC	??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ ; `string'
EXTRN	_inflate_fast:PROC
;	COMDAT ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@
CONST	SEGMENT
??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@ DB 'invalid dis'
	DB	'tance too far back', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@
CONST	SEGMENT
??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@ DB 'invalid distance code'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@
CONST	SEGMENT
??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@ DB 'invalid litera'
	DB	'l/length code', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@
CONST	SEGMENT
??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@ DB 'invalid distances set'
	DB	00H						; `string'
CONST	ENDS
;	COMDAT ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@ DB 'invalid litera'
	DB	'l/lengths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@
CONST	SEGMENT
??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@ DB 'invalid bit leng'
	DB	'th repeat', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@ DB 'invalid code leng'
	DB	'ths set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@
CONST	SEGMENT
??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@ DB 'too many le'
	DB	'ngth or distance symbols', 00H		; `string'
CONST	ENDS
;	COMDAT ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@
CONST	SEGMENT
??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@ DB 'invalid store'
	DB	'd block lengths', 00H			; `string'
CONST	ENDS
;	COMDAT ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@
CONST	SEGMENT
??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@ DB 'invalid block type', 00H ; `string'
	ORG $+2
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflateBack@@9@9 DW 010H			; `inflateBack'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateBackEnd@4
; Function compile flags: /Odtp
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\infback.c
;	COMDAT _inflateBackEnd@4
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_inflateBackEnd@4 PROC					; COMDAT

; 616  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 617  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00003	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00007	74 12		 je	 SHORT $LN1@inflateBac
  00009	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000c	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00010	74 09		 je	 SHORT $LN1@inflateBac
  00012	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00015	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00019	75 07		 jne	 SHORT $LN2@inflateBac
$LN1@inflateBac:

; 618  :         return Z_STREAM_ERROR;

  0001b	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00020	eb 25		 jmp	 SHORT $LN3@inflateBac
$LN2@inflateBac:

; 619  :     ZFREE(strm, strm->state);

  00022	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00025	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00028	50		 push	 eax
  00029	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0002c	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0002f	52		 push	 edx
  00030	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00033	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00036	ff d1		 call	 ecx
  00038	83 c4 08	 add	 esp, 8

; 620  :     strm->state = Z_NULL;

  0003b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003e	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 621  :     Tracev((stderr, "inflate: end\n"));
; 622  :     return Z_OK;

  00045	33 c0		 xor	 eax, eax
$LN3@inflateBac:

; 623  : }

  00047	5d		 pop	 ebp
  00048	c2 04 00	 ret	 4
_inflateBackEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 75   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 76   : #ifdef BUILDFIXED
; 77   :     static int virgin = 1;
; 78   :     static code *lenfix, *distfix;
; 79   :     static code fixed[544];
; 80   : 
; 81   :     /* build fixed huffman tables if first call (may not be thread safe) */
; 82   :     if (virgin) {
; 83   :         unsigned sym, bits;
; 84   :         static code *next;
; 85   : 
; 86   :         /* literal/length table */
; 87   :         sym = 0;
; 88   :         while (sym < 144) state->lens[sym++] = 8;
; 89   :         while (sym < 256) state->lens[sym++] = 9;
; 90   :         while (sym < 280) state->lens[sym++] = 7;
; 91   :         while (sym < 288) state->lens[sym++] = 8;
; 92   :         next = fixed;
; 93   :         lenfix = next;
; 94   :         bits = 9;
; 95   :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 96   : 
; 97   :         /* distance table */
; 98   :         sym = 0;
; 99   :         while (sym < 32) state->lens[sym++] = 5;
; 100  :         distfix = next;
; 101  :         bits = 5;
; 102  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 103  : 
; 104  :         /* do this just once */
; 105  :         virgin = 0;
; 106  :     }
; 107  : #else /* !BUILDFIXED */
; 108  : #   include "inffixed.h"
; 109  : #endif /* BUILDFIXED */
; 110  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 111  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 112  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 113  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 114  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateBackInit_@20
; Function compile flags: /Odtp
;	COMDAT _inflateBackInit_@20
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_window$ = 16						; size = 4
_version$ = 20						; size = 4
_stream_size$ = 24					; size = 4
_inflateBackInit_@20 PROC				; COMDAT

; 34   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 35   :     struct inflate_state FAR *state;
; 36   : 
; 37   :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 38   :         stream_size != (int)(sizeof(z_stream)))

  00004	83 7d 14 00	 cmp	 DWORD PTR _version$[ebp], 0
  00008	74 17		 je	 SHORT $LN6@inflateBac@2
  0000a	8b 45 14	 mov	 eax, DWORD PTR _version$[ebp]
  0000d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00010	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_05GDHACFMB@1?42?43?$AA@
  00017	3b ca		 cmp	 ecx, edx
  00019	75 06		 jne	 SHORT $LN6@inflateBac@2
  0001b	83 7d 18 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	74 0a		 je	 SHORT $LN7@inflateBac@2
$LN6@inflateBac@2:

; 39   :         return Z_VERSION_ERROR;

  00021	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00026	e9 d0 00 00 00	 jmp	 $LN8@inflateBac@2
$LN7@inflateBac@2:

; 40   :     if (strm == Z_NULL || window == Z_NULL ||
; 41   :         windowBits < 8 || windowBits > 15)

  0002b	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0002f	74 12		 je	 SHORT $LN4@inflateBac@2
  00031	83 7d 10 00	 cmp	 DWORD PTR _window$[ebp], 0
  00035	74 0c		 je	 SHORT $LN4@inflateBac@2
  00037	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  0003b	7c 06		 jl	 SHORT $LN4@inflateBac@2
  0003d	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  00041	7e 0a		 jle	 SHORT $LN5@inflateBac@2
$LN4@inflateBac@2:

; 42   :         return Z_STREAM_ERROR;

  00043	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00048	e9 ae 00 00 00	 jmp	 $LN8@inflateBac@2
$LN5@inflateBac@2:

; 43   :     strm->msg = Z_NULL;                 /* in case we return an error */

  0004d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00050	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 44   :     if (strm->zalloc == (alloc_func)0) {

  00057	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005a	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0005e	75 14		 jne	 SHORT $LN3@inflateBac@2

; 45   :         strm->zalloc = zcalloc;

  00060	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00063	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 46   :         strm->opaque = (voidpf)0;

  0006a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0006d	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN3@inflateBac@2:

; 47   :     }
; 48   :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00074	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00077	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0007b	75 0a		 jne	 SHORT $LN2@inflateBac@2
  0007d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00080	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN2@inflateBac@2:

; 49   :     state = (struct inflate_state FAR *)ZALLOC(strm, 1,
; 50   :                                                sizeof(struct inflate_state));

  00087	68 30 25 00 00	 push	 9520			; 00002530H
  0008c	6a 01		 push	 1
  0008e	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00091	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00094	51		 push	 ecx
  00095	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00098	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0009b	ff d0		 call	 eax
  0009d	83 c4 0c	 add	 esp, 12			; 0000000cH
  000a0	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 51   :     if (state == Z_NULL) return Z_MEM_ERROR;

  000a3	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  000a7	75 07		 jne	 SHORT $LN1@inflateBac@2
  000a9	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000ae	eb 4b		 jmp	 SHORT $LN8@inflateBac@2
$LN1@inflateBac@2:

; 52   :     Tracev((stderr, "inflate: allocated\n"));
; 53   :     strm->state = (struct internal_state FAR *)state;

  000b0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000b3	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b6	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 54   :     state->dmax = 32768U;

  000b9	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000bc	c7 40 14 00 80
	00 00		 mov	 DWORD PTR [eax+20], 32768 ; 00008000H

; 55   :     state->wbits = windowBits;

  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  000c9	89 51 24	 mov	 DWORD PTR [ecx+36], edx

; 56   :     state->wsize = 1U << windowBits;

  000cc	b8 01 00 00 00	 mov	 eax, 1
  000d1	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000d4	d3 e0		 shl	 eax, cl
  000d6	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000d9	89 41 28	 mov	 DWORD PTR [ecx+40], eax

; 57   :     state->window = window;

  000dc	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000df	8b 45 10	 mov	 eax, DWORD PTR _window$[ebp]
  000e2	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 58   :     state->write = 0;

  000e5	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000e8	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 59   :     state->whave = 0;

  000ef	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f2	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 60   :     return Z_OK;

  000f9	33 c0		 xor	 eax, eax
$LN8@inflateBac@2:

; 61   : }

  000fb	8b e5		 mov	 esp, ebp
  000fd	5d		 pop	 ebp
  000fe	c2 14 00	 ret	 20			; 00000014H
_inflateBackInit_@20 ENDP
PUBLIC	_inflateBack@20
; Function compile flags: /Odtp
;	COMDAT _inflateBack@20
_TEXT	SEGMENT
tv137 = -64						; size = 4
tv76 = -60						; size = 4
tv73 = -56						; size = 4
_state$ = -52						; size = 4
_from$ = -48						; size = 4
_copy$ = -44						; size = 4
_this$ = -40						; size = 4
_hold$ = -36						; size = 4
_ret$ = -32						; size = 4
_next$ = -28						; size = 4
_left$ = -24						; size = 4
_bits$ = -20						; size = 4
_len$ = -16						; size = 4
_have$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_in$ = 12						; size = 4
_in_desc$ = 16						; size = 4
_out$ = 20						; size = 4
_out_desc$ = 24						; size = 4
_inflateBack@20 PROC					; COMDAT

; 247  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 40	 sub	 esp, 64			; 00000040H

; 248  :     struct inflate_state FAR *state;
; 249  :     unsigned char FAR *next;    /* next input */
; 250  :     unsigned char FAR *put;     /* next output */
; 251  :     unsigned have, left;        /* available input and output */
; 252  :     unsigned long hold;         /* bit buffer */
; 253  :     unsigned bits;              /* bits in bit buffer */
; 254  :     unsigned copy;              /* number of stored or match bytes to copy */
; 255  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 256  :     code this;                  /* current decoding table entry */
; 257  :     code last;                  /* parent table entry */
; 258  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 259  :     int ret;                    /* return code */
; 260  :     static const unsigned short order[19] = /* permutation of code lengths */
; 261  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 262  : 
; 263  :     /* Check that the strm exists and that the state was initialized */
; 264  :     if (strm == Z_NULL || strm->state == Z_NULL)

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN345@inflateBac@3
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN346@inflateBac@3
$LN345@inflateBac@3:

; 265  :         return Z_STREAM_ERROR;

  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 81 13 00 00	 jmp	 $LN347@inflateBac@3
$LN346@inflateBac@3:

; 266  :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 cc	 mov	 DWORD PTR _state$[ebp], edx

; 267  : 
; 268  :     /* Reset the state */
; 269  :     strm->msg = Z_NULL;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 270  :     state->mode = TYPE;

  00032	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00035	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 271  :     state->last = 0;

  0003b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0003e	c7 42 04 00 00
	00 00		 mov	 DWORD PTR [edx+4], 0

; 272  :     state->whave = 0;

  00045	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00048	c7 40 2c 00 00
	00 00		 mov	 DWORD PTR [eax+44], 0

; 273  :     next = strm->next_in;

  0004f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00052	8b 11		 mov	 edx, DWORD PTR [ecx]
  00054	89 55 e4	 mov	 DWORD PTR _next$[ebp], edx

; 274  :     have = next != Z_NULL ? strm->avail_in : 0;

  00057	83 7d e4 00	 cmp	 DWORD PTR _next$[ebp], 0
  0005b	74 0b		 je	 SHORT $LN349@inflateBac@3
  0005d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00060	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00063	89 4d c8	 mov	 DWORD PTR tv73[ebp], ecx
  00066	eb 07		 jmp	 SHORT $LN350@inflateBac@3
$LN349@inflateBac@3:
  00068	c7 45 c8 00 00
	00 00		 mov	 DWORD PTR tv73[ebp], 0
$LN350@inflateBac@3:
  0006f	8b 55 c8	 mov	 edx, DWORD PTR tv73[ebp]
  00072	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx

; 275  :     hold = 0;

  00075	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0

; 276  :     bits = 0;

  0007c	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0

; 277  :     put = state->window;

  00083	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00086	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00089	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx

; 278  :     left = state->wsize;

  0008c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0008f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00092	89 45 e8	 mov	 DWORD PTR _left$[ebp], eax
$LN344@inflateBac@3:

; 279  : 
; 280  :     /* Inflate until end of block marked as last */
; 281  :     for (;;)
; 282  :         switch (state->mode) {

  00095	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00098	8b 11		 mov	 edx, DWORD PTR [ecx]
  0009a	89 55 c4	 mov	 DWORD PTR tv76[ebp], edx
  0009d	8b 45 c4	 mov	 eax, DWORD PTR tv76[ebp]
  000a0	83 e8 0b	 sub	 eax, 11			; 0000000bH
  000a3	89 45 c4	 mov	 DWORD PTR tv76[ebp], eax
  000a6	83 7d c4 10	 cmp	 DWORD PTR tv76[ebp], 16	; 00000010H
  000aa	0f 87 ce 12 00
	00		 ja	 $LN1@inflateBac@3
  000b0	8b 4d c4	 mov	 ecx, DWORD PTR tv76[ebp]
  000b3	0f b6 91 00 00
	00 00		 movzx	 edx, BYTE PTR $LN351@inflateBac@3[ecx]
  000ba	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN352@inflateBac@3[edx*4]
$LN340@inflateBac@3:

; 283  :         case TYPE:
; 284  :             /* determine and dispatch block type */
; 285  :             if (state->last) {

  000c1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000c4	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  000c8	74 2e		 je	 SHORT $LN332@inflateBac@3
$LN338@inflateBac@3:

; 286  :                 BYTEBITS();

  000ca	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  000cd	83 e1 07	 and	 ecx, 7
  000d0	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  000d3	d3 ea		 shr	 edx, cl
  000d5	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  000d8	8b 45 ec	 mov	 eax, DWORD PTR _bits$[ebp]
  000db	83 e0 07	 and	 eax, 7
  000de	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  000e1	2b c8		 sub	 ecx, eax
  000e3	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  000e6	33 d2		 xor	 edx, edx
  000e8	75 e0		 jne	 SHORT $LN338@inflateBac@3

; 287  :                 state->mode = DONE;

  000ea	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  000ed	c7 00 1a 00 00
	00		 mov	 DWORD PTR [eax], 26	; 0000001aH

; 288  :                 break;

  000f3	e9 8f 12 00 00	 jmp	 $LN341@inflateBac@3
$LN332@inflateBac@3:

; 289  :             }
; 290  :             NEEDBITS(3);

  000f8	83 7d ec 03	 cmp	 DWORD PTR _bits$[ebp], 3
  000fc	73 66		 jae	 SHORT $LN334@inflateBac@3
$LN327@inflateBac@3:
  000fe	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00102	75 2a		 jne	 SHORT $LN326@inflateBac@3
  00104	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  00107	51		 push	 ecx
  00108	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  0010b	52		 push	 edx
  0010c	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  0010f	83 c4 08	 add	 esp, 8
  00112	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00115	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00119	75 13		 jne	 SHORT $LN326@inflateBac@3
  0011b	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00122	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00129	e9 5e 12 00 00	 jmp	 $inf_leave$77603
$LN326@inflateBac@3:
  0012e	33 c0		 xor	 eax, eax
  00130	75 cc		 jne	 SHORT $LN327@inflateBac@3
  00132	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00135	83 e9 01	 sub	 ecx, 1
  00138	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  0013b	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  0013e	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00141	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00144	d3 e0		 shl	 eax, cl
  00146	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  00149	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  0014c	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  0014f	83 c1 01	 add	 ecx, 1
  00152	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  00155	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00158	83 c2 08	 add	 edx, 8
  0015b	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  0015e	33 c0		 xor	 eax, eax
  00160	75 9c		 jne	 SHORT $LN327@inflateBac@3
  00162	eb 94		 jmp	 SHORT $LN332@inflateBac@3
$LN334@inflateBac@3:
  00164	33 c9		 xor	 ecx, ecx
  00166	75 90		 jne	 SHORT $LN332@inflateBac@3

; 291  :             state->last = BITS(1);

  00168	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  0016b	83 e2 01	 and	 edx, 1
  0016e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00171	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN322@inflateBac@3:

; 292  :             DROPBITS(1);

  00174	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  00177	d1 e9		 shr	 ecx, 1
  00179	89 4d dc	 mov	 DWORD PTR _hold$[ebp], ecx
  0017c	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  0017f	83 ea 01	 sub	 edx, 1
  00182	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00185	33 c0		 xor	 eax, eax
  00187	75 eb		 jne	 SHORT $LN322@inflateBac@3

; 293  :             switch (BITS(2)) {

  00189	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  0018c	83 e1 03	 and	 ecx, 3
  0018f	89 4d c0	 mov	 DWORD PTR tv137[ebp], ecx
  00192	83 7d c0 03	 cmp	 DWORD PTR tv137[ebp], 3
  00196	77 4a		 ja	 SHORT $LN313@inflateBac@3
  00198	8b 55 c0	 mov	 edx, DWORD PTR tv137[ebp]
  0019b	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN353@inflateBac@3[edx*4]
$LN317@inflateBac@3:

; 294  :             case 0:                             /* stored block */
; 295  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 296  :                         state->last ? " (last)" : ""));
; 297  :                 state->mode = STORED;

  001a2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001a5	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 298  :                 break;

  001ab	eb 35		 jmp	 SHORT $LN313@inflateBac@3
$LN316@inflateBac@3:

; 299  :             case 1:                             /* fixed block */
; 300  :                 fixedtables(state);

  001ad	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  001b0	51		 push	 ecx
  001b1	e8 00 00 00 00	 call	 _fixedtables
  001b6	83 c4 04	 add	 esp, 4

; 301  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 302  :                         state->last ? " (last)" : ""));
; 303  :                 state->mode = LEN;              /* decode codes */

  001b9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001bc	c7 02 12 00 00
	00		 mov	 DWORD PTR [edx], 18	; 00000012H

; 304  :                 break;

  001c2	eb 1e		 jmp	 SHORT $LN313@inflateBac@3
$LN315@inflateBac@3:

; 305  :             case 2:                             /* dynamic block */
; 306  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 307  :                         state->last ? " (last)" : ""));
; 308  :                 state->mode = TABLE;

  001c4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  001c7	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH

; 309  :                 break;

  001cd	eb 13		 jmp	 SHORT $LN313@inflateBac@3
$LN314@inflateBac@3:

; 310  :             case 3:
; 311  :                 strm->msg = (char *)"invalid block type";

  001cf	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  001d2	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 312  :                 state->mode = BAD;

  001d9	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  001dc	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH
$LN313@inflateBac@3:

; 313  :             }
; 314  :             DROPBITS(2);

  001e2	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  001e5	c1 e8 02	 shr	 eax, 2
  001e8	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  001eb	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  001ee	83 e9 02	 sub	 ecx, 2
  001f1	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  001f4	33 d2		 xor	 edx, edx
  001f6	75 ea		 jne	 SHORT $LN313@inflateBac@3

; 315  :             break;

  001f8	e9 8a 11 00 00	 jmp	 $LN341@inflateBac@3
$LN309@inflateBac@3:

; 316  : 
; 317  :         case STORED:
; 318  :             /* get and verify stored block length */
; 319  :             BYTEBITS();                         /* go to byte boundary */

  001fd	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00200	83 e1 07	 and	 ecx, 7
  00203	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  00206	d3 e8		 shr	 eax, cl
  00208	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  0020b	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0020e	83 e1 07	 and	 ecx, 7
  00211	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00214	2b d1		 sub	 edx, ecx
  00216	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00219	33 c0		 xor	 eax, eax
  0021b	75 e0		 jne	 SHORT $LN309@inflateBac@3
$LN303@inflateBac@3:

; 320  :             NEEDBITS(32);

  0021d	83 7d ec 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00221	73 66		 jae	 SHORT $LN305@inflateBac@3
$LN298@inflateBac@3:
  00223	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00227	75 2a		 jne	 SHORT $LN297@inflateBac@3
  00229	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  0022c	51		 push	 ecx
  0022d	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00230	52		 push	 edx
  00231	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00234	83 c4 08	 add	 esp, 8
  00237	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0023a	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0023e	75 13		 jne	 SHORT $LN297@inflateBac@3
  00240	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00247	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0024e	e9 39 11 00 00	 jmp	 $inf_leave$77603
$LN297@inflateBac@3:
  00253	33 c0		 xor	 eax, eax
  00255	75 cc		 jne	 SHORT $LN298@inflateBac@3
  00257	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  0025a	83 e9 01	 sub	 ecx, 1
  0025d	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00260	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  00263	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00266	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00269	d3 e0		 shl	 eax, cl
  0026b	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  0026e	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00271	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00274	83 c1 01	 add	 ecx, 1
  00277	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  0027a	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  0027d	83 c2 08	 add	 edx, 8
  00280	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00283	33 c0		 xor	 eax, eax
  00285	75 9c		 jne	 SHORT $LN298@inflateBac@3
  00287	eb 94		 jmp	 SHORT $LN303@inflateBac@3
$LN305@inflateBac@3:
  00289	33 c9		 xor	 ecx, ecx
  0028b	75 90		 jne	 SHORT $LN303@inflateBac@3

; 321  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  0028d	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00290	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00296	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  00299	c1 e8 10	 shr	 eax, 16			; 00000010H
  0029c	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  002a1	3b d0		 cmp	 edx, eax
  002a3	74 18		 je	 SHORT $LN293@inflateBac@3

; 322  :                 strm->msg = (char *)"invalid stored block lengths";

  002a5	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  002a8	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 323  :                 state->mode = BAD;

  002af	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  002b2	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 324  :                 break;

  002b8	e9 ca 10 00 00	 jmp	 $LN341@inflateBac@3
$LN293@inflateBac@3:

; 325  :             }
; 326  :             state->length = (unsigned)hold & 0xffff;

  002bd	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  002c0	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  002c5	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002c8	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN292@inflateBac@3:

; 327  :             Tracev((stderr, "inflate:       stored length %u\n",
; 328  :                     state->length));
; 329  :             INITBITS();

  002cb	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  002d2	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002d9	33 d2		 xor	 edx, edx
  002db	75 ee		 jne	 SHORT $LN292@inflateBac@3
$LN289@inflateBac@3:

; 330  : 
; 331  :             /* copy stored block from input to output */
; 332  :             while (state->length != 0) {

  002dd	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  002e0	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  002e4	0f 84 ec 00 00
	00		 je	 $LN288@inflateBac@3

; 333  :                 copy = state->length;

  002ea	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  002ed	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  002f0	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN287@inflateBac@3:

; 334  :                 PULL();

  002f3	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  002f7	75 2a		 jne	 SHORT $LN286@inflateBac@3
  002f9	8d 45 e4	 lea	 eax, DWORD PTR _next$[ebp]
  002fc	50		 push	 eax
  002fd	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00300	51		 push	 ecx
  00301	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00304	83 c4 08	 add	 esp, 8
  00307	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0030a	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0030e	75 13		 jne	 SHORT $LN286@inflateBac@3
  00310	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00317	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0031e	e9 69 10 00 00	 jmp	 $inf_leave$77603
$LN286@inflateBac@3:
  00323	33 d2		 xor	 edx, edx
  00325	75 cc		 jne	 SHORT $LN287@inflateBac@3
$LN282@inflateBac@3:

; 335  :                 ROOM();

  00327	83 7d e8 00	 cmp	 DWORD PTR _left$[ebp], 0
  0032b	75 3d		 jne	 SHORT $LN281@inflateBac@3
  0032d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00330	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00333	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  00336	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00339	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0033c	89 45 e8	 mov	 DWORD PTR _left$[ebp], eax
  0033f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00342	8b 55 e8	 mov	 edx, DWORD PTR _left$[ebp]
  00345	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  00348	8b 45 e8	 mov	 eax, DWORD PTR _left$[ebp]
  0034b	50		 push	 eax
  0034c	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  0034f	51		 push	 ecx
  00350	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  00353	52		 push	 edx
  00354	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00357	83 c4 0c	 add	 esp, 12			; 0000000cH
  0035a	85 c0		 test	 eax, eax
  0035c	74 0c		 je	 SHORT $LN281@inflateBac@3
  0035e	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00365	e9 22 10 00 00	 jmp	 $inf_leave$77603
$LN281@inflateBac@3:
  0036a	33 c0		 xor	 eax, eax
  0036c	75 b9		 jne	 SHORT $LN282@inflateBac@3

; 336  :                 if (copy > have) copy = have;

  0036e	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00371	3b 4d f4	 cmp	 ecx, DWORD PTR _have$[ebp]
  00374	76 06		 jbe	 SHORT $LN277@inflateBac@3
  00376	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  00379	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
$LN277@inflateBac@3:

; 337  :                 if (copy > left) copy = left;

  0037c	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  0037f	3b 45 e8	 cmp	 eax, DWORD PTR _left$[ebp]
  00382	76 06		 jbe	 SHORT $LN276@inflateBac@3
  00384	8b 4d e8	 mov	 ecx, DWORD PTR _left$[ebp]
  00387	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN276@inflateBac@3:

; 338  :                 zmemcpy(put, next, copy);

  0038a	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  0038d	52		 push	 edx
  0038e	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  00391	50		 push	 eax
  00392	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00395	51		 push	 ecx
  00396	e8 00 00 00 00	 call	 _memcpy
  0039b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 339  :                 have -= copy;

  0039e	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  003a1	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  003a4	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx

; 340  :                 next += copy;

  003a7	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  003aa	03 45 d4	 add	 eax, DWORD PTR _copy$[ebp]
  003ad	89 45 e4	 mov	 DWORD PTR _next$[ebp], eax

; 341  :                 left -= copy;

  003b0	8b 4d e8	 mov	 ecx, DWORD PTR _left$[ebp]
  003b3	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003b6	89 4d e8	 mov	 DWORD PTR _left$[ebp], ecx

; 342  :                 put += copy;

  003b9	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  003bc	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  003bf	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 343  :                 state->length -= copy;

  003c2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003c5	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  003c8	2b 4d d4	 sub	 ecx, DWORD PTR _copy$[ebp]
  003cb	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  003ce	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 344  :             }

  003d1	e9 07 ff ff ff	 jmp	 $LN289@inflateBac@3
$LN288@inflateBac@3:

; 345  :             Tracev((stderr, "inflate:       stored end\n"));
; 346  :             state->mode = TYPE;

  003d6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  003d9	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 347  :             break;

  003df	e9 a3 0f 00 00	 jmp	 $LN341@inflateBac@3
$LN271@inflateBac@3:

; 348  : 
; 349  :         case TABLE:
; 350  :             /* get dynamic table entries descriptor */
; 351  :             NEEDBITS(14);

  003e4	83 7d ec 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  003e8	73 66		 jae	 SHORT $LN273@inflateBac@3
$LN266@inflateBac@3:
  003ea	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  003ee	75 2a		 jne	 SHORT $LN265@inflateBac@3
  003f0	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  003f3	51		 push	 ecx
  003f4	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  003f7	52		 push	 edx
  003f8	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  003fb	83 c4 08	 add	 esp, 8
  003fe	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00401	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00405	75 13		 jne	 SHORT $LN265@inflateBac@3
  00407	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0040e	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00415	e9 72 0f 00 00	 jmp	 $inf_leave$77603
$LN265@inflateBac@3:
  0041a	33 c0		 xor	 eax, eax
  0041c	75 cc		 jne	 SHORT $LN266@inflateBac@3
  0041e	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00421	83 e9 01	 sub	 ecx, 1
  00424	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00427	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  0042a	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0042d	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00430	d3 e0		 shl	 eax, cl
  00432	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  00435	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00438	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  0043b	83 c1 01	 add	 ecx, 1
  0043e	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  00441	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00444	83 c2 08	 add	 edx, 8
  00447	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  0044a	33 c0		 xor	 eax, eax
  0044c	75 9c		 jne	 SHORT $LN266@inflateBac@3
  0044e	eb 94		 jmp	 SHORT $LN271@inflateBac@3
$LN273@inflateBac@3:
  00450	33 c9		 xor	 ecx, ecx
  00452	75 90		 jne	 SHORT $LN271@inflateBac@3

; 352  :             state->nlen = BITS(5) + 257;

  00454	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00457	83 e2 1f	 and	 edx, 31			; 0000001fH
  0045a	81 c2 01 01 00
	00		 add	 edx, 257		; 00000101H
  00460	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00463	89 50 60	 mov	 DWORD PTR [eax+96], edx
$LN261@inflateBac@3:

; 353  :             DROPBITS(5);

  00466	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  00469	c1 e9 05	 shr	 ecx, 5
  0046c	89 4d dc	 mov	 DWORD PTR _hold$[ebp], ecx
  0046f	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00472	83 ea 05	 sub	 edx, 5
  00475	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00478	33 c0		 xor	 eax, eax
  0047a	75 ea		 jne	 SHORT $LN261@inflateBac@3

; 354  :             state->ndist = BITS(5) + 1;

  0047c	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  0047f	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00482	83 c1 01	 add	 ecx, 1
  00485	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00488	89 4a 64	 mov	 DWORD PTR [edx+100], ecx
$LN258@inflateBac@3:

; 355  :             DROPBITS(5);

  0048b	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  0048e	c1 e8 05	 shr	 eax, 5
  00491	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00494	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00497	83 e9 05	 sub	 ecx, 5
  0049a	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  0049d	33 d2		 xor	 edx, edx
  0049f	75 ea		 jne	 SHORT $LN258@inflateBac@3

; 356  :             state->ncode = BITS(4) + 4;

  004a1	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  004a4	83 e0 0f	 and	 eax, 15			; 0000000fH
  004a7	83 c0 04	 add	 eax, 4
  004aa	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  004ad	89 41 5c	 mov	 DWORD PTR [ecx+92], eax
$LN255@inflateBac@3:

; 357  :             DROPBITS(4);

  004b0	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  004b3	c1 ea 04	 shr	 edx, 4
  004b6	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  004b9	8b 45 ec	 mov	 eax, DWORD PTR _bits$[ebp]
  004bc	83 e8 04	 sub	 eax, 4
  004bf	89 45 ec	 mov	 DWORD PTR _bits$[ebp], eax
  004c2	33 c9		 xor	 ecx, ecx
  004c4	75 ea		 jne	 SHORT $LN255@inflateBac@3

; 358  : #ifndef PKZIP_BUG_WORKAROUND
; 359  :             if (state->nlen > 286 || state->ndist > 30) {

  004c6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004c9	81 7a 60 1e 01
	00 00		 cmp	 DWORD PTR [edx+96], 286	; 0000011eH
  004d0	77 09		 ja	 SHORT $LN251@inflateBac@3
  004d2	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004d5	83 78 64 1e	 cmp	 DWORD PTR [eax+100], 30	; 0000001eH
  004d9	76 18		 jbe	 SHORT $LN252@inflateBac@3
$LN251@inflateBac@3:

; 360  :                 strm->msg = (char *)"too many length or distance symbols";

  004db	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  004de	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 361  :                 state->mode = BAD;

  004e5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  004e8	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 362  :                 break;

  004ee	e9 94 0e 00 00	 jmp	 $LN341@inflateBac@3
$LN252@inflateBac@3:

; 363  :             }
; 364  : #endif
; 365  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 366  : 
; 367  :             /* get code length code lengths (not a typo) */
; 368  :             state->have = 0;

  004f3	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  004f6	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0
$LN250@inflateBac@3:

; 369  :             while (state->have < state->ncode) {

  004fd	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00500	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00503	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00506	3b 42 5c	 cmp	 eax, DWORD PTR [edx+92]
  00509	0f 83 b6 00 00
	00		 jae	 $LN232@inflateBac@3
$LN245@inflateBac@3:

; 370  :                 NEEDBITS(3);

  0050f	83 7d ec 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00513	73 66		 jae	 SHORT $LN247@inflateBac@3
$LN240@inflateBac@3:
  00515	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00519	75 2a		 jne	 SHORT $LN239@inflateBac@3
  0051b	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  0051e	51		 push	 ecx
  0051f	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00522	52		 push	 edx
  00523	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00526	83 c4 08	 add	 esp, 8
  00529	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0052c	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00530	75 13		 jne	 SHORT $LN239@inflateBac@3
  00532	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00539	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00540	e9 47 0e 00 00	 jmp	 $inf_leave$77603
$LN239@inflateBac@3:
  00545	33 c0		 xor	 eax, eax
  00547	75 cc		 jne	 SHORT $LN240@inflateBac@3
  00549	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  0054c	83 e9 01	 sub	 ecx, 1
  0054f	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00552	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  00555	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00558	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0055b	d3 e0		 shl	 eax, cl
  0055d	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  00560	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00563	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00566	83 c1 01	 add	 ecx, 1
  00569	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  0056c	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  0056f	83 c2 08	 add	 edx, 8
  00572	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00575	33 c0		 xor	 eax, eax
  00577	75 9c		 jne	 SHORT $LN240@inflateBac@3
  00579	eb 94		 jmp	 SHORT $LN245@inflateBac@3
$LN247@inflateBac@3:
  0057b	33 c9		 xor	 ecx, ecx
  0057d	75 90		 jne	 SHORT $LN245@inflateBac@3

; 371  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  0057f	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00582	83 e2 07	 and	 edx, 7
  00585	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00588	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  0058b	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  00593	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00596	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  0059b	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0059e	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  005a1	83 c0 01	 add	 eax, 1
  005a4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005a7	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$LN235@inflateBac@3:

; 372  :                 DROPBITS(3);

  005aa	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  005ad	c1 ea 03	 shr	 edx, 3
  005b0	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  005b3	8b 45 ec	 mov	 eax, DWORD PTR _bits$[ebp]
  005b6	83 e8 03	 sub	 eax, 3
  005b9	89 45 ec	 mov	 DWORD PTR _bits$[ebp], eax
  005bc	33 c9		 xor	 ecx, ecx
  005be	75 ea		 jne	 SHORT $LN235@inflateBac@3

; 373  :             }

  005c0	e9 38 ff ff ff	 jmp	 $LN250@inflateBac@3
$LN232@inflateBac@3:

; 374  :             while (state->have < 19)

  005c5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005c8	83 7a 68 13	 cmp	 DWORD PTR [edx+104], 19	; 00000013H
  005cc	73 29		 jae	 SHORT $LN231@inflateBac@3

; 375  :                 state->lens[order[state->have++]] = 0;

  005ce	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  005d1	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  005d4	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflateBack@@9@9[ecx*2]
  005dc	33 c0		 xor	 eax, eax
  005de	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005e1	66 89 44 51 70	 mov	 WORD PTR [ecx+edx*2+112], ax
  005e6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005e9	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  005ec	83 c0 01	 add	 eax, 1
  005ef	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  005f2	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  005f5	eb ce		 jmp	 SHORT $LN232@inflateBac@3
$LN231@inflateBac@3:

; 376  :             state->next = state->codes;

  005f7	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  005fa	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00600	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00603	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 377  :             state->lencode = (code const FAR *)(state->next);

  00606	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00609	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0060c	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  0060f	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 378  :             state->lenbits = 7;

  00612	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00615	c7 41 54 07 00
	00 00		 mov	 DWORD PTR [ecx+84], 7

; 379  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 380  :                                 &(state->lenbits), state->work);

  0061c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0061f	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00625	52		 push	 edx
  00626	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00629	83 c0 54	 add	 eax, 84			; 00000054H
  0062c	50		 push	 eax
  0062d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00630	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00633	51		 push	 ecx
  00634	6a 13		 push	 19			; 00000013H
  00636	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00639	83 c2 70	 add	 edx, 112		; 00000070H
  0063c	52		 push	 edx
  0063d	6a 00		 push	 0
  0063f	e8 00 00 00 00	 call	 _inflate_table
  00644	83 c4 18	 add	 esp, 24			; 00000018H
  00647	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 381  :             if (ret) {

  0064a	83 7d e0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0064e	74 18		 je	 SHORT $LN230@inflateBac@3

; 382  :                 strm->msg = (char *)"invalid code lengths set";

  00650	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00653	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 383  :                 state->mode = BAD;

  0065a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0065d	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH

; 384  :                 break;

  00663	e9 1f 0d 00 00	 jmp	 $LN341@inflateBac@3
$LN230@inflateBac@3:

; 385  :             }
; 386  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 387  : 
; 388  :             /* get length and distance code code lengths */
; 389  :             state->have = 0;

  00668	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0066b	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0
$LN229@inflateBac@3:

; 390  :             while (state->have < state->nlen + state->ndist) {

  00672	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00675	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00678	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0067b	03 4a 64	 add	 ecx, DWORD PTR [edx+100]
  0067e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00681	39 48 68	 cmp	 DWORD PTR [eax+104], ecx
  00684	0f 83 3b 04 00
	00		 jae	 $LN228@inflateBac@3
$LN227@inflateBac@3:

; 391  :                 for (;;) {
; 392  :                     this = state->lencode[BITS(state->lenbits)];

  0068a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0068d	ba 01 00 00 00	 mov	 edx, 1
  00692	8b 49 54	 mov	 ecx, DWORD PTR [ecx+84]
  00695	d3 e2		 shl	 edx, cl
  00697	83 ea 01	 sub	 edx, 1
  0069a	23 55 dc	 and	 edx, DWORD PTR _hold$[ebp]
  0069d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  006a0	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  006a3	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  006a6	89 55 d8	 mov	 DWORD PTR _this$[ebp], edx

; 393  :                     if ((unsigned)(this.bits) <= bits) break;

  006a9	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  006ad	3b 45 ec	 cmp	 eax, DWORD PTR _bits$[ebp]
  006b0	77 02		 ja	 SHORT $LN221@inflateBac@3
  006b2	eb 69		 jmp	 SHORT $LN226@inflateBac@3
$LN221@inflateBac@3:

; 394  :                     PULLBYTE();

  006b4	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  006b8	75 2a		 jne	 SHORT $LN220@inflateBac@3
  006ba	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  006bd	51		 push	 ecx
  006be	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  006c1	52		 push	 edx
  006c2	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  006c5	83 c4 08	 add	 esp, 8
  006c8	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  006cb	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  006cf	75 13		 jne	 SHORT $LN220@inflateBac@3
  006d1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  006d8	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  006df	e9 a8 0c 00 00	 jmp	 $inf_leave$77603
$LN220@inflateBac@3:
  006e4	33 c0		 xor	 eax, eax
  006e6	75 cc		 jne	 SHORT $LN221@inflateBac@3
  006e8	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  006eb	83 e9 01	 sub	 ecx, 1
  006ee	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  006f1	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  006f4	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  006f7	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  006fa	d3 e0		 shl	 eax, cl
  006fc	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  006ff	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00702	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00705	83 c1 01	 add	 ecx, 1
  00708	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  0070b	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  0070e	83 c2 08	 add	 edx, 8
  00711	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00714	33 c0		 xor	 eax, eax
  00716	75 9c		 jne	 SHORT $LN221@inflateBac@3

; 395  :                 }

  00718	e9 6d ff ff ff	 jmp	 $LN227@inflateBac@3
$LN226@inflateBac@3:

; 396  :                 if (this.val < 16) {

  0071d	0f b7 4d da	 movzx	 ecx, WORD PTR _this$[ebp+2]
  00721	83 f9 10	 cmp	 ecx, 16			; 00000010H
  00724	0f 8d b5 00 00
	00		 jge	 $LN216@inflateBac@3
$LN212@inflateBac@3:

; 397  :                     NEEDBITS(this.bits);

  0072a	0f b6 55 d9	 movzx	 edx, BYTE PTR _this$[ebp+1]
  0072e	39 55 ec	 cmp	 DWORD PTR _bits$[ebp], edx
  00731	73 66		 jae	 SHORT $LN214@inflateBac@3
$LN207@inflateBac@3:
  00733	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00737	75 2a		 jne	 SHORT $LN206@inflateBac@3
  00739	8d 45 e4	 lea	 eax, DWORD PTR _next$[ebp]
  0073c	50		 push	 eax
  0073d	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00740	51		 push	 ecx
  00741	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00744	83 c4 08	 add	 esp, 8
  00747	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0074a	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0074e	75 13		 jne	 SHORT $LN206@inflateBac@3
  00750	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00757	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0075e	e9 29 0c 00 00	 jmp	 $inf_leave$77603
$LN206@inflateBac@3:
  00763	33 d2		 xor	 edx, edx
  00765	75 cc		 jne	 SHORT $LN207@inflateBac@3
  00767	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  0076a	83 e8 01	 sub	 eax, 1
  0076d	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00770	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00773	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00776	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00779	d3 e2		 shl	 edx, cl
  0077b	03 55 dc	 add	 edx, DWORD PTR _hold$[ebp]
  0077e	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00781	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  00784	83 c0 01	 add	 eax, 1
  00787	89 45 e4	 mov	 DWORD PTR _next$[ebp], eax
  0078a	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0078d	83 c1 08	 add	 ecx, 8
  00790	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00793	33 d2		 xor	 edx, edx
  00795	75 9c		 jne	 SHORT $LN207@inflateBac@3
  00797	eb 91		 jmp	 SHORT $LN212@inflateBac@3
$LN214@inflateBac@3:
  00799	33 c0		 xor	 eax, eax
  0079b	75 8d		 jne	 SHORT $LN212@inflateBac@3
$LN202@inflateBac@3:

; 398  :                     DROPBITS(this.bits);

  0079d	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  007a1	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  007a4	d3 ea		 shr	 edx, cl
  007a6	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  007a9	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  007ad	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  007b0	2b c8		 sub	 ecx, eax
  007b2	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  007b5	33 d2		 xor	 edx, edx
  007b7	75 e4		 jne	 SHORT $LN202@inflateBac@3

; 399  :                     state->lens[state->have++] = this.val;

  007b9	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  007bc	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  007bf	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  007c2	66 8b 45 da	 mov	 ax, WORD PTR _this$[ebp+2]
  007c6	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  007cb	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  007ce	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  007d1	83 c2 01	 add	 edx, 1
  007d4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  007d7	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 400  :                 }
; 401  :                 else {

  007da	e9 e1 02 00 00	 jmp	 $LN199@inflateBac@3
$LN216@inflateBac@3:

; 402  :                     if (this.val == 16) {

  007df	0f b7 4d da	 movzx	 ecx, WORD PTR _this$[ebp+2]
  007e3	83 f9 10	 cmp	 ecx, 16			; 00000010H
  007e6	0f 85 eb 00 00
	00		 jne	 $LN198@inflateBac@3
$LN194@inflateBac@3:

; 403  :                         NEEDBITS(this.bits + 2);

  007ec	0f b6 55 d9	 movzx	 edx, BYTE PTR _this$[ebp+1]
  007f0	83 c2 02	 add	 edx, 2
  007f3	39 55 ec	 cmp	 DWORD PTR _bits$[ebp], edx
  007f6	73 66		 jae	 SHORT $LN196@inflateBac@3
$LN189@inflateBac@3:
  007f8	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  007fc	75 2a		 jne	 SHORT $LN188@inflateBac@3
  007fe	8d 45 e4	 lea	 eax, DWORD PTR _next$[ebp]
  00801	50		 push	 eax
  00802	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00805	51		 push	 ecx
  00806	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00809	83 c4 08	 add	 esp, 8
  0080c	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0080f	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00813	75 13		 jne	 SHORT $LN188@inflateBac@3
  00815	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  0081c	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00823	e9 64 0b 00 00	 jmp	 $inf_leave$77603
$LN188@inflateBac@3:
  00828	33 d2		 xor	 edx, edx
  0082a	75 cc		 jne	 SHORT $LN189@inflateBac@3
  0082c	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  0082f	83 e8 01	 sub	 eax, 1
  00832	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00835	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00838	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0083b	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0083e	d3 e2		 shl	 edx, cl
  00840	03 55 dc	 add	 edx, DWORD PTR _hold$[ebp]
  00843	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00846	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  00849	83 c0 01	 add	 eax, 1
  0084c	89 45 e4	 mov	 DWORD PTR _next$[ebp], eax
  0084f	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00852	83 c1 08	 add	 ecx, 8
  00855	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00858	33 d2		 xor	 edx, edx
  0085a	75 9c		 jne	 SHORT $LN189@inflateBac@3
  0085c	eb 8e		 jmp	 SHORT $LN194@inflateBac@3
$LN196@inflateBac@3:
  0085e	33 c0		 xor	 eax, eax
  00860	75 8a		 jne	 SHORT $LN194@inflateBac@3
$LN184@inflateBac@3:

; 404  :                         DROPBITS(this.bits);

  00862	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  00866	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00869	d3 ea		 shr	 edx, cl
  0086b	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  0086e	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  00872	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00875	2b c8		 sub	 ecx, eax
  00877	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  0087a	33 d2		 xor	 edx, edx
  0087c	75 e4		 jne	 SHORT $LN184@inflateBac@3

; 405  :                         if (state->have == 0) {

  0087e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00881	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  00885	75 18		 jne	 SHORT $LN181@inflateBac@3

; 406  :                             strm->msg = (char *)"invalid bit length repeat";

  00887	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0088a	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 407  :                             state->mode = BAD;

  00891	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00894	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 408  :                             break;

  0089a	e9 26 02 00 00	 jmp	 $LN228@inflateBac@3
$LN181@inflateBac@3:

; 409  :                         }
; 410  :                         len = (unsigned)(state->lens[state->have - 1]);

  0089f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  008a2	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  008a5	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  008a8	0f b7 44 4a 6e	 movzx	 eax, WORD PTR [edx+ecx*2+110]
  008ad	89 45 f0	 mov	 DWORD PTR _len$[ebp], eax

; 411  :                         copy = 3 + BITS(2);

  008b0	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  008b3	83 e1 03	 and	 ecx, 3
  008b6	83 c1 03	 add	 ecx, 3
  008b9	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN180@inflateBac@3:

; 412  :                         DROPBITS(2);

  008bc	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  008bf	c1 ea 02	 shr	 edx, 2
  008c2	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  008c5	8b 45 ec	 mov	 eax, DWORD PTR _bits$[ebp]
  008c8	83 e8 02	 sub	 eax, 2
  008cb	89 45 ec	 mov	 DWORD PTR _bits$[ebp], eax
  008ce	33 c9		 xor	 ecx, ecx
  008d0	75 ea		 jne	 SHORT $LN180@inflateBac@3

; 413  :                     }
; 414  :                     else if (this.val == 17) {

  008d2	e9 88 01 00 00	 jmp	 $LN177@inflateBac@3
$LN198@inflateBac@3:
  008d7	0f b7 55 da	 movzx	 edx, WORD PTR _this$[ebp+2]
  008db	83 fa 11	 cmp	 edx, 17			; 00000011H
  008de	0f 85 c0 00 00
	00		 jne	 $LN152@inflateBac@3
$LN172@inflateBac@3:

; 415  :                         NEEDBITS(this.bits + 3);

  008e4	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  008e8	83 c0 03	 add	 eax, 3
  008eb	39 45 ec	 cmp	 DWORD PTR _bits$[ebp], eax
  008ee	73 66		 jae	 SHORT $LN174@inflateBac@3
$LN167@inflateBac@3:
  008f0	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  008f4	75 2a		 jne	 SHORT $LN166@inflateBac@3
  008f6	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  008f9	51		 push	 ecx
  008fa	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  008fd	52		 push	 edx
  008fe	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00901	83 c4 08	 add	 esp, 8
  00904	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00907	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0090b	75 13		 jne	 SHORT $LN166@inflateBac@3
  0090d	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00914	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  0091b	e9 6c 0a 00 00	 jmp	 $inf_leave$77603
$LN166@inflateBac@3:
  00920	33 c0		 xor	 eax, eax
  00922	75 cc		 jne	 SHORT $LN167@inflateBac@3
  00924	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00927	83 e9 01	 sub	 ecx, 1
  0092a	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  0092d	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  00930	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00933	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00936	d3 e0		 shl	 eax, cl
  00938	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  0093b	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  0093e	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00941	83 c1 01	 add	 ecx, 1
  00944	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  00947	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  0094a	83 c2 08	 add	 edx, 8
  0094d	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00950	33 c0		 xor	 eax, eax
  00952	75 9c		 jne	 SHORT $LN167@inflateBac@3
  00954	eb 8e		 jmp	 SHORT $LN172@inflateBac@3
$LN174@inflateBac@3:
  00956	33 c9		 xor	 ecx, ecx
  00958	75 8a		 jne	 SHORT $LN172@inflateBac@3
$LN162@inflateBac@3:

; 416  :                         DROPBITS(this.bits);

  0095a	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  0095e	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00961	d3 ea		 shr	 edx, cl
  00963	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00966	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  0096a	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0096d	2b c8		 sub	 ecx, eax
  0096f	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00972	33 d2		 xor	 edx, edx
  00974	75 e4		 jne	 SHORT $LN162@inflateBac@3

; 417  :                         len = 0;

  00976	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 418  :                         copy = 3 + BITS(3);

  0097d	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  00980	83 e0 07	 and	 eax, 7
  00983	83 c0 03	 add	 eax, 3
  00986	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN159@inflateBac@3:

; 419  :                         DROPBITS(3);

  00989	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  0098c	c1 e9 03	 shr	 ecx, 3
  0098f	89 4d dc	 mov	 DWORD PTR _hold$[ebp], ecx
  00992	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00995	83 ea 03	 sub	 edx, 3
  00998	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  0099b	33 c0		 xor	 eax, eax
  0099d	75 ea		 jne	 SHORT $LN159@inflateBac@3

; 420  :                     }
; 421  :                     else {

  0099f	e9 bb 00 00 00	 jmp	 $LN177@inflateBac@3
$LN152@inflateBac@3:

; 422  :                         NEEDBITS(this.bits + 7);

  009a4	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  009a8	83 c1 07	 add	 ecx, 7
  009ab	39 4d ec	 cmp	 DWORD PTR _bits$[ebp], ecx
  009ae	73 66		 jae	 SHORT $LN154@inflateBac@3
$LN147@inflateBac@3:
  009b0	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  009b4	75 2a		 jne	 SHORT $LN146@inflateBac@3
  009b6	8d 55 e4	 lea	 edx, DWORD PTR _next$[ebp]
  009b9	52		 push	 edx
  009ba	8b 45 10	 mov	 eax, DWORD PTR _in_desc$[ebp]
  009bd	50		 push	 eax
  009be	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  009c1	83 c4 08	 add	 esp, 8
  009c4	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  009c7	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  009cb	75 13		 jne	 SHORT $LN146@inflateBac@3
  009cd	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  009d4	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  009db	e9 ac 09 00 00	 jmp	 $inf_leave$77603
$LN146@inflateBac@3:
  009e0	33 c9		 xor	 ecx, ecx
  009e2	75 cc		 jne	 SHORT $LN147@inflateBac@3
  009e4	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  009e7	83 ea 01	 sub	 edx, 1
  009ea	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  009ed	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  009f0	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  009f3	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  009f6	d3 e2		 shl	 edx, cl
  009f8	03 55 dc	 add	 edx, DWORD PTR _hold$[ebp]
  009fb	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  009fe	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  00a01	83 c0 01	 add	 eax, 1
  00a04	89 45 e4	 mov	 DWORD PTR _next$[ebp], eax
  00a07	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a0a	83 c1 08	 add	 ecx, 8
  00a0d	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00a10	33 d2		 xor	 edx, edx
  00a12	75 9c		 jne	 SHORT $LN147@inflateBac@3
  00a14	eb 8e		 jmp	 SHORT $LN152@inflateBac@3
$LN154@inflateBac@3:
  00a16	33 c0		 xor	 eax, eax
  00a18	75 8a		 jne	 SHORT $LN152@inflateBac@3
$LN142@inflateBac@3:

; 423  :                         DROPBITS(this.bits);

  00a1a	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  00a1e	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00a21	d3 ea		 shr	 edx, cl
  00a23	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00a26	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  00a2a	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a2d	2b c8		 sub	 ecx, eax
  00a2f	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00a32	33 d2		 xor	 edx, edx
  00a34	75 e4		 jne	 SHORT $LN142@inflateBac@3

; 424  :                         len = 0;

  00a36	c7 45 f0 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 425  :                         copy = 11 + BITS(7);

  00a3d	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  00a40	83 e0 7f	 and	 eax, 127		; 0000007fH
  00a43	83 c0 0b	 add	 eax, 11			; 0000000bH
  00a46	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN139@inflateBac@3:

; 426  :                         DROPBITS(7);

  00a49	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  00a4c	c1 e9 07	 shr	 ecx, 7
  00a4f	89 4d dc	 mov	 DWORD PTR _hold$[ebp], ecx
  00a52	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00a55	83 ea 07	 sub	 edx, 7
  00a58	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00a5b	33 c0		 xor	 eax, eax
  00a5d	75 ea		 jne	 SHORT $LN139@inflateBac@3
$LN177@inflateBac@3:

; 427  :                     }
; 428  :                     if (state->have + copy > state->nlen + state->ndist) {

  00a5f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00a62	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  00a65	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  00a68	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a6b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00a6e	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00a71	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  00a74	3b d1		 cmp	 edx, ecx
  00a76	76 15		 jbe	 SHORT $LN135@inflateBac@3

; 429  :                         strm->msg = (char *)"invalid bit length repeat";

  00a78	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a7b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 430  :                         state->mode = BAD;

  00a82	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00a85	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 431  :                         break;

  00a8b	eb 38		 jmp	 SHORT $LN228@inflateBac@3
$LN135@inflateBac@3:

; 432  :                     }
; 433  :                     while (copy--)

  00a8d	8b 45 d4	 mov	 eax, DWORD PTR _copy$[ebp]
  00a90	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00a93	83 e9 01	 sub	 ecx, 1
  00a96	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
  00a99	85 c0		 test	 eax, eax
  00a9b	74 23		 je	 SHORT $LN199@inflateBac@3

; 434  :                         state->lens[state->have++] = (unsigned short)len;

  00a9d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00aa0	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00aa3	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00aa6	66 8b 55 f0	 mov	 dx, WORD PTR _len$[ebp]
  00aaa	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00aaf	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ab2	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00ab5	83 c1 01	 add	 ecx, 1
  00ab8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00abb	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  00abe	eb cd		 jmp	 SHORT $LN135@inflateBac@3
$LN199@inflateBac@3:

; 435  :                 }
; 436  :             }

  00ac0	e9 ad fb ff ff	 jmp	 $LN229@inflateBac@3
$LN228@inflateBac@3:

; 437  : 
; 438  :             /* handle error breaks in while */
; 439  :             if (state->mode == BAD) break;

  00ac5	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ac8	83 38 1b	 cmp	 DWORD PTR [eax], 27	; 0000001bH
  00acb	75 05		 jne	 SHORT $LN133@inflateBac@3
  00acd	e9 b5 08 00 00	 jmp	 $LN341@inflateBac@3
$LN133@inflateBac@3:

; 440  : 
; 441  :             /* build code tables */
; 442  :             state->next = state->codes;

  00ad2	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ad5	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  00adb	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00ade	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx

; 443  :             state->lencode = (code const FAR *)(state->next);

  00ae1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ae4	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00ae7	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00aea	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 444  :             state->lenbits = 9;

  00aed	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00af0	c7 40 54 09 00
	00 00		 mov	 DWORD PTR [eax+84], 9

; 445  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 446  :                                 &(state->lenbits), state->work);

  00af7	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00afa	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  00b00	51		 push	 ecx
  00b01	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b04	83 c2 54	 add	 edx, 84			; 00000054H
  00b07	52		 push	 edx
  00b08	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b0b	83 c0 6c	 add	 eax, 108		; 0000006cH
  00b0e	50		 push	 eax
  00b0f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b12	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00b15	52		 push	 edx
  00b16	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b19	83 c0 70	 add	 eax, 112		; 00000070H
  00b1c	50		 push	 eax
  00b1d	6a 01		 push	 1
  00b1f	e8 00 00 00 00	 call	 _inflate_table
  00b24	83 c4 18	 add	 esp, 24			; 00000018H
  00b27	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 447  :             if (ret) {

  00b2a	83 7d e0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00b2e	74 18		 je	 SHORT $LN132@inflateBac@3

; 448  :                 strm->msg = (char *)"invalid literal/lengths set";

  00b30	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00b33	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 449  :                 state->mode = BAD;

  00b3a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b3d	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 450  :                 break;

  00b43	e9 3f 08 00 00	 jmp	 $LN341@inflateBac@3
$LN132@inflateBac@3:

; 451  :             }
; 452  :             state->distcode = (code const FAR *)(state->next);

  00b48	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b4b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b4e	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  00b51	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 453  :             state->distbits = 6;

  00b54	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b57	c7 40 58 06 00
	00 00		 mov	 DWORD PTR [eax+88], 6

; 454  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 455  :                             &(state->next), &(state->distbits), state->work);

  00b5e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b61	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  00b67	51		 push	 ecx
  00b68	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b6b	83 c2 58	 add	 edx, 88			; 00000058H
  00b6e	52		 push	 edx
  00b6f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b72	83 c0 6c	 add	 eax, 108		; 0000006cH
  00b75	50		 push	 eax
  00b76	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00b79	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  00b7c	52		 push	 edx
  00b7d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00b80	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  00b83	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00b86	8d 44 4a 70	 lea	 eax, DWORD PTR [edx+ecx*2+112]
  00b8a	50		 push	 eax
  00b8b	6a 02		 push	 2
  00b8d	e8 00 00 00 00	 call	 _inflate_table
  00b92	83 c4 18	 add	 esp, 24			; 00000018H
  00b95	89 45 e0	 mov	 DWORD PTR _ret$[ebp], eax

; 456  :             if (ret) {

  00b98	83 7d e0 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00b9c	74 18		 je	 SHORT $LN131@inflateBac@3

; 457  :                 strm->msg = (char *)"invalid distances set";

  00b9e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00ba1	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 458  :                 state->mode = BAD;

  00ba8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00bab	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 459  :                 break;

  00bb1	e9 d1 07 00 00	 jmp	 $LN341@inflateBac@3
$LN131@inflateBac@3:

; 460  :             }
; 461  :             Tracev((stderr, "inflate:       codes ok\n"));
; 462  :             state->mode = LEN;

  00bb6	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bb9	c7 00 12 00 00
	00		 mov	 DWORD PTR [eax], 18	; 00000012H
$LN130@inflateBac@3:

; 463  : 
; 464  :         case LEN:
; 465  :             /* use inflate_fast() if we have enough input and output */
; 466  :             if (have >= 6 && left >= 258) {

  00bbf	83 7d f4 06	 cmp	 DWORD PTR _have$[ebp], 6
  00bc3	0f 82 b4 00 00
	00		 jb	 $LN121@inflateBac@3
  00bc9	81 7d e8 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  00bd0	0f 82 a7 00 00
	00		 jb	 $LN121@inflateBac@3
$LN128@inflateBac@3:

; 467  :                 RESTORE();

  00bd6	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00bd9	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00bdc	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00bdf	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00be2	8b 4d e8	 mov	 ecx, DWORD PTR _left$[ebp]
  00be5	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00be8	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00beb	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  00bee	89 02		 mov	 DWORD PTR [edx], eax
  00bf0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00bf3	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  00bf6	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00bf9	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00bfc	8b 4d dc	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bff	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00c02	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c05	8b 45 ec	 mov	 eax, DWORD PTR _bits$[ebp]
  00c08	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  00c0b	33 c9		 xor	 ecx, ecx
  00c0d	75 c7		 jne	 SHORT $LN128@inflateBac@3

; 468  :                 if (state->whave < state->wsize)

  00c0f	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c12	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c15	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00c18	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  00c1b	73 0f		 jae	 SHORT $LN125@inflateBac@3

; 469  :                     state->whave = state->wsize - left;

  00c1d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c20	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00c23	2b 45 e8	 sub	 eax, DWORD PTR _left$[ebp]
  00c26	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c29	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN125@inflateBac@3:

; 470  :                 inflate_fast(strm, state->wsize);

  00c2c	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00c2f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00c32	50		 push	 eax
  00c33	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c36	51		 push	 ecx
  00c37	e8 00 00 00 00	 call	 _inflate_fast
  00c3c	83 c4 08	 add	 esp, 8
$LN124@inflateBac@3:

; 471  :                 LOAD();

  00c3f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c42	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00c45	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  00c48	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c4b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00c4e	89 55 e8	 mov	 DWORD PTR _left$[ebp], edx
  00c51	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00c54	8b 08		 mov	 ecx, DWORD PTR [eax]
  00c56	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  00c59	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00c5c	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00c5f	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00c62	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00c65	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  00c68	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00c6b	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c6e	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00c71	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00c74	33 d2		 xor	 edx, edx
  00c76	75 c7		 jne	 SHORT $LN124@inflateBac@3

; 472  :                 break;

  00c78	e9 0a 07 00 00	 jmp	 $LN341@inflateBac@3
$LN121@inflateBac@3:

; 473  :             }
; 474  : 
; 475  :             /* get a literal, length, or end-of-block code */
; 476  :             for (;;) {
; 477  :                 this = state->lencode[BITS(state->lenbits)];

  00c7d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c80	ba 01 00 00 00	 mov	 edx, 1
  00c85	8b 48 54	 mov	 ecx, DWORD PTR [eax+84]
  00c88	d3 e2		 shl	 edx, cl
  00c8a	83 ea 01	 sub	 edx, 1
  00c8d	23 55 dc	 and	 edx, DWORD PTR _hold$[ebp]
  00c90	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00c93	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  00c96	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00c99	89 55 d8	 mov	 DWORD PTR _this$[ebp], edx

; 478  :                 if ((unsigned)(this.bits) <= bits) break;

  00c9c	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  00ca0	3b 45 ec	 cmp	 eax, DWORD PTR _bits$[ebp]
  00ca3	77 02		 ja	 SHORT $LN115@inflateBac@3
  00ca5	eb 69		 jmp	 SHORT $LN120@inflateBac@3
$LN115@inflateBac@3:

; 479  :                 PULLBYTE();

  00ca7	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00cab	75 2a		 jne	 SHORT $LN114@inflateBac@3
  00cad	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  00cb0	51		 push	 ecx
  00cb1	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00cb4	52		 push	 edx
  00cb5	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00cb8	83 c4 08	 add	 esp, 8
  00cbb	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00cbe	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00cc2	75 13		 jne	 SHORT $LN114@inflateBac@3
  00cc4	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00ccb	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00cd2	e9 b5 06 00 00	 jmp	 $inf_leave$77603
$LN114@inflateBac@3:
  00cd7	33 c0		 xor	 eax, eax
  00cd9	75 cc		 jne	 SHORT $LN115@inflateBac@3
  00cdb	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00cde	83 e9 01	 sub	 ecx, 1
  00ce1	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00ce4	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  00ce7	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00cea	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ced	d3 e0		 shl	 eax, cl
  00cef	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  00cf2	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00cf5	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00cf8	83 c1 01	 add	 ecx, 1
  00cfb	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  00cfe	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00d01	83 c2 08	 add	 edx, 8
  00d04	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00d07	33 c0		 xor	 eax, eax
  00d09	75 9c		 jne	 SHORT $LN115@inflateBac@3

; 480  :             }

  00d0b	e9 6d ff ff ff	 jmp	 $LN121@inflateBac@3
$LN120@inflateBac@3:

; 481  :             if (this.op && (this.op & 0xf0) == 0) {

  00d10	0f b6 4d d8	 movzx	 ecx, BYTE PTR _this$[ebp]
  00d14	85 c9		 test	 ecx, ecx
  00d16	0f 84 db 00 00
	00		 je	 $LN95@inflateBac@3
  00d1c	0f b6 55 d8	 movzx	 edx, BYTE PTR _this$[ebp]
  00d20	81 e2 f0 00 00
	00		 and	 edx, 240		; 000000f0H
  00d26	0f 85 cb 00 00
	00		 jne	 $LN95@inflateBac@3

; 482  :                 last = this;

  00d2c	8b 45 d8	 mov	 eax, DWORD PTR _this$[ebp]
  00d2f	89 45 f8	 mov	 DWORD PTR _last$[ebp], eax
$LN109@inflateBac@3:

; 483  :                 for (;;) {
; 484  :                     this = state->lencode[last.val +
; 485  :                             (BITS(last.bits + last.op) >> last.bits)];

  00d32	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  00d36	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d3a	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  00d3e	03 c8		 add	 ecx, eax
  00d40	b8 01 00 00 00	 mov	 eax, 1
  00d45	d3 e0		 shl	 eax, cl
  00d47	83 e8 01	 sub	 eax, 1
  00d4a	23 45 dc	 and	 eax, DWORD PTR _hold$[ebp]
  00d4d	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00d51	d3 e8		 shr	 eax, cl
  00d53	03 d0		 add	 edx, eax
  00d55	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00d58	8b 41 4c	 mov	 eax, DWORD PTR [ecx+76]
  00d5b	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  00d5e	89 4d d8	 mov	 DWORD PTR _this$[ebp], ecx

; 486  :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  00d61	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  00d65	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  00d69	03 d0		 add	 edx, eax
  00d6b	3b 55 ec	 cmp	 edx, DWORD PTR _bits$[ebp]
  00d6e	77 02		 ja	 SHORT $LN103@inflateBac@3
  00d70	eb 69		 jmp	 SHORT $LN98@inflateBac@3
$LN103@inflateBac@3:

; 487  :                     PULLBYTE();

  00d72	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d76	75 2a		 jne	 SHORT $LN102@inflateBac@3
  00d78	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  00d7b	51		 push	 ecx
  00d7c	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00d7f	52		 push	 edx
  00d80	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00d83	83 c4 08	 add	 esp, 8
  00d86	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00d89	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d8d	75 13		 jne	 SHORT $LN102@inflateBac@3
  00d8f	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00d96	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00d9d	e9 ea 05 00 00	 jmp	 $inf_leave$77603
$LN102@inflateBac@3:
  00da2	33 c0		 xor	 eax, eax
  00da4	75 cc		 jne	 SHORT $LN103@inflateBac@3
  00da6	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00da9	83 e9 01	 sub	 ecx, 1
  00dac	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00daf	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  00db2	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00db5	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00db8	d3 e0		 shl	 eax, cl
  00dba	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  00dbd	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00dc0	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00dc3	83 c1 01	 add	 ecx, 1
  00dc6	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  00dc9	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00dcc	83 c2 08	 add	 edx, 8
  00dcf	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00dd2	33 c0		 xor	 eax, eax
  00dd4	75 9c		 jne	 SHORT $LN103@inflateBac@3

; 488  :                 }

  00dd6	e9 57 ff ff ff	 jmp	 $LN109@inflateBac@3
$LN98@inflateBac@3:

; 489  :                 DROPBITS(last.bits);

  00ddb	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  00ddf	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  00de2	d3 ea		 shr	 edx, cl
  00de4	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00de7	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  00deb	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00dee	2b c8		 sub	 ecx, eax
  00df0	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00df3	33 d2		 xor	 edx, edx
  00df5	75 e4		 jne	 SHORT $LN98@inflateBac@3
$LN95@inflateBac@3:

; 490  :             }
; 491  :             DROPBITS(this.bits);

  00df7	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  00dfb	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  00dfe	d3 e8		 shr	 eax, cl
  00e00	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00e03	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  00e07	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00e0a	2b d1		 sub	 edx, ecx
  00e0c	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00e0f	33 c0		 xor	 eax, eax
  00e11	75 e4		 jne	 SHORT $LN95@inflateBac@3

; 492  :             state->length = (unsigned)this.val;

  00e13	0f b7 4d da	 movzx	 ecx, WORD PTR _this$[ebp+2]
  00e17	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00e1a	89 4a 40	 mov	 DWORD PTR [edx+64], ecx

; 493  : 
; 494  :             /* process literal */
; 495  :             if (this.op == 0) {

  00e1d	0f b6 45 d8	 movzx	 eax, BYTE PTR _this$[ebp]
  00e21	85 c0		 test	 eax, eax
  00e23	75 72		 jne	 SHORT $LN92@inflateBac@3
$LN91@inflateBac@3:

; 496  :                 Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
; 497  :                         "inflate:         literal '%c'\n" :
; 498  :                         "inflate:         literal 0x%02x\n", this.val));
; 499  :                 ROOM();

  00e25	83 7d e8 00	 cmp	 DWORD PTR _left$[ebp], 0
  00e29	75 3d		 jne	 SHORT $LN90@inflateBac@3
  00e2b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e2e	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  00e31	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx
  00e34	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e37	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00e3a	89 4d e8	 mov	 DWORD PTR _left$[ebp], ecx
  00e3d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00e40	8b 45 e8	 mov	 eax, DWORD PTR _left$[ebp]
  00e43	89 42 2c	 mov	 DWORD PTR [edx+44], eax
  00e46	8b 4d e8	 mov	 ecx, DWORD PTR _left$[ebp]
  00e49	51		 push	 ecx
  00e4a	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e4d	52		 push	 edx
  00e4e	8b 45 18	 mov	 eax, DWORD PTR _out_desc$[ebp]
  00e51	50		 push	 eax
  00e52	ff 55 14	 call	 DWORD PTR _out$[ebp]
  00e55	83 c4 0c	 add	 esp, 12			; 0000000cH
  00e58	85 c0		 test	 eax, eax
  00e5a	74 0c		 je	 SHORT $LN90@inflateBac@3
  00e5c	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00e63	e9 24 05 00 00	 jmp	 $inf_leave$77603
$LN90@inflateBac@3:
  00e68	33 c9		 xor	 ecx, ecx
  00e6a	75 b9		 jne	 SHORT $LN91@inflateBac@3

; 500  :                 *put++ = (unsigned char)(state->length);

  00e6c	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e6f	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00e72	8a 48 40	 mov	 cl, BYTE PTR [eax+64]
  00e75	88 0a		 mov	 BYTE PTR [edx], cl
  00e77	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00e7a	83 c2 01	 add	 edx, 1
  00e7d	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 501  :                 left--;

  00e80	8b 45 e8	 mov	 eax, DWORD PTR _left$[ebp]
  00e83	83 e8 01	 sub	 eax, 1
  00e86	89 45 e8	 mov	 DWORD PTR _left$[ebp], eax

; 502  :                 state->mode = LEN;

  00e89	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00e8c	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H

; 503  :                 break;

  00e92	e9 f0 04 00 00	 jmp	 $LN341@inflateBac@3
$LN92@inflateBac@3:

; 504  :             }
; 505  : 
; 506  :             /* process end of block */
; 507  :             if (this.op & 32) {

  00e97	0f b6 55 d8	 movzx	 edx, BYTE PTR _this$[ebp]
  00e9b	83 e2 20	 and	 edx, 32			; 00000020H
  00e9e	74 0e		 je	 SHORT $LN86@inflateBac@3

; 508  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 509  :                 state->mode = TYPE;

  00ea0	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ea3	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH

; 510  :                 break;

  00ea9	e9 d9 04 00 00	 jmp	 $LN341@inflateBac@3
$LN86@inflateBac@3:

; 511  :             }
; 512  : 
; 513  :             /* invalid code */
; 514  :             if (this.op & 64) {

  00eae	0f b6 4d d8	 movzx	 ecx, BYTE PTR _this$[ebp]
  00eb2	83 e1 40	 and	 ecx, 64			; 00000040H
  00eb5	74 18		 je	 SHORT $LN85@inflateBac@3

; 515  :                 strm->msg = (char *)"invalid literal/length code";

  00eb7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00eba	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 516  :                 state->mode = BAD;

  00ec1	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00ec4	c7 00 1b 00 00
	00		 mov	 DWORD PTR [eax], 27	; 0000001bH

; 517  :                 break;

  00eca	e9 b8 04 00 00	 jmp	 $LN341@inflateBac@3
$LN85@inflateBac@3:

; 518  :             }
; 519  : 
; 520  :             /* length code -- get extra bits, if any */
; 521  :             state->extra = (unsigned)(this.op) & 15;

  00ecf	0f b6 4d d8	 movzx	 ecx, BYTE PTR _this$[ebp]
  00ed3	83 e1 0f	 and	 ecx, 15			; 0000000fH
  00ed6	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00ed9	89 4a 48	 mov	 DWORD PTR [edx+72], ecx

; 522  :             if (state->extra != 0) {

  00edc	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00edf	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  00ee3	0f 84 b2 00 00
	00		 je	 $LN67@inflateBac@3
$LN80@inflateBac@3:

; 523  :                 NEEDBITS(state->extra);

  00ee9	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00eec	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00eef	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  00ef2	73 66		 jae	 SHORT $LN82@inflateBac@3
$LN75@inflateBac@3:
  00ef4	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ef8	75 2a		 jne	 SHORT $LN74@inflateBac@3
  00efa	8d 45 e4	 lea	 eax, DWORD PTR _next$[ebp]
  00efd	50		 push	 eax
  00efe	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  00f01	51		 push	 ecx
  00f02	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00f05	83 c4 08	 add	 esp, 8
  00f08	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00f0b	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00f0f	75 13		 jne	 SHORT $LN74@inflateBac@3
  00f11	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00f18	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00f1f	e9 68 04 00 00	 jmp	 $inf_leave$77603
$LN74@inflateBac@3:
  00f24	33 d2		 xor	 edx, edx
  00f26	75 cc		 jne	 SHORT $LN75@inflateBac@3
  00f28	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  00f2b	83 e8 01	 sub	 eax, 1
  00f2e	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00f31	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  00f34	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00f37	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f3a	d3 e2		 shl	 edx, cl
  00f3c	03 55 dc	 add	 edx, DWORD PTR _hold$[ebp]
  00f3f	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  00f42	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  00f45	83 c0 01	 add	 eax, 1
  00f48	89 45 e4	 mov	 DWORD PTR _next$[ebp], eax
  00f4b	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  00f4e	83 c1 08	 add	 ecx, 8
  00f51	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  00f54	33 d2		 xor	 edx, edx
  00f56	75 9c		 jne	 SHORT $LN75@inflateBac@3
  00f58	eb 8f		 jmp	 SHORT $LN80@inflateBac@3
$LN82@inflateBac@3:
  00f5a	33 c0		 xor	 eax, eax
  00f5c	75 8b		 jne	 SHORT $LN80@inflateBac@3

; 524  :                 state->length += BITS(state->extra);

  00f5e	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f61	ba 01 00 00 00	 mov	 edx, 1
  00f66	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  00f69	d3 e2		 shl	 edx, cl
  00f6b	83 ea 01	 sub	 edx, 1
  00f6e	23 55 dc	 and	 edx, DWORD PTR _hold$[ebp]
  00f71	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00f74	03 50 40	 add	 edx, DWORD PTR [eax+64]
  00f77	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f7a	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN70@inflateBac@3:

; 525  :                 DROPBITS(state->extra);

  00f7d	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  00f80	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  00f83	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  00f86	d3 e8		 shr	 eax, cl
  00f88	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  00f8b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f8e	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  00f91	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  00f94	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  00f97	33 c0		 xor	 eax, eax
  00f99	75 e2		 jne	 SHORT $LN70@inflateBac@3
$LN67@inflateBac@3:

; 526  :             }
; 527  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 528  : 
; 529  :             /* get distance code */
; 530  :             for (;;) {
; 531  :                 this = state->distcode[BITS(state->distbits)];

  00f9b	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  00f9e	ba 01 00 00 00	 mov	 edx, 1
  00fa3	8b 49 58	 mov	 ecx, DWORD PTR [ecx+88]
  00fa6	d3 e2		 shl	 edx, cl
  00fa8	83 ea 01	 sub	 edx, 1
  00fab	23 55 dc	 and	 edx, DWORD PTR _hold$[ebp]
  00fae	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  00fb1	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00fb4	8b 14 91	 mov	 edx, DWORD PTR [ecx+edx*4]
  00fb7	89 55 d8	 mov	 DWORD PTR _this$[ebp], edx

; 532  :                 if ((unsigned)(this.bits) <= bits) break;

  00fba	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  00fbe	3b 45 ec	 cmp	 eax, DWORD PTR _bits$[ebp]
  00fc1	77 02		 ja	 SHORT $LN61@inflateBac@3
  00fc3	eb 69		 jmp	 SHORT $LN66@inflateBac@3
$LN61@inflateBac@3:

; 533  :                 PULLBYTE();

  00fc5	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00fc9	75 2a		 jne	 SHORT $LN60@inflateBac@3
  00fcb	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  00fce	51		 push	 ecx
  00fcf	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  00fd2	52		 push	 edx
  00fd3	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  00fd6	83 c4 08	 add	 esp, 8
  00fd9	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00fdc	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00fe0	75 13		 jne	 SHORT $LN60@inflateBac@3
  00fe2	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  00fe9	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  00ff0	e9 97 03 00 00	 jmp	 $inf_leave$77603
$LN60@inflateBac@3:
  00ff5	33 c0		 xor	 eax, eax
  00ff7	75 cc		 jne	 SHORT $LN61@inflateBac@3
  00ff9	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00ffc	83 e9 01	 sub	 ecx, 1
  00fff	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  01002	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  01005	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01008	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0100b	d3 e0		 shl	 eax, cl
  0100d	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  01010	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  01013	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  01016	83 c1 01	 add	 ecx, 1
  01019	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  0101c	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  0101f	83 c2 08	 add	 edx, 8
  01022	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  01025	33 c0		 xor	 eax, eax
  01027	75 9c		 jne	 SHORT $LN61@inflateBac@3

; 534  :             }

  01029	e9 6d ff ff ff	 jmp	 $LN67@inflateBac@3
$LN66@inflateBac@3:

; 535  :             if ((this.op & 0xf0) == 0) {

  0102e	0f b6 4d d8	 movzx	 ecx, BYTE PTR _this$[ebp]
  01032	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  01038	0f 85 cb 00 00
	00		 jne	 $LN41@inflateBac@3

; 536  :                 last = this;

  0103e	8b 55 d8	 mov	 edx, DWORD PTR _this$[ebp]
  01041	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN55@inflateBac@3:

; 537  :                 for (;;) {
; 538  :                     this = state->distcode[last.val +
; 539  :                             (BITS(last.bits + last.op) >> last.bits)];

  01044	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  01048	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0104c	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  01050	03 ca		 add	 ecx, edx
  01052	ba 01 00 00 00	 mov	 edx, 1
  01057	d3 e2		 shl	 edx, cl
  01059	83 ea 01	 sub	 edx, 1
  0105c	23 55 dc	 and	 edx, DWORD PTR _hold$[ebp]
  0105f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01063	d3 ea		 shr	 edx, cl
  01065	03 c2		 add	 eax, edx
  01067	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0106a	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  0106d	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01070	89 45 d8	 mov	 DWORD PTR _this$[ebp], eax

; 540  :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  01073	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01077	0f b6 55 d9	 movzx	 edx, BYTE PTR _this$[ebp+1]
  0107b	03 ca		 add	 ecx, edx
  0107d	3b 4d ec	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01080	77 02		 ja	 SHORT $LN49@inflateBac@3
  01082	eb 69		 jmp	 SHORT $LN44@inflateBac@3
$LN49@inflateBac@3:

; 541  :                     PULLBYTE();

  01084	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01088	75 2a		 jne	 SHORT $LN48@inflateBac@3
  0108a	8d 45 e4	 lea	 eax, DWORD PTR _next$[ebp]
  0108d	50		 push	 eax
  0108e	8b 4d 10	 mov	 ecx, DWORD PTR _in_desc$[ebp]
  01091	51		 push	 ecx
  01092	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01095	83 c4 08	 add	 esp, 8
  01098	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0109b	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0109f	75 13		 jne	 SHORT $LN48@inflateBac@3
  010a1	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  010a8	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  010af	e9 d8 02 00 00	 jmp	 $inf_leave$77603
$LN48@inflateBac@3:
  010b4	33 d2		 xor	 edx, edx
  010b6	75 cc		 jne	 SHORT $LN49@inflateBac@3
  010b8	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  010bb	83 e8 01	 sub	 eax, 1
  010be	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  010c1	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  010c4	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  010c7	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  010ca	d3 e2		 shl	 edx, cl
  010cc	03 55 dc	 add	 edx, DWORD PTR _hold$[ebp]
  010cf	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  010d2	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  010d5	83 c0 01	 add	 eax, 1
  010d8	89 45 e4	 mov	 DWORD PTR _next$[ebp], eax
  010db	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  010de	83 c1 08	 add	 ecx, 8
  010e1	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  010e4	33 d2		 xor	 edx, edx
  010e6	75 9c		 jne	 SHORT $LN49@inflateBac@3

; 542  :                 }

  010e8	e9 57 ff ff ff	 jmp	 $LN55@inflateBac@3
$LN44@inflateBac@3:

; 543  :                 DROPBITS(last.bits);

  010ed	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010f1	8b 45 dc	 mov	 eax, DWORD PTR _hold$[ebp]
  010f4	d3 e8		 shr	 eax, cl
  010f6	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  010f9	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  010fd	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  01100	2b d1		 sub	 edx, ecx
  01102	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  01105	33 c0		 xor	 eax, eax
  01107	75 e4		 jne	 SHORT $LN44@inflateBac@3
$LN41@inflateBac@3:

; 544  :             }
; 545  :             DROPBITS(this.bits);

  01109	0f b6 4d d9	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  0110d	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  01110	d3 ea		 shr	 edx, cl
  01112	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  01115	0f b6 45 d9	 movzx	 eax, BYTE PTR _this$[ebp+1]
  01119	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  0111c	2b c8		 sub	 ecx, eax
  0111e	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  01121	33 d2		 xor	 edx, edx
  01123	75 e4		 jne	 SHORT $LN41@inflateBac@3

; 546  :             if (this.op & 64) {

  01125	0f b6 45 d8	 movzx	 eax, BYTE PTR _this$[ebp]
  01129	83 e0 40	 and	 eax, 64			; 00000040H
  0112c	74 18		 je	 SHORT $LN38@inflateBac@3

; 547  :                 strm->msg = (char *)"invalid distance code";

  0112e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01131	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 548  :                 state->mode = BAD;

  01138	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0113b	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 549  :                 break;

  01141	e9 41 02 00 00	 jmp	 $LN341@inflateBac@3
$LN38@inflateBac@3:

; 550  :             }
; 551  :             state->offset = (unsigned)this.val;

  01146	0f b7 45 da	 movzx	 eax, WORD PTR _this$[ebp+2]
  0114a	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0114d	89 41 44	 mov	 DWORD PTR [ecx+68], eax

; 552  : 
; 553  :             /* get distance extra bits, if any */
; 554  :             state->extra = (unsigned)(this.op) & 15;

  01150	0f b6 55 d8	 movzx	 edx, BYTE PTR _this$[ebp]
  01154	83 e2 0f	 and	 edx, 15			; 0000000fH
  01157	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0115a	89 50 48	 mov	 DWORD PTR [eax+72], edx

; 555  :             if (state->extra != 0) {

  0115d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01160	83 79 48 00	 cmp	 DWORD PTR [ecx+72], 0
  01164	0f 84 b2 00 00
	00		 je	 $LN37@inflateBac@3
$LN33@inflateBac@3:

; 556  :                 NEEDBITS(state->extra);

  0116a	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0116d	8b 45 ec	 mov	 eax, DWORD PTR _bits$[ebp]
  01170	3b 42 48	 cmp	 eax, DWORD PTR [edx+72]
  01173	73 66		 jae	 SHORT $LN35@inflateBac@3
$LN28@inflateBac@3:
  01175	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01179	75 2a		 jne	 SHORT $LN27@inflateBac@3
  0117b	8d 4d e4	 lea	 ecx, DWORD PTR _next$[ebp]
  0117e	51		 push	 ecx
  0117f	8b 55 10	 mov	 edx, DWORD PTR _in_desc$[ebp]
  01182	52		 push	 edx
  01183	ff 55 0c	 call	 DWORD PTR _in$[ebp]
  01186	83 c4 08	 add	 esp, 8
  01189	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  0118c	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01190	75 13		 jne	 SHORT $LN27@inflateBac@3
  01192	c7 45 e4 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
  01199	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  011a0	e9 e7 01 00 00	 jmp	 $inf_leave$77603
$LN27@inflateBac@3:
  011a5	33 c0		 xor	 eax, eax
  011a7	75 cc		 jne	 SHORT $LN28@inflateBac@3
  011a9	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  011ac	83 e9 01	 sub	 ecx, 1
  011af	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  011b2	8b 55 e4	 mov	 edx, DWORD PTR _next$[ebp]
  011b5	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011b8	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  011bb	d3 e0		 shl	 eax, cl
  011bd	03 45 dc	 add	 eax, DWORD PTR _hold$[ebp]
  011c0	89 45 dc	 mov	 DWORD PTR _hold$[ebp], eax
  011c3	8b 4d e4	 mov	 ecx, DWORD PTR _next$[ebp]
  011c6	83 c1 01	 add	 ecx, 1
  011c9	89 4d e4	 mov	 DWORD PTR _next$[ebp], ecx
  011cc	8b 55 ec	 mov	 edx, DWORD PTR _bits$[ebp]
  011cf	83 c2 08	 add	 edx, 8
  011d2	89 55 ec	 mov	 DWORD PTR _bits$[ebp], edx
  011d5	33 c0		 xor	 eax, eax
  011d7	75 9c		 jne	 SHORT $LN28@inflateBac@3
  011d9	eb 8f		 jmp	 SHORT $LN33@inflateBac@3
$LN35@inflateBac@3:
  011db	33 c9		 xor	 ecx, ecx
  011dd	75 8b		 jne	 SHORT $LN33@inflateBac@3

; 557  :                 state->offset += BITS(state->extra);

  011df	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  011e2	b8 01 00 00 00	 mov	 eax, 1
  011e7	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  011ea	d3 e0		 shl	 eax, cl
  011ec	83 e8 01	 sub	 eax, 1
  011ef	23 45 dc	 and	 eax, DWORD PTR _hold$[ebp]
  011f2	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  011f5	03 41 44	 add	 eax, DWORD PTR [ecx+68]
  011f8	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  011fb	89 42 44	 mov	 DWORD PTR [edx+68], eax
$LN23@inflateBac@3:

; 558  :                 DROPBITS(state->extra);

  011fe	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01201	8b 55 dc	 mov	 edx, DWORD PTR _hold$[ebp]
  01204	8b 48 48	 mov	 ecx, DWORD PTR [eax+72]
  01207	d3 ea		 shr	 edx, cl
  01209	89 55 dc	 mov	 DWORD PTR _hold$[ebp], edx
  0120c	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0120f	8b 4d ec	 mov	 ecx, DWORD PTR _bits$[ebp]
  01212	2b 48 48	 sub	 ecx, DWORD PTR [eax+72]
  01215	89 4d ec	 mov	 DWORD PTR _bits$[ebp], ecx
  01218	33 d2		 xor	 edx, edx
  0121a	75 e2		 jne	 SHORT $LN23@inflateBac@3
$LN37@inflateBac@3:

; 559  :             }
; 560  :             if (state->offset > state->wsize - (state->whave < state->wsize ?
; 561  :                                                 left : 0)) {

  0121c	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0121f	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01222	8b 50 2c	 mov	 edx, DWORD PTR [eax+44]
  01225	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  01228	1b c0		 sbb	 eax, eax
  0122a	23 45 e8	 and	 eax, DWORD PTR _left$[ebp]
  0122d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01230	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  01233	2b d0		 sub	 edx, eax
  01235	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01238	39 50 44	 cmp	 DWORD PTR [eax+68], edx
  0123b	76 18		 jbe	 SHORT $LN16@inflateBac@3

; 562  :                 strm->msg = (char *)"invalid distance too far back";

  0123d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01240	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 563  :                 state->mode = BAD;

  01247	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0124a	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 564  :                 break;

  01250	e9 32 01 00 00	 jmp	 $LN341@inflateBac@3
$LN16@inflateBac@3:

; 565  :             }
; 566  :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 567  : 
; 568  :             /* copy match from window to output */
; 569  :             do {
; 570  :                 ROOM();

  01255	83 7d e8 00	 cmp	 DWORD PTR _left$[ebp], 0
  01259	75 3d		 jne	 SHORT $LN15@inflateBac@3
  0125b	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0125e	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  01261	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx
  01264	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  01267	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0126a	89 45 e8	 mov	 DWORD PTR _left$[ebp], eax
  0126d	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01270	8b 55 e8	 mov	 edx, DWORD PTR _left$[ebp]
  01273	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
  01276	8b 45 e8	 mov	 eax, DWORD PTR _left$[ebp]
  01279	50		 push	 eax
  0127a	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  0127d	51		 push	 ecx
  0127e	8b 55 18	 mov	 edx, DWORD PTR _out_desc$[ebp]
  01281	52		 push	 edx
  01282	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01285	83 c4 0c	 add	 esp, 12			; 0000000cH
  01288	85 c0		 test	 eax, eax
  0128a	74 0c		 je	 SHORT $LN15@inflateBac@3
  0128c	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
  01293	e9 f4 00 00 00	 jmp	 $inf_leave$77603
$LN15@inflateBac@3:
  01298	33 c0		 xor	 eax, eax
  0129a	75 b9		 jne	 SHORT $LN16@inflateBac@3

; 571  :                 copy = state->wsize - state->offset;

  0129c	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  0129f	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  012a2	8b 41 28	 mov	 eax, DWORD PTR [ecx+40]
  012a5	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  012a8	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 572  :                 if (copy < left) {

  012ab	8b 4d d4	 mov	 ecx, DWORD PTR _copy$[ebp]
  012ae	3b 4d e8	 cmp	 ecx, DWORD PTR _left$[ebp]
  012b1	73 14		 jae	 SHORT $LN11@inflateBac@3

; 573  :                     from = put + copy;

  012b3	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  012b6	03 55 d4	 add	 edx, DWORD PTR _copy$[ebp]
  012b9	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 574  :                     copy = left - copy;

  012bc	8b 45 e8	 mov	 eax, DWORD PTR _left$[ebp]
  012bf	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  012c2	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax

; 575  :                 }
; 576  :                 else {

  012c5	eb 12		 jmp	 SHORT $LN10@inflateBac@3
$LN11@inflateBac@3:

; 577  :                     from = put - state->offset;

  012c7	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012ca	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  012cd	2b 51 44	 sub	 edx, DWORD PTR [ecx+68]
  012d0	89 55 d0	 mov	 DWORD PTR _from$[ebp], edx

; 578  :                     copy = left;

  012d3	8b 45 e8	 mov	 eax, DWORD PTR _left$[ebp]
  012d6	89 45 d4	 mov	 DWORD PTR _copy$[ebp], eax
$LN10@inflateBac@3:

; 579  :                 }
; 580  :                 if (copy > state->length) copy = state->length;

  012d9	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012dc	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  012df	3b 51 40	 cmp	 edx, DWORD PTR [ecx+64]
  012e2	76 09		 jbe	 SHORT $LN9@inflateBac@3
  012e4	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  012e7	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  012ea	89 4d d4	 mov	 DWORD PTR _copy$[ebp], ecx
$LN9@inflateBac@3:

; 581  :                 state->length -= copy;

  012ed	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  012f0	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  012f3	2b 45 d4	 sub	 eax, DWORD PTR _copy$[ebp]
  012f6	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  012f9	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 582  :                 left -= copy;

  012fc	8b 55 e8	 mov	 edx, DWORD PTR _left$[ebp]
  012ff	2b 55 d4	 sub	 edx, DWORD PTR _copy$[ebp]
  01302	89 55 e8	 mov	 DWORD PTR _left$[ebp], edx
$LN8@inflateBac@3:

; 583  :                 do {
; 584  :                     *put++ = *from++;

  01305	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01308	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  0130b	8a 11		 mov	 dl, BYTE PTR [ecx]
  0130d	88 10		 mov	 BYTE PTR [eax], dl
  0130f	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01312	83 c0 01	 add	 eax, 1
  01315	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  01318	8b 4d d0	 mov	 ecx, DWORD PTR _from$[ebp]
  0131b	83 c1 01	 add	 ecx, 1
  0131e	89 4d d0	 mov	 DWORD PTR _from$[ebp], ecx

; 585  :                 } while (--copy);

  01321	8b 55 d4	 mov	 edx, DWORD PTR _copy$[ebp]
  01324	83 ea 01	 sub	 edx, 1
  01327	89 55 d4	 mov	 DWORD PTR _copy$[ebp], edx
  0132a	75 d9		 jne	 SHORT $LN8@inflateBac@3

; 586  :             } while (state->length != 0);

  0132c	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  0132f	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  01333	0f 85 1c ff ff
	ff		 jne	 $LN16@inflateBac@3

; 587  :             break;

  01339	eb 4c		 jmp	 SHORT $LN341@inflateBac@3
$LN5@inflateBac@3:

; 588  : 
; 589  :         case DONE:
; 590  :             /* inflate stream terminated properly -- write leftover output */
; 591  :             ret = Z_STREAM_END;

  0133b	c7 45 e0 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 592  :             if (left < state->wsize) {

  01342	8b 4d cc	 mov	 ecx, DWORD PTR _state$[ebp]
  01345	8b 55 e8	 mov	 edx, DWORD PTR _left$[ebp]
  01348	3b 51 28	 cmp	 edx, DWORD PTR [ecx+40]
  0134b	73 26		 jae	 SHORT $LN4@inflateBac@3

; 593  :                 if (out(out_desc, state->window, state->wsize - left))

  0134d	8b 45 cc	 mov	 eax, DWORD PTR _state$[ebp]
  01350	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  01353	2b 4d e8	 sub	 ecx, DWORD PTR _left$[ebp]
  01356	51		 push	 ecx
  01357	8b 55 cc	 mov	 edx, DWORD PTR _state$[ebp]
  0135a	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0135d	50		 push	 eax
  0135e	8b 4d 18	 mov	 ecx, DWORD PTR _out_desc$[ebp]
  01361	51		 push	 ecx
  01362	ff 55 14	 call	 DWORD PTR _out$[ebp]
  01365	83 c4 0c	 add	 esp, 12			; 0000000cH
  01368	85 c0		 test	 eax, eax
  0136a	74 07		 je	 SHORT $LN4@inflateBac@3

; 594  :                     ret = Z_BUF_ERROR;

  0136c	c7 45 e0 fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN4@inflateBac@3:

; 595  :             }
; 596  :             goto inf_leave;

  01373	eb 17		 jmp	 SHORT $inf_leave$77603
$LN2@inflateBac@3:

; 597  : 
; 598  :         case BAD:
; 599  :             ret = Z_DATA_ERROR;

  01375	c7 45 e0 fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 600  :             goto inf_leave;

  0137c	eb 0e		 jmp	 SHORT $inf_leave$77603
$LN1@inflateBac@3:

; 601  : 
; 602  :         default:                /* can't happen, but makes compilers happy */
; 603  :             ret = Z_STREAM_ERROR;

  0137e	c7 45 e0 fe ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -2 ; fffffffeH
  01385	eb 05		 jmp	 SHORT $inf_leave$77603
$LN341@inflateBac@3:

; 604  :             goto inf_leave;
; 605  :         }

  01387	e9 09 ed ff ff	 jmp	 $LN344@inflateBac@3
$inf_leave$77603:

; 606  : 
; 607  :     /* Return unused input */
; 608  :   inf_leave:
; 609  :     strm->next_in = next;

  0138c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0138f	8b 45 e4	 mov	 eax, DWORD PTR _next$[ebp]
  01392	89 02		 mov	 DWORD PTR [edx], eax

; 610  :     strm->avail_in = have;

  01394	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01397	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  0139a	89 51 04	 mov	 DWORD PTR [ecx+4], edx

; 611  :     return ret;

  0139d	8b 45 e0	 mov	 eax, DWORD PTR _ret$[ebp]
$LN347@inflateBac@3:

; 612  : }

  013a0	8b e5		 mov	 esp, ebp
  013a2	5d		 pop	 ebp
  013a3	c2 14 00	 ret	 20			; 00000014H
  013a6	8b ff		 npad	 2
$LN352@inflateBac@3:
  013a8	00 00 00 00	 DD	 $LN340@inflateBac@3
  013ac	00 00 00 00	 DD	 $LN309@inflateBac@3
  013b0	00 00 00 00	 DD	 $LN271@inflateBac@3
  013b4	00 00 00 00	 DD	 $LN130@inflateBac@3
  013b8	00 00 00 00	 DD	 $LN5@inflateBac@3
  013bc	00 00 00 00	 DD	 $LN2@inflateBac@3
  013c0	00 00 00 00	 DD	 $LN1@inflateBac@3
$LN351@inflateBac@3:
  013c4	00		 DB	 0
  013c5	06		 DB	 6
  013c6	01		 DB	 1
  013c7	06		 DB	 6
  013c8	02		 DB	 2
  013c9	06		 DB	 6
  013ca	06		 DB	 6
  013cb	03		 DB	 3
  013cc	06		 DB	 6
  013cd	06		 DB	 6
  013ce	06		 DB	 6
  013cf	06		 DB	 6
  013d0	06		 DB	 6
  013d1	06		 DB	 6
  013d2	06		 DB	 6
  013d3	04		 DB	 4
  013d4	05		 DB	 5
  013d5	8d 49 00	 npad	 3
$LN353@inflateBac@3:
  013d8	00 00 00 00	 DD	 $LN317@inflateBac@3
  013dc	00 00 00 00	 DD	 $LN316@inflateBac@3
  013e0	00 00 00 00	 DD	 $LN315@inflateBac@3
  013e4	00 00 00 00	 DD	 $LN314@inflateBac@3
_inflateBack@20 ENDP
END
