; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\adler32.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	_adler32@12
; Function compile flags: /Odtp
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\adler32.c
;	COMDAT _adler32@12
_TEXT	SEGMENT
_sum2$ = -8						; size = 4
_n$ = -4						; size = 4
_adler$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_adler32@12 PROC					; COMDAT

; 61   : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 62   :     unsigned long sum2;
; 63   :     unsigned n;
; 64   : 
; 65   :     /* split Adler-32 into component sums */
; 66   :     sum2 = (adler >> 16) & 0xffff;

  00006	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00009	c1 e8 10	 shr	 eax, 16			; 00000010H
  0000c	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00011	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax

; 67   :     adler &= 0xffff;

  00014	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  00017	81 e1 ff ff 00
	00		 and	 ecx, 65535		; 0000ffffH
  0001d	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx

; 68   : 
; 69   :     /* in case user likes doing a byte at a time, keep it fast */
; 70   :     if (len == 1) {

  00020	83 7d 10 01	 cmp	 DWORD PTR _len$[ebp], 1
  00024	75 4c		 jne	 SHORT $LN18@adler32

; 71   :         adler += buf[0];

  00026	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  00029	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0002c	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  0002f	89 45 08	 mov	 DWORD PTR _adler$[ebp], eax

; 72   :         if (adler >= BASE)

  00032	81 7d 08 f1 ff
	00 00		 cmp	 DWORD PTR _adler$[ebp], 65521 ; 0000fff1H
  00039	72 0c		 jb	 SHORT $LN17@adler32

; 73   :             adler -= BASE;

  0003b	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  0003e	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
  00044	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
$LN17@adler32:

; 74   :         sum2 += adler;

  00047	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0004a	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0004d	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 75   :         if (sum2 >= BASE)

  00050	81 7d f8 f1 ff
	00 00		 cmp	 DWORD PTR _sum2$[ebp], 65521 ; 0000fff1H
  00057	72 0b		 jb	 SHORT $LN16@adler32

; 76   :             sum2 -= BASE;

  00059	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  0005c	2d f1 ff 00 00	 sub	 eax, 65521		; 0000fff1H
  00061	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax
$LN16@adler32:

; 77   :         return adler | (sum2 << 16);

  00064	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00067	c1 e0 10	 shl	 eax, 16			; 00000010H
  0006a	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
  0006d	e9 13 04 00 00	 jmp	 $LN19@adler32
$LN18@adler32:

; 78   :     }
; 79   : 
; 80   :     /* initial Adler-32 value (deferred check for len == 1 speed) */
; 81   :     if (buf == Z_NULL)

  00072	83 7d 0c 00	 cmp	 DWORD PTR _buf$[ebp], 0
  00076	75 0a		 jne	 SHORT $LN15@adler32

; 82   :         return 1L;

  00078	b8 01 00 00 00	 mov	 eax, 1
  0007d	e9 03 04 00 00	 jmp	 $LN19@adler32
$LN15@adler32:

; 83   : 
; 84   :     /* in case short lengths are provided, keep it somewhat fast */
; 85   :     if (len < 16) {

  00082	83 7d 10 10	 cmp	 DWORD PTR _len$[ebp], 16 ; 00000010H
  00086	73 62		 jae	 SHORT $LN10@adler32
$LN13@adler32:

; 86   :         while (len--) {

  00088	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  0008b	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  0008e	83 ea 01	 sub	 edx, 1
  00091	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
  00094	85 c9		 test	 ecx, ecx
  00096	74 20		 je	 SHORT $LN12@adler32

; 87   :             adler += *buf++;

  00098	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0009b	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0009e	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  000a1	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  000a4	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 88   :             sum2 += adler;

  000ad	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  000b0	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  000b3	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax

; 89   :         }

  000b6	eb d0		 jmp	 SHORT $LN13@adler32
$LN12@adler32:

; 90   :         if (adler >= BASE)

  000b8	81 7d 08 f1 ff
	00 00		 cmp	 DWORD PTR _adler$[ebp], 65521 ; 0000fff1H
  000bf	72 0c		 jb	 SHORT $LN11@adler32

; 91   :             adler -= BASE;

  000c1	8b 4d 08	 mov	 ecx, DWORD PTR _adler$[ebp]
  000c4	81 e9 f1 ff 00
	00		 sub	 ecx, 65521		; 0000fff1H
  000ca	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
$LN11@adler32:

; 92   :         MOD4(sum2);             /* only added so many BASE's */

  000cd	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  000d0	33 d2		 xor	 edx, edx
  000d2	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  000d7	f7 f1		 div	 ecx
  000d9	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 93   :         return adler | (sum2 << 16);

  000dc	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  000df	c1 e0 10	 shl	 eax, 16			; 00000010H
  000e2	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
  000e5	e9 9b 03 00 00	 jmp	 $LN19@adler32
$LN10@adler32:

; 94   :     }
; 95   : 
; 96   :     /* do length NMAX blocks -- requires just one modulo operation */
; 97   :     while (len >= NMAX) {

  000ea	81 7d 10 b0 15
	00 00		 cmp	 DWORD PTR _len$[ebp], 5552 ; 000015b0H
  000f1	0f 82 ad 01 00
	00		 jb	 $LN9@adler32

; 98   :         len -= NMAX;

  000f7	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  000fa	81 ea b0 15 00
	00		 sub	 edx, 5552		; 000015b0H
  00100	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 99   :         n = NMAX / 16;          /* NMAX is divisible by 16 */

  00103	c7 45 fc 5b 01
	00 00		 mov	 DWORD PTR _n$[ebp], 347	; 0000015bH
$LN8@adler32:

; 100  :         do {
; 101  :             DO16(buf);          /* 16 sums unrolled */

  0010a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0010d	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00110	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00113	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00116	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00119	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0011c	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0011f	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00122	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  00126	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00129	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0012c	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0012f	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00132	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00135	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00138	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  0013c	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0013f	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00142	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00145	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00148	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0014b	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0014e	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00152	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00155	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00158	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0015b	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0015e	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00161	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00164	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  00168	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0016b	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0016e	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00171	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00174	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00177	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0017a	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  0017e	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00181	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00184	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00187	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0018a	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0018d	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00190	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  00194	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00197	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0019a	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0019d	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001a0	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001a3	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001a6	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  001aa	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001ad	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001b0	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001b3	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001b6	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001b9	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001bc	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  001c0	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001c3	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001c6	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001c9	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001cc	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001cf	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001d2	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  001d6	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001d9	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001dc	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001df	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001e2	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001e5	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001e8	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  001ec	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  001ef	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  001f2	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  001f5	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  001f8	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  001fb	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  001fe	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  00202	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00205	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00208	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0020b	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0020e	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00211	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00214	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  00218	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0021b	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0021e	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00221	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00224	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00227	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0022a	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  0022e	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00231	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00234	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00237	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0023a	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0023d	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00240	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  00244	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00247	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0024a	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0024d	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00250	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00253	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00256	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  0025a	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0025d	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00260	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00263	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00266	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 102  :             buf += 16;

  00269	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0026c	83 c0 10	 add	 eax, 16			; 00000010H
  0026f	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 103  :         } while (--n);

  00272	8b 4d fc	 mov	 ecx, DWORD PTR _n$[ebp]
  00275	83 e9 01	 sub	 ecx, 1
  00278	89 4d fc	 mov	 DWORD PTR _n$[ebp], ecx
  0027b	0f 85 89 fe ff
	ff		 jne	 $LN8@adler32

; 104  :         MOD(adler);

  00281	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00284	33 d2		 xor	 edx, edx
  00286	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0028b	f7 f1		 div	 ecx
  0028d	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 105  :         MOD(sum2);

  00290	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00293	33 d2		 xor	 edx, edx
  00295	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  0029a	f7 f1		 div	 ecx
  0029c	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 106  :     }

  0029f	e9 46 fe ff ff	 jmp	 $LN10@adler32
$LN9@adler32:

; 107  : 
; 108  :     /* do remaining bytes (less than NMAX, still just one modulo) */
; 109  :     if (len) {                  /* avoid modulos if none remaining */

  002a4	83 7d 10 00	 cmp	 DWORD PTR _len$[ebp], 0
  002a8	0f 84 ce 01 00
	00		 je	 $LN5@adler32
$LN4@adler32:

; 110  :         while (len >= 16) {

  002ae	83 7d 10 10	 cmp	 DWORD PTR _len$[ebp], 16 ; 00000010H
  002b2	0f 82 76 01 00
	00		 jb	 $LN2@adler32

; 111  :             len -= 16;

  002b8	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  002bb	83 ea 10	 sub	 edx, 16			; 00000010H
  002be	89 55 10	 mov	 DWORD PTR _len$[ebp], edx

; 112  :             DO16(buf);

  002c1	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002c4	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  002c7	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002ca	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002cd	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  002d0	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002d3	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  002d6	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002d9	0f b6 48 01	 movzx	 ecx, BYTE PTR [eax+1]
  002dd	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002e0	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002e3	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  002e6	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002e9	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  002ec	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  002ef	0f b6 48 02	 movzx	 ecx, BYTE PTR [eax+2]
  002f3	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  002f6	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  002f9	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  002fc	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  002ff	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00302	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00305	0f b6 48 03	 movzx	 ecx, BYTE PTR [eax+3]
  00309	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0030c	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0030f	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00312	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00315	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00318	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0031b	0f b6 48 04	 movzx	 ecx, BYTE PTR [eax+4]
  0031f	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00322	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00325	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00328	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0032b	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0032e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00331	0f b6 48 05	 movzx	 ecx, BYTE PTR [eax+5]
  00335	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00338	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0033b	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0033e	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00341	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00344	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00347	0f b6 48 06	 movzx	 ecx, BYTE PTR [eax+6]
  0034b	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0034e	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00351	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00354	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00357	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0035a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0035d	0f b6 48 07	 movzx	 ecx, BYTE PTR [eax+7]
  00361	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00364	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00367	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0036a	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0036d	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00370	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00373	0f b6 48 08	 movzx	 ecx, BYTE PTR [eax+8]
  00377	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  0037a	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0037d	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00380	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00383	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  00386	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00389	0f b6 48 09	 movzx	 ecx, BYTE PTR [eax+9]
  0038d	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00390	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00393	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00396	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00399	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0039c	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0039f	0f b6 48 0a	 movzx	 ecx, BYTE PTR [eax+10]
  003a3	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003a6	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003a9	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003ac	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003af	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003b2	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003b5	0f b6 48 0b	 movzx	 ecx, BYTE PTR [eax+11]
  003b9	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003bc	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003bf	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003c2	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003c5	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003c8	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003cb	0f b6 48 0c	 movzx	 ecx, BYTE PTR [eax+12]
  003cf	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003d2	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003d5	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003d8	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003db	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003de	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003e1	0f b6 48 0d	 movzx	 ecx, BYTE PTR [eax+13]
  003e5	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003e8	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  003eb	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  003ee	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  003f1	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  003f4	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  003f7	0f b6 48 0e	 movzx	 ecx, BYTE PTR [eax+14]
  003fb	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  003fe	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00401	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  00404	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  00407	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
  0040a	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  0040d	0f b6 48 0f	 movzx	 ecx, BYTE PTR [eax+15]
  00411	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00414	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  00417	8b 55 f8	 mov	 edx, DWORD PTR _sum2$[ebp]
  0041a	03 55 08	 add	 edx, DWORD PTR _adler$[ebp]
  0041d	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx

; 113  :             buf += 16;

  00420	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00423	83 c0 10	 add	 eax, 16			; 00000010H
  00426	89 45 0c	 mov	 DWORD PTR _buf$[ebp], eax

; 114  :         }

  00429	e9 80 fe ff ff	 jmp	 $LN4@adler32
$LN2@adler32:

; 115  :         while (len--) {

  0042e	8b 4d 10	 mov	 ecx, DWORD PTR _len$[ebp]
  00431	8b 55 10	 mov	 edx, DWORD PTR _len$[ebp]
  00434	83 ea 01	 sub	 edx, 1
  00437	89 55 10	 mov	 DWORD PTR _len$[ebp], edx
  0043a	85 c9		 test	 ecx, ecx
  0043c	74 20		 je	 SHORT $LN1@adler32

; 116  :             adler += *buf++;

  0043e	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00441	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00444	03 4d 08	 add	 ecx, DWORD PTR _adler$[ebp]
  00447	89 4d 08	 mov	 DWORD PTR _adler$[ebp], ecx
  0044a	8b 55 0c	 mov	 edx, DWORD PTR _buf$[ebp]
  0044d	83 c2 01	 add	 edx, 1
  00450	89 55 0c	 mov	 DWORD PTR _buf$[ebp], edx

; 117  :             sum2 += adler;

  00453	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00456	03 45 08	 add	 eax, DWORD PTR _adler$[ebp]
  00459	89 45 f8	 mov	 DWORD PTR _sum2$[ebp], eax

; 118  :         }

  0045c	eb d0		 jmp	 SHORT $LN2@adler32
$LN1@adler32:

; 119  :         MOD(adler);

  0045e	8b 45 08	 mov	 eax, DWORD PTR _adler$[ebp]
  00461	33 d2		 xor	 edx, edx
  00463	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00468	f7 f1		 div	 ecx
  0046a	89 55 08	 mov	 DWORD PTR _adler$[ebp], edx

; 120  :         MOD(sum2);

  0046d	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  00470	33 d2		 xor	 edx, edx
  00472	b9 f1 ff 00 00	 mov	 ecx, 65521		; 0000fff1H
  00477	f7 f1		 div	 ecx
  00479	89 55 f8	 mov	 DWORD PTR _sum2$[ebp], edx
$LN5@adler32:

; 121  :     }
; 122  : 
; 123  :     /* return recombined sums */
; 124  :     return adler | (sum2 << 16);

  0047c	8b 45 f8	 mov	 eax, DWORD PTR _sum2$[ebp]
  0047f	c1 e0 10	 shl	 eax, 16			; 00000010H
  00482	0b 45 08	 or	 eax, DWORD PTR _adler$[ebp]
$LN19@adler32:

; 125  : }

  00485	8b e5		 mov	 esp, ebp
  00487	5d		 pop	 ebp
  00488	c2 0c 00	 ret	 12			; 0000000cH
_adler32@12 ENDP
END
