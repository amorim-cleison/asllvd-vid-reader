; Listing generated by Microsoft (R) Optimizing Compiler Version 15.00.21022.08 

	TITLE	y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\inflate.c
	.686P
	.XMM
	include listing.inc
	.model	flat

INCLUDELIB OLDNAMES

PUBLIC	??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ ; `string'
PUBLIC	??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ ; `string'
PUBLIC	??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@	; `string'
PUBLIC	??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ ; `string'
PUBLIC	??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@	; `string'
PUBLIC	??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@	; `string'
PUBLIC	??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ ; `string'
;	COMDAT ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@
CONST	SEGMENT
??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@ DB 'incorrect length che'
	DB	'ck', 00H					; `string'
CONST	ENDS
;	COMDAT ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@
CONST	SEGMENT
??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@ DB 'incorrect data check', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@
CONST	SEGMENT
??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@ DB 'header crc mismatch', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@
CONST	SEGMENT
??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@ DB 'unknown header fl'
	DB	'ags set', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@
CONST	SEGMENT
??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@ DB 'invalid window size', 00H ; `string'
CONST	ENDS
;	COMDAT ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@
CONST	SEGMENT
??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@ DB 'unknown compress'
	DB	'ion method', 00H				; `string'
CONST	ENDS
;	COMDAT ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@
CONST	SEGMENT
??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@ DB 'incorrect header che'
	DB	'ck', 00H					; `string'
?lenfix@?1??fixedtables@@9@9 DB 060H			; `fixedtables'::`2'::lenfix
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c0H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a0H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e0H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	090H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d0H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b0H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f0H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c8H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a8H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e8H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	098H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d8H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b8H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f8H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c4H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a4H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e4H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	094H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d4H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b4H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f4H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0ccH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0acH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0ecH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09cH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0dcH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bcH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fcH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c2H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a2H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e2H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	092H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d2H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b2H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f2H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0caH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0aaH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0eaH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09aH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0daH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0baH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0faH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c6H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a6H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e6H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	096H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d6H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b6H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f6H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0ceH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0aeH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0eeH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09eH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0deH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0beH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0feH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	050H
	DB	00H
	DB	08H
	DW	010H
	DB	014H
	DB	08H
	DW	073H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	070H
	DB	00H
	DB	08H
	DW	030H
	DB	00H
	DB	09H
	DW	0c1H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	060H
	DB	00H
	DB	08H
	DW	020H
	DB	00H
	DB	09H
	DW	0a1H
	DB	00H
	DB	08H
	DW	00H
	DB	00H
	DB	08H
	DW	080H
	DB	00H
	DB	08H
	DW	040H
	DB	00H
	DB	09H
	DW	0e1H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	058H
	DB	00H
	DB	08H
	DW	018H
	DB	00H
	DB	09H
	DW	091H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	078H
	DB	00H
	DB	08H
	DW	038H
	DB	00H
	DB	09H
	DW	0d1H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	068H
	DB	00H
	DB	08H
	DW	028H
	DB	00H
	DB	09H
	DW	0b1H
	DB	00H
	DB	08H
	DW	08H
	DB	00H
	DB	08H
	DW	088H
	DB	00H
	DB	08H
	DW	048H
	DB	00H
	DB	09H
	DW	0f1H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	054H
	DB	00H
	DB	08H
	DW	014H
	DB	015H
	DB	08H
	DW	0e3H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	074H
	DB	00H
	DB	08H
	DW	034H
	DB	00H
	DB	09H
	DW	0c9H
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	064H
	DB	00H
	DB	08H
	DW	024H
	DB	00H
	DB	09H
	DW	0a9H
	DB	00H
	DB	08H
	DW	04H
	DB	00H
	DB	08H
	DW	084H
	DB	00H
	DB	08H
	DW	044H
	DB	00H
	DB	09H
	DW	0e9H
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05cH
	DB	00H
	DB	08H
	DW	01cH
	DB	00H
	DB	09H
	DW	099H
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07cH
	DB	00H
	DB	08H
	DW	03cH
	DB	00H
	DB	09H
	DW	0d9H
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06cH
	DB	00H
	DB	08H
	DW	02cH
	DB	00H
	DB	09H
	DW	0b9H
	DB	00H
	DB	08H
	DW	0cH
	DB	00H
	DB	08H
	DW	08cH
	DB	00H
	DB	08H
	DW	04cH
	DB	00H
	DB	09H
	DW	0f9H
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	052H
	DB	00H
	DB	08H
	DW	012H
	DB	015H
	DB	08H
	DW	0a3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	072H
	DB	00H
	DB	08H
	DW	032H
	DB	00H
	DB	09H
	DW	0c5H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	062H
	DB	00H
	DB	08H
	DW	022H
	DB	00H
	DB	09H
	DW	0a5H
	DB	00H
	DB	08H
	DW	02H
	DB	00H
	DB	08H
	DW	082H
	DB	00H
	DB	08H
	DW	042H
	DB	00H
	DB	09H
	DW	0e5H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05aH
	DB	00H
	DB	08H
	DW	01aH
	DB	00H
	DB	09H
	DW	095H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07aH
	DB	00H
	DB	08H
	DW	03aH
	DB	00H
	DB	09H
	DW	0d5H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06aH
	DB	00H
	DB	08H
	DW	02aH
	DB	00H
	DB	09H
	DW	0b5H
	DB	00H
	DB	08H
	DW	0aH
	DB	00H
	DB	08H
	DW	08aH
	DB	00H
	DB	08H
	DW	04aH
	DB	00H
	DB	09H
	DW	0f5H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	056H
	DB	00H
	DB	08H
	DW	016H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	076H
	DB	00H
	DB	08H
	DW	036H
	DB	00H
	DB	09H
	DW	0cdH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	066H
	DB	00H
	DB	08H
	DW	026H
	DB	00H
	DB	09H
	DW	0adH
	DB	00H
	DB	08H
	DW	06H
	DB	00H
	DB	08H
	DW	086H
	DB	00H
	DB	08H
	DW	046H
	DB	00H
	DB	09H
	DW	0edH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05eH
	DB	00H
	DB	08H
	DW	01eH
	DB	00H
	DB	09H
	DW	09dH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07eH
	DB	00H
	DB	08H
	DW	03eH
	DB	00H
	DB	09H
	DW	0ddH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06eH
	DB	00H
	DB	08H
	DW	02eH
	DB	00H
	DB	09H
	DW	0bdH
	DB	00H
	DB	08H
	DW	0eH
	DB	00H
	DB	08H
	DW	08eH
	DB	00H
	DB	08H
	DW	04eH
	DB	00H
	DB	09H
	DW	0fdH
	DB	060H
	DB	07H
	DW	00H
	DB	00H
	DB	08H
	DW	051H
	DB	00H
	DB	08H
	DW	011H
	DB	015H
	DB	08H
	DW	083H
	DB	012H
	DB	07H
	DW	01fH
	DB	00H
	DB	08H
	DW	071H
	DB	00H
	DB	08H
	DW	031H
	DB	00H
	DB	09H
	DW	0c3H
	DB	010H
	DB	07H
	DW	0aH
	DB	00H
	DB	08H
	DW	061H
	DB	00H
	DB	08H
	DW	021H
	DB	00H
	DB	09H
	DW	0a3H
	DB	00H
	DB	08H
	DW	01H
	DB	00H
	DB	08H
	DW	081H
	DB	00H
	DB	08H
	DW	041H
	DB	00H
	DB	09H
	DW	0e3H
	DB	010H
	DB	07H
	DW	06H
	DB	00H
	DB	08H
	DW	059H
	DB	00H
	DB	08H
	DW	019H
	DB	00H
	DB	09H
	DW	093H
	DB	013H
	DB	07H
	DW	03bH
	DB	00H
	DB	08H
	DW	079H
	DB	00H
	DB	08H
	DW	039H
	DB	00H
	DB	09H
	DW	0d3H
	DB	011H
	DB	07H
	DW	011H
	DB	00H
	DB	08H
	DW	069H
	DB	00H
	DB	08H
	DW	029H
	DB	00H
	DB	09H
	DW	0b3H
	DB	00H
	DB	08H
	DW	09H
	DB	00H
	DB	08H
	DW	089H
	DB	00H
	DB	08H
	DW	049H
	DB	00H
	DB	09H
	DW	0f3H
	DB	010H
	DB	07H
	DW	04H
	DB	00H
	DB	08H
	DW	055H
	DB	00H
	DB	08H
	DW	015H
	DB	010H
	DB	08H
	DW	0102H
	DB	013H
	DB	07H
	DW	02bH
	DB	00H
	DB	08H
	DW	075H
	DB	00H
	DB	08H
	DW	035H
	DB	00H
	DB	09H
	DW	0cbH
	DB	011H
	DB	07H
	DW	0dH
	DB	00H
	DB	08H
	DW	065H
	DB	00H
	DB	08H
	DW	025H
	DB	00H
	DB	09H
	DW	0abH
	DB	00H
	DB	08H
	DW	05H
	DB	00H
	DB	08H
	DW	085H
	DB	00H
	DB	08H
	DW	045H
	DB	00H
	DB	09H
	DW	0ebH
	DB	010H
	DB	07H
	DW	08H
	DB	00H
	DB	08H
	DW	05dH
	DB	00H
	DB	08H
	DW	01dH
	DB	00H
	DB	09H
	DW	09bH
	DB	014H
	DB	07H
	DW	053H
	DB	00H
	DB	08H
	DW	07dH
	DB	00H
	DB	08H
	DW	03dH
	DB	00H
	DB	09H
	DW	0dbH
	DB	012H
	DB	07H
	DW	017H
	DB	00H
	DB	08H
	DW	06dH
	DB	00H
	DB	08H
	DW	02dH
	DB	00H
	DB	09H
	DW	0bbH
	DB	00H
	DB	08H
	DW	0dH
	DB	00H
	DB	08H
	DW	08dH
	DB	00H
	DB	08H
	DW	04dH
	DB	00H
	DB	09H
	DW	0fbH
	DB	010H
	DB	07H
	DW	03H
	DB	00H
	DB	08H
	DW	053H
	DB	00H
	DB	08H
	DW	013H
	DB	015H
	DB	08H
	DW	0c3H
	DB	013H
	DB	07H
	DW	023H
	DB	00H
	DB	08H
	DW	073H
	DB	00H
	DB	08H
	DW	033H
	DB	00H
	DB	09H
	DW	0c7H
	DB	011H
	DB	07H
	DW	0bH
	DB	00H
	DB	08H
	DW	063H
	DB	00H
	DB	08H
	DW	023H
	DB	00H
	DB	09H
	DW	0a7H
	DB	00H
	DB	08H
	DW	03H
	DB	00H
	DB	08H
	DW	083H
	DB	00H
	DB	08H
	DW	043H
	DB	00H
	DB	09H
	DW	0e7H
	DB	010H
	DB	07H
	DW	07H
	DB	00H
	DB	08H
	DW	05bH
	DB	00H
	DB	08H
	DW	01bH
	DB	00H
	DB	09H
	DW	097H
	DB	014H
	DB	07H
	DW	043H
	DB	00H
	DB	08H
	DW	07bH
	DB	00H
	DB	08H
	DW	03bH
	DB	00H
	DB	09H
	DW	0d7H
	DB	012H
	DB	07H
	DW	013H
	DB	00H
	DB	08H
	DW	06bH
	DB	00H
	DB	08H
	DW	02bH
	DB	00H
	DB	09H
	DW	0b7H
	DB	00H
	DB	08H
	DW	0bH
	DB	00H
	DB	08H
	DW	08bH
	DB	00H
	DB	08H
	DW	04bH
	DB	00H
	DB	09H
	DW	0f7H
	DB	010H
	DB	07H
	DW	05H
	DB	00H
	DB	08H
	DW	057H
	DB	00H
	DB	08H
	DW	017H
	DB	040H
	DB	08H
	DW	00H
	DB	013H
	DB	07H
	DW	033H
	DB	00H
	DB	08H
	DW	077H
	DB	00H
	DB	08H
	DW	037H
	DB	00H
	DB	09H
	DW	0cfH
	DB	011H
	DB	07H
	DW	0fH
	DB	00H
	DB	08H
	DW	067H
	DB	00H
	DB	08H
	DW	027H
	DB	00H
	DB	09H
	DW	0afH
	DB	00H
	DB	08H
	DW	07H
	DB	00H
	DB	08H
	DW	087H
	DB	00H
	DB	08H
	DW	047H
	DB	00H
	DB	09H
	DW	0efH
	DB	010H
	DB	07H
	DW	09H
	DB	00H
	DB	08H
	DW	05fH
	DB	00H
	DB	08H
	DW	01fH
	DB	00H
	DB	09H
	DW	09fH
	DB	014H
	DB	07H
	DW	063H
	DB	00H
	DB	08H
	DW	07fH
	DB	00H
	DB	08H
	DW	03fH
	DB	00H
	DB	09H
	DW	0dfH
	DB	012H
	DB	07H
	DW	01bH
	DB	00H
	DB	08H
	DW	06fH
	DB	00H
	DB	08H
	DW	02fH
	DB	00H
	DB	09H
	DW	0bfH
	DB	00H
	DB	08H
	DW	0fH
	DB	00H
	DB	08H
	DW	08fH
	DB	00H
	DB	08H
	DW	04fH
	DB	00H
	DB	09H
	DW	0ffH
?distfix@?1??fixedtables@@9@9 DB 010H			; `fixedtables'::`2'::distfix
	DB	05H
	DW	01H
	DB	017H
	DB	05H
	DW	0101H
	DB	013H
	DB	05H
	DW	011H
	DB	01bH
	DB	05H
	DW	01001H
	DB	011H
	DB	05H
	DW	05H
	DB	019H
	DB	05H
	DW	0401H
	DB	015H
	DB	05H
	DW	041H
	DB	01dH
	DB	05H
	DW	04001H
	DB	010H
	DB	05H
	DW	03H
	DB	018H
	DB	05H
	DW	0201H
	DB	014H
	DB	05H
	DW	021H
	DB	01cH
	DB	05H
	DW	02001H
	DB	012H
	DB	05H
	DW	09H
	DB	01aH
	DB	05H
	DW	0801H
	DB	016H
	DB	05H
	DW	081H
	DB	040H
	DB	05H
	DW	00H
	DB	010H
	DB	05H
	DW	02H
	DB	017H
	DB	05H
	DW	0181H
	DB	013H
	DB	05H
	DW	019H
	DB	01bH
	DB	05H
	DW	01801H
	DB	011H
	DB	05H
	DW	07H
	DB	019H
	DB	05H
	DW	0601H
	DB	015H
	DB	05H
	DW	061H
	DB	01dH
	DB	05H
	DW	06001H
	DB	010H
	DB	05H
	DW	04H
	DB	018H
	DB	05H
	DW	0301H
	DB	014H
	DB	05H
	DW	031H
	DB	01cH
	DB	05H
	DW	03001H
	DB	012H
	DB	05H
	DW	0dH
	DB	01aH
	DB	05H
	DW	0c01H
	DB	016H
	DB	05H
	DW	0c1H
	DB	040H
	DB	05H
	DW	00H
?order@?1??inflate@@9@9 DW 010H				; `inflate'::`2'::order
	DW	011H
	DW	012H
	DW	00H
	DW	08H
	DW	07H
	DW	09H
	DW	06H
	DW	0aH
	DW	05H
	DW	0bH
	DW	04H
	DW	0cH
	DW	03H
	DW	0dH
	DW	02H
	DW	0eH
	DW	01H
	DW	0fH
PUBLIC	_inflateCopy@8
; Function compile flags: /Odtp
; File y:\asl\software\video_compressor\vid_reader\zlib\zlib-1.2.3\inflate.c
;	COMDAT _inflateCopy@8
_TEXT	SEGMENT
_state$ = -16						; size = 4
_copy$ = -12						; size = 4
_wsize$ = -8						; size = 4
_window$ = -4						; size = 4
_dest$ = 8						; size = 4
_source$ = 12						; size = 4
_inflateCopy@8 PROC					; COMDAT

; 1326 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 10	 sub	 esp, 16			; 00000010H

; 1327 :     struct inflate_state FAR *state;
; 1328 :     struct inflate_state FAR *copy;
; 1329 :     unsigned char FAR *window;
; 1330 :     unsigned wsize;
; 1331 : 
; 1332 :     /* check input */
; 1333 :     if (dest == Z_NULL || source == Z_NULL || source->state == Z_NULL ||
; 1334 :         source->zalloc == (alloc_func)0 || source->zfree == (free_func)0)

  00006	83 7d 08 00	 cmp	 DWORD PTR _dest$[ebp], 0
  0000a	74 21		 je	 SHORT $LN6@inflateCop
  0000c	83 7d 0c 00	 cmp	 DWORD PTR _source$[ebp], 0
  00010	74 1b		 je	 SHORT $LN6@inflateCop
  00012	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  00015	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00019	74 12		 je	 SHORT $LN6@inflateCop
  0001b	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  0001e	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00022	74 09		 je	 SHORT $LN6@inflateCop
  00024	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00027	83 7a 24 00	 cmp	 DWORD PTR [edx+36], 0
  0002b	75 0a		 jne	 SHORT $LN7@inflateCop
$LN6@inflateCop:

; 1335 :         return Z_STREAM_ERROR;

  0002d	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00032	e9 85 01 00 00	 jmp	 $LN8@inflateCop
$LN7@inflateCop:

; 1336 :     state = (struct inflate_state FAR *)source->state;

  00037	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0003a	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0003d	89 4d f0	 mov	 DWORD PTR _state$[ebp], ecx

; 1337 : 
; 1338 :     /* allocate space */
; 1339 :     copy = (struct inflate_state FAR *)
; 1340 :            ZALLOC(source, 1, sizeof(struct inflate_state));

  00040	68 30 25 00 00	 push	 9520			; 00002530H
  00045	6a 01		 push	 1
  00047	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  0004a	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  0004d	50		 push	 eax
  0004e	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  00051	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00054	ff d2		 call	 edx
  00056	83 c4 0c	 add	 esp, 12			; 0000000cH
  00059	89 45 f4	 mov	 DWORD PTR _copy$[ebp], eax

; 1341 :     if (copy == Z_NULL) return Z_MEM_ERROR;

  0005c	83 7d f4 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00060	75 0a		 jne	 SHORT $LN5@inflateCop
  00062	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  00067	e9 50 01 00 00	 jmp	 $LN8@inflateCop
$LN5@inflateCop:

; 1342 :     window = Z_NULL;

  0006c	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _window$[ebp], 0

; 1343 :     if (state->window != Z_NULL) {

  00073	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00076	83 78 34 00	 cmp	 DWORD PTR [eax+52], 0
  0007a	74 4b		 je	 SHORT $LN4@inflateCop

; 1344 :         window = (unsigned char FAR *)
; 1345 :                  ZALLOC(source, 1U << state->wbits, sizeof(unsigned char));

  0007c	6a 01		 push	 1
  0007e	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  00081	ba 01 00 00 00	 mov	 edx, 1
  00086	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00089	d3 e2		 shl	 edx, cl
  0008b	52		 push	 edx
  0008c	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  0008f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00092	51		 push	 ecx
  00093	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  00096	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00099	ff d0		 call	 eax
  0009b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0009e	89 45 fc	 mov	 DWORD PTR _window$[ebp], eax

; 1346 :         if (window == Z_NULL) {

  000a1	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  000a5	75 20		 jne	 SHORT $LN4@inflateCop

; 1347 :             ZFREE(source, copy);

  000a7	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  000aa	51		 push	 ecx
  000ab	8b 55 0c	 mov	 edx, DWORD PTR _source$[ebp]
  000ae	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000b1	50		 push	 eax
  000b2	8b 4d 0c	 mov	 ecx, DWORD PTR _source$[ebp]
  000b5	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  000b8	ff d2		 call	 edx
  000ba	83 c4 08	 add	 esp, 8

; 1348 :             return Z_MEM_ERROR;

  000bd	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000c2	e9 f5 00 00 00	 jmp	 $LN8@inflateCop
$LN4@inflateCop:

; 1349 :         }
; 1350 :     }
; 1351 : 
; 1352 :     /* copy state */
; 1353 :     zmemcpy(dest, source, sizeof(z_stream));

  000c7	6a 38		 push	 56			; 00000038H
  000c9	8b 45 0c	 mov	 eax, DWORD PTR _source$[ebp]
  000cc	50		 push	 eax
  000cd	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  000d0	51		 push	 ecx
  000d1	e8 00 00 00 00	 call	 _memcpy
  000d6	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1354 :     zmemcpy(copy, state, sizeof(struct inflate_state));

  000d9	68 30 25 00 00	 push	 9520			; 00002530H
  000de	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000e1	52		 push	 edx
  000e2	8b 45 f4	 mov	 eax, DWORD PTR _copy$[ebp]
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _memcpy
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1355 :     if (state->lencode >= state->codes &&
; 1356 :         state->lencode <= state->codes + ENOUGH - 1) {

  000ee	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  000f1	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  000f7	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  000fa	39 4a 4c	 cmp	 DWORD PTR [edx+76], ecx
  000fd	72 58		 jb	 SHORT $LN2@inflateCop
  000ff	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00102	05 2c 25 00 00	 add	 eax, 9516		; 0000252cH
  00107	8b 4d f0	 mov	 ecx, DWORD PTR _state$[ebp]
  0010a	39 41 4c	 cmp	 DWORD PTR [ecx+76], eax
  0010d	77 48		 ja	 SHORT $LN2@inflateCop

; 1357 :         copy->lencode = copy->codes + (state->lencode - state->codes);

  0010f	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00112	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00118	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0011b	8b 48 4c	 mov	 ecx, DWORD PTR [eax+76]
  0011e	2b ca		 sub	 ecx, edx
  00120	c1 f9 02	 sar	 ecx, 2
  00123	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  00126	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  0012d	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00130	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 1358 :         copy->distcode = copy->codes + (state->distcode - state->codes);

  00133	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00136	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  0013c	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  0013f	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  00142	2b ca		 sub	 ecx, edx
  00144	c1 f9 02	 sar	 ecx, 2
  00147	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0014a	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  00151	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00154	89 41 50	 mov	 DWORD PTR [ecx+80], eax
$LN2@inflateCop:

; 1359 :     }
; 1360 :     copy->next = copy->codes + (state->next - state->codes);

  00157	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  0015a	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00160	8b 45 f0	 mov	 eax, DWORD PTR _state$[ebp]
  00163	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  00166	2b ca		 sub	 ecx, edx
  00168	c1 f9 02	 sar	 ecx, 2
  0016b	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  0016e	8d 84 8a 30 05
	00 00		 lea	 eax, DWORD PTR [edx+ecx*4+1328]
  00175	8b 4d f4	 mov	 ecx, DWORD PTR _copy$[ebp]
  00178	89 41 6c	 mov	 DWORD PTR [ecx+108], eax

; 1361 :     if (window != Z_NULL) {

  0017b	83 7d fc 00	 cmp	 DWORD PTR _window$[ebp], 0
  0017f	74 27		 je	 SHORT $LN1@inflateCop

; 1362 :         wsize = 1U << state->wbits;

  00181	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00184	b8 01 00 00 00	 mov	 eax, 1
  00189	8b 4a 24	 mov	 ecx, DWORD PTR [edx+36]
  0018c	d3 e0		 shl	 eax, cl
  0018e	89 45 f8	 mov	 DWORD PTR _wsize$[ebp], eax

; 1363 :         zmemcpy(window, state->window, wsize);

  00191	8b 4d f8	 mov	 ecx, DWORD PTR _wsize$[ebp]
  00194	51		 push	 ecx
  00195	8b 55 f0	 mov	 edx, DWORD PTR _state$[ebp]
  00198	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0019b	50		 push	 eax
  0019c	8b 4d fc	 mov	 ecx, DWORD PTR _window$[ebp]
  0019f	51		 push	 ecx
  001a0	e8 00 00 00 00	 call	 _memcpy
  001a5	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN1@inflateCop:

; 1364 :     }
; 1365 :     copy->window = window;

  001a8	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001ab	8b 45 fc	 mov	 eax, DWORD PTR _window$[ebp]
  001ae	89 42 34	 mov	 DWORD PTR [edx+52], eax

; 1366 :     dest->state = (struct internal_state FAR *)copy;

  001b1	8b 4d 08	 mov	 ecx, DWORD PTR _dest$[ebp]
  001b4	8b 55 f4	 mov	 edx, DWORD PTR _copy$[ebp]
  001b7	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 1367 :     return Z_OK;

  001ba	33 c0		 xor	 eax, eax
$LN8@inflateCop:

; 1368 : }

  001bc	8b e5		 mov	 esp, ebp
  001be	5d		 pop	 ebp
  001bf	c2 08 00	 ret	 8
_inflateCopy@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateSyncPoint@4
; Function compile flags: /Odtp
;	COMDAT _inflateSyncPoint@4
_TEXT	SEGMENT
tv71 = -8						; size = 4
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSyncPoint@4 PROC				; COMDAT

; 1315 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1316 :     struct inflate_state FAR *state;
; 1317 : 
; 1318 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN1@inflateSyn
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 07		 jne	 SHORT $LN2@inflateSyn
$LN1@inflateSyn:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	eb 2d		 jmp	 SHORT $LN3@inflateSyn
$LN2@inflateSyn:

; 1319 :     state = (struct inflate_state FAR *)strm->state;

  0001c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0001f	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00022	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 1320 :     return state->mode == STORED && state->bits == 0;

  00025	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00028	83 38 0d	 cmp	 DWORD PTR [eax], 13	; 0000000dH
  0002b	75 12		 jne	 SHORT $LN5@inflateSyn
  0002d	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00030	83 79 3c 00	 cmp	 DWORD PTR [ecx+60], 0
  00034	75 09		 jne	 SHORT $LN5@inflateSyn
  00036	c7 45 f8 01 00
	00 00		 mov	 DWORD PTR tv71[ebp], 1
  0003d	eb 07		 jmp	 SHORT $LN6@inflateSyn
$LN5@inflateSyn:
  0003f	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR tv71[ebp], 0
$LN6@inflateSyn:
  00046	8b 45 f8	 mov	 eax, DWORD PTR tv71[ebp]
$LN3@inflateSyn:

; 1321 : }

  00049	8b e5		 mov	 esp, ebp
  0004b	5d		 pop	 ebp
  0004c	c2 04 00	 ret	 4
_inflateSyncPoint@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _syncsearch
_TEXT	SEGMENT
_got$ = -8						; size = 4
_next$ = -4						; size = 4
_have$ = 8						; size = 4
_buf$ = 12						; size = 4
_len$ = 16						; size = 4
_syncsearch PROC					; COMDAT

; 1243 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1244 :     unsigned got;
; 1245 :     unsigned next;
; 1246 : 
; 1247 :     got = *have;

  00006	8b 45 08	 mov	 eax, DWORD PTR _have$[ebp]
  00009	8b 08		 mov	 ecx, DWORD PTR [eax]
  0000b	89 4d f8	 mov	 DWORD PTR _got$[ebp], ecx

; 1248 :     next = 0;

  0000e	c7 45 fc 00 00
	00 00		 mov	 DWORD PTR _next$[ebp], 0
$LN6@syncsearch:

; 1249 :     while (next < len && got < 4) {

  00015	8b 55 fc	 mov	 edx, DWORD PTR _next$[ebp]
  00018	3b 55 10	 cmp	 edx, DWORD PTR _len$[ebp]
  0001b	73 5c		 jae	 SHORT $LN5@syncsearch
  0001d	83 7d f8 04	 cmp	 DWORD PTR _got$[ebp], 4
  00021	73 56		 jae	 SHORT $LN5@syncsearch

; 1250 :         if ((int)(buf[next]) == (got < 2 ? 0 : 0xff))

  00023	8b 45 0c	 mov	 eax, DWORD PTR _buf$[ebp]
  00026	03 45 fc	 add	 eax, DWORD PTR _next$[ebp]
  00029	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  0002c	83 7d f8 02	 cmp	 DWORD PTR _got$[ebp], 2
  00030	1b d2		 sbb	 edx, edx
  00032	81 e2 01 ff ff
	ff		 and	 edx, -255		; ffffff01H
  00038	81 c2 ff 00 00
	00		 add	 edx, 255		; 000000ffH
  0003e	3b ca		 cmp	 ecx, edx
  00040	75 0b		 jne	 SHORT $LN4@syncsearch

; 1251 :             got++;

  00042	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  00045	83 c0 01	 add	 eax, 1
  00048	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
  0004b	eb 21		 jmp	 SHORT $LN3@syncsearch
$LN4@syncsearch:

; 1252 :         else if (buf[next])

  0004d	8b 4d 0c	 mov	 ecx, DWORD PTR _buf$[ebp]
  00050	03 4d fc	 add	 ecx, DWORD PTR _next$[ebp]
  00053	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00056	85 d2		 test	 edx, edx
  00058	74 09		 je	 SHORT $LN2@syncsearch

; 1253 :             got = 0;

  0005a	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _got$[ebp], 0

; 1254 :         else

  00061	eb 0b		 jmp	 SHORT $LN3@syncsearch
$LN2@syncsearch:

; 1255 :             got = 4 - got;

  00063	b8 04 00 00 00	 mov	 eax, 4
  00068	2b 45 f8	 sub	 eax, DWORD PTR _got$[ebp]
  0006b	89 45 f8	 mov	 DWORD PTR _got$[ebp], eax
$LN3@syncsearch:

; 1256 :         next++;

  0006e	8b 4d fc	 mov	 ecx, DWORD PTR _next$[ebp]
  00071	83 c1 01	 add	 ecx, 1
  00074	89 4d fc	 mov	 DWORD PTR _next$[ebp], ecx

; 1257 :     }

  00077	eb 9c		 jmp	 SHORT $LN6@syncsearch
$LN5@syncsearch:

; 1258 :     *have = got;

  00079	8b 55 08	 mov	 edx, DWORD PTR _have$[ebp]
  0007c	8b 45 f8	 mov	 eax, DWORD PTR _got$[ebp]
  0007f	89 02		 mov	 DWORD PTR [edx], eax

; 1259 :     return next;

  00081	8b 45 fc	 mov	 eax, DWORD PTR _next$[ebp]

; 1260 : }

  00084	8b e5		 mov	 esp, ebp
  00086	5d		 pop	 ebp
  00087	c3		 ret	 0
_syncsearch ENDP
_TEXT	ENDS
PUBLIC	_inflateEnd@4
; Function compile flags: /Odtp
;	COMDAT _inflateEnd@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateEnd@4 PROC					; COMDAT

; 1157 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 1158 :     struct inflate_state FAR *state;
; 1159 :     if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 12		 je	 SHORT $LN2@inflateEnd
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	74 09		 je	 SHORT $LN2@inflateEnd
  00013	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00016	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  0001a	75 07		 jne	 SHORT $LN3@inflateEnd
$LN2@inflateEnd:

; 1160 :         return Z_STREAM_ERROR;

  0001c	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00021	eb 50		 jmp	 SHORT $LN4@inflateEnd
$LN3@inflateEnd:

; 1161 :     state = (struct inflate_state FAR *)strm->state;

  00023	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00026	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00029	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 1162 :     if (state->window != Z_NULL) ZFREE(strm, state->window);

  0002c	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0002f	83 79 34 00	 cmp	 DWORD PTR [ecx+52], 0
  00033	74 19		 je	 SHORT $LN1@inflateEnd
  00035	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00038	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  0003b	50		 push	 eax
  0003c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003f	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  00042	52		 push	 edx
  00043	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00046	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00049	ff d1		 call	 ecx
  0004b	83 c4 08	 add	 esp, 8
$LN1@inflateEnd:

; 1163 :     ZFREE(strm, strm->state);

  0004e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00051	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00054	50		 push	 eax
  00055	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00058	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  0005b	52		 push	 edx
  0005c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005f	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00062	ff d1		 call	 ecx
  00064	83 c4 08	 add	 esp, 8

; 1164 :     strm->state = Z_NULL;

  00067	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0006a	c7 42 1c 00 00
	00 00		 mov	 DWORD PTR [edx+28], 0

; 1165 :     Tracev((stderr, "inflate: end\n"));
; 1166 :     return Z_OK;

  00071	33 c0		 xor	 eax, eax
$LN4@inflateEnd:

; 1167 : }

  00073	8b e5		 mov	 esp, ebp
  00075	5d		 pop	 ebp
  00076	c2 04 00	 ret	 4
_inflateEnd@4 ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _updatewindow
_TEXT	SEGMENT
_state$ = -12						; size = 4
_copy$ = -8						; size = 4
_dist$ = -4						; size = 4
_strm$ = 8						; size = 4
_out$ = 12						; size = 4
_updatewindow PROC					; COMDAT

; 326  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 0c	 sub	 esp, 12			; 0000000cH

; 327  :     struct inflate_state FAR *state;
; 328  :     unsigned copy, dist;
; 329  : 
; 330  :     state = (struct inflate_state FAR *)strm->state;

  00006	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00009	8b 48 1c	 mov	 ecx, DWORD PTR [eax+28]
  0000c	89 4d f4	 mov	 DWORD PTR _state$[ebp], ecx

; 331  : 
; 332  :     /* if it hasn't been done already, allocate space for the window */
; 333  :     if (state->window == Z_NULL) {

  0000f	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00012	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00016	75 3b		 jne	 SHORT $LN10@updatewind

; 334  :         state->window = (unsigned char FAR *)
; 335  :                         ZALLOC(strm, 1U << state->wbits,
; 336  :                                sizeof(unsigned char));

  00018	6a 01		 push	 1
  0001a	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0001d	ba 01 00 00 00	 mov	 edx, 1
  00022	8b 48 24	 mov	 ecx, DWORD PTR [eax+36]
  00025	d3 e2		 shl	 edx, cl
  00027	52		 push	 edx
  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  0002e	51		 push	 ecx
  0002f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00032	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00035	ff d0		 call	 eax
  00037	83 c4 0c	 add	 esp, 12			; 0000000cH
  0003a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0003d	89 41 34	 mov	 DWORD PTR [ecx+52], eax

; 337  :         if (state->window == Z_NULL) return 1;

  00040	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00043	83 7a 34 00	 cmp	 DWORD PTR [edx+52], 0
  00047	75 0a		 jne	 SHORT $LN10@updatewind
  00049	b8 01 00 00 00	 mov	 eax, 1
  0004e	e9 4a 01 00 00	 jmp	 $LN11@updatewind
$LN10@updatewind:

; 338  :     }
; 339  : 
; 340  :     /* if window not in use yet, initialize */
; 341  :     if (state->wsize == 0) {

  00053	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00056	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  0005a	75 27		 jne	 SHORT $LN8@updatewind

; 342  :         state->wsize = 1U << state->wbits;

  0005c	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0005f	ba 01 00 00 00	 mov	 edx, 1
  00064	8b 49 24	 mov	 ecx, DWORD PTR [ecx+36]
  00067	d3 e2		 shl	 edx, cl
  00069	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  0006c	89 50 28	 mov	 DWORD PTR [eax+40], edx

; 343  :         state->write = 0;

  0006f	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00072	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0

; 344  :         state->whave = 0;

  00079	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0007c	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0
$LN8@updatewind:

; 345  :     }
; 346  : 
; 347  :     /* copy state->wsize or less output bytes into the circular window */
; 348  :     copy = out - strm->avail_out;

  00083	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00086	8b 4d 0c	 mov	 ecx, DWORD PTR _out$[ebp]
  00089	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  0008c	89 4d f8	 mov	 DWORD PTR _copy$[ebp], ecx

; 349  :     if (copy >= state->wsize) {

  0008f	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00092	8b 45 f8	 mov	 eax, DWORD PTR _copy$[ebp]
  00095	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  00098	72 3e		 jb	 SHORT $LN7@updatewind

; 350  :         zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);

  0009a	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0009d	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000a0	52		 push	 edx
  000a1	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000a4	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000a7	8b 50 0c	 mov	 edx, DWORD PTR [eax+12]
  000aa	2b 51 28	 sub	 edx, DWORD PTR [ecx+40]
  000ad	52		 push	 edx
  000ae	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000b1	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000b4	51		 push	 ecx
  000b5	e8 00 00 00 00	 call	 _memcpy
  000ba	83 c4 0c	 add	 esp, 12			; 0000000cH

; 351  :         state->write = 0;

  000bd	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  000c0	c7 42 30 00 00
	00 00		 mov	 DWORD PTR [edx+48], 0

; 352  :         state->whave = state->wsize;

  000c7	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000ca	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000cd	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  000d0	89 50 2c	 mov	 DWORD PTR [eax+44], edx

; 353  :     }
; 354  :     else {

  000d3	e9 c3 00 00 00	 jmp	 $LN6@updatewind
$LN7@updatewind:

; 355  :         dist = state->wsize - state->write;

  000d8	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  000db	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  000de	8b 50 28	 mov	 edx, DWORD PTR [eax+40]
  000e1	2b 51 30	 sub	 edx, DWORD PTR [ecx+48]
  000e4	89 55 fc	 mov	 DWORD PTR _dist$[ebp], edx

; 356  :         if (dist > copy) dist = copy;

  000e7	8b 45 fc	 mov	 eax, DWORD PTR _dist$[ebp]
  000ea	3b 45 f8	 cmp	 eax, DWORD PTR _copy$[ebp]
  000ed	76 06		 jbe	 SHORT $LN5@updatewind
  000ef	8b 4d f8	 mov	 ecx, DWORD PTR _copy$[ebp]
  000f2	89 4d fc	 mov	 DWORD PTR _dist$[ebp], ecx
$LN5@updatewind:

; 357  :         zmemcpy(state->window + state->write, strm->next_out - copy, dist);

  000f5	8b 55 fc	 mov	 edx, DWORD PTR _dist$[ebp]
  000f8	52		 push	 edx
  000f9	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000fc	8b 48 0c	 mov	 ecx, DWORD PTR [eax+12]
  000ff	2b 4d f8	 sub	 ecx, DWORD PTR _copy$[ebp]
  00102	51		 push	 ecx
  00103	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00106	8b 42 34	 mov	 eax, DWORD PTR [edx+52]
  00109	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0010c	03 41 30	 add	 eax, DWORD PTR [ecx+48]
  0010f	50		 push	 eax
  00110	e8 00 00 00 00	 call	 _memcpy
  00115	83 c4 0c	 add	 esp, 12			; 0000000cH

; 358  :         copy -= dist;

  00118	8b 55 f8	 mov	 edx, DWORD PTR _copy$[ebp]
  0011b	2b 55 fc	 sub	 edx, DWORD PTR _dist$[ebp]
  0011e	89 55 f8	 mov	 DWORD PTR _copy$[ebp], edx

; 359  :         if (copy) {

  00121	74 34		 je	 SHORT $LN4@updatewind

; 360  :             zmemcpy(state->window, strm->next_out - copy, copy);

  00123	8b 45 f8	 mov	 eax, DWORD PTR _copy$[ebp]
  00126	50		 push	 eax
  00127	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0012a	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  0012d	2b 55 f8	 sub	 edx, DWORD PTR _copy$[ebp]
  00130	52		 push	 edx
  00131	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00134	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  00137	51		 push	 ecx
  00138	e8 00 00 00 00	 call	 _memcpy
  0013d	83 c4 0c	 add	 esp, 12			; 0000000cH

; 361  :             state->write = copy;

  00140	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00143	8b 45 f8	 mov	 eax, DWORD PTR _copy$[ebp]
  00146	89 42 30	 mov	 DWORD PTR [edx+48], eax

; 362  :             state->whave = state->wsize;

  00149	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0014c	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0014f	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  00152	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 363  :         }
; 364  :         else {

  00155	eb 44		 jmp	 SHORT $LN6@updatewind
$LN4@updatewind:

; 365  :             state->write += dist;

  00157	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  0015a	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  0015d	03 55 fc	 add	 edx, DWORD PTR _dist$[ebp]
  00160	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00163	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 366  :             if (state->write == state->wsize) state->write = 0;

  00166	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00169	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0016c	8b 41 30	 mov	 eax, DWORD PTR [ecx+48]
  0016f	3b 42 28	 cmp	 eax, DWORD PTR [edx+40]
  00172	75 0a		 jne	 SHORT $LN2@updatewind
  00174	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00177	c7 41 30 00 00
	00 00		 mov	 DWORD PTR [ecx+48], 0
$LN2@updatewind:

; 367  :             if (state->whave < state->wsize) state->whave += dist;

  0017e	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  00181	8b 45 f4	 mov	 eax, DWORD PTR _state$[ebp]
  00184	8b 4a 2c	 mov	 ecx, DWORD PTR [edx+44]
  00187	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  0018a	73 0f		 jae	 SHORT $LN6@updatewind
  0018c	8b 55 f4	 mov	 edx, DWORD PTR _state$[ebp]
  0018f	8b 42 2c	 mov	 eax, DWORD PTR [edx+44]
  00192	03 45 fc	 add	 eax, DWORD PTR _dist$[ebp]
  00195	8b 4d f4	 mov	 ecx, DWORD PTR _state$[ebp]
  00198	89 41 2c	 mov	 DWORD PTR [ecx+44], eax
$LN6@updatewind:

; 368  :         }
; 369  :     }
; 370  :     return 0;

  0019b	33 c0		 xor	 eax, eax
$LN11@updatewind:

; 371  : }

  0019d	8b e5		 mov	 esp, ebp
  0019f	5d		 pop	 ebp
  001a0	c3		 ret	 0
_updatewindow ENDP
; Function compile flags: /Odtp
_TEXT	ENDS
;	COMDAT _fixedtables
_TEXT	SEGMENT
_state$ = 8						; size = 4
_fixedtables PROC					; COMDAT

; 207  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 208  : #ifdef BUILDFIXED
; 209  :     static int virgin = 1;
; 210  :     static code *lenfix, *distfix;
; 211  :     static code fixed[544];
; 212  : 
; 213  :     /* build fixed huffman tables if first call (may not be thread safe) */
; 214  :     if (virgin) {
; 215  :         unsigned sym, bits;
; 216  :         static code *next;
; 217  : 
; 218  :         /* literal/length table */
; 219  :         sym = 0;
; 220  :         while (sym < 144) state->lens[sym++] = 8;
; 221  :         while (sym < 256) state->lens[sym++] = 9;
; 222  :         while (sym < 280) state->lens[sym++] = 7;
; 223  :         while (sym < 288) state->lens[sym++] = 8;
; 224  :         next = fixed;
; 225  :         lenfix = next;
; 226  :         bits = 9;
; 227  :         inflate_table(LENS, state->lens, 288, &(next), &(bits), state->work);
; 228  : 
; 229  :         /* distance table */
; 230  :         sym = 0;
; 231  :         while (sym < 32) state->lens[sym++] = 5;
; 232  :         distfix = next;
; 233  :         bits = 5;
; 234  :         inflate_table(DISTS, state->lens, 32, &(next), &(bits), state->work);
; 235  : 
; 236  :         /* do this just once */
; 237  :         virgin = 0;
; 238  :     }
; 239  : #else /* !BUILDFIXED */
; 240  : #   include "inffixed.h"
; 241  : #endif /* BUILDFIXED */
; 242  :     state->lencode = lenfix;

  00003	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00006	c7 40 4c 00 00
	00 00		 mov	 DWORD PTR [eax+76], OFFSET ?lenfix@?1??fixedtables@@9@9

; 243  :     state->lenbits = 9;

  0000d	8b 4d 08	 mov	 ecx, DWORD PTR _state$[ebp]
  00010	c7 41 54 09 00
	00 00		 mov	 DWORD PTR [ecx+84], 9

; 244  :     state->distcode = distfix;

  00017	8b 55 08	 mov	 edx, DWORD PTR _state$[ebp]
  0001a	c7 42 50 00 00
	00 00		 mov	 DWORD PTR [edx+80], OFFSET ?distfix@?1??fixedtables@@9@9

; 245  :     state->distbits = 5;

  00021	8b 45 08	 mov	 eax, DWORD PTR _state$[ebp]
  00024	c7 40 58 05 00
	00 00		 mov	 DWORD PTR [eax+88], 5

; 246  : }

  0002b	5d		 pop	 ebp
  0002c	c3		 ret	 0
_fixedtables ENDP
_TEXT	ENDS
PUBLIC	_inflateReset@4
; Function compile flags: /Odtp
;	COMDAT _inflateReset@4
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateReset@4 PROC					; COMDAT

; 105  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 106  :     struct inflate_state FAR *state;
; 107  : 
; 108  :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00004	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  00008	74 09		 je	 SHORT $LN1@inflateRes
  0000a	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000d	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00011	75 0a		 jne	 SHORT $LN2@inflateRes
$LN1@inflateRes:
  00013	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00018	e9 c6 00 00 00	 jmp	 $LN3@inflateRes
$LN2@inflateRes:

; 109  :     state = (struct inflate_state FAR *)strm->state;

  0001d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00020	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00023	89 55 fc	 mov	 DWORD PTR _state$[ebp], edx

; 110  :     strm->total_in = strm->total_out = state->total = 0;

  00026	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00029	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
  00030	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00033	c7 41 14 00 00
	00 00		 mov	 DWORD PTR [ecx+20], 0
  0003a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0003d	c7 42 08 00 00
	00 00		 mov	 DWORD PTR [edx+8], 0

; 111  :     strm->msg = Z_NULL;

  00044	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00047	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 112  :     strm->adler = 1;        /* to support ill-conceived Java test suite */

  0004e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00051	c7 41 30 01 00
	00 00		 mov	 DWORD PTR [ecx+48], 1

; 113  :     state->mode = HEAD;

  00058	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  0005b	c7 02 00 00 00
	00		 mov	 DWORD PTR [edx], 0

; 114  :     state->last = 0;

  00061	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00064	c7 40 04 00 00
	00 00		 mov	 DWORD PTR [eax+4], 0

; 115  :     state->havedict = 0;

  0006b	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0006e	c7 41 0c 00 00
	00 00		 mov	 DWORD PTR [ecx+12], 0

; 116  :     state->dmax = 32768U;

  00075	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00078	c7 42 14 00 80
	00 00		 mov	 DWORD PTR [edx+20], 32768 ; 00008000H

; 117  :     state->head = Z_NULL;

  0007f	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  00082	c7 40 20 00 00
	00 00		 mov	 DWORD PTR [eax+32], 0

; 118  :     state->wsize = 0;

  00089	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  0008c	c7 41 28 00 00
	00 00		 mov	 DWORD PTR [ecx+40], 0

; 119  :     state->whave = 0;

  00093	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00096	c7 42 2c 00 00
	00 00		 mov	 DWORD PTR [edx+44], 0

; 120  :     state->write = 0;

  0009d	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000a0	c7 40 30 00 00
	00 00		 mov	 DWORD PTR [eax+48], 0

; 121  :     state->hold = 0;

  000a7	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000aa	c7 41 38 00 00
	00 00		 mov	 DWORD PTR [ecx+56], 0

; 122  :     state->bits = 0;

  000b1	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000b4	c7 42 3c 00 00
	00 00		 mov	 DWORD PTR [edx+60], 0

; 123  :     state->lencode = state->distcode = state->next = state->codes;

  000bb	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000be	05 30 05 00 00	 add	 eax, 1328		; 00000530H
  000c3	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  000c6	89 41 6c	 mov	 DWORD PTR [ecx+108], eax
  000c9	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000cc	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000cf	8b 48 6c	 mov	 ecx, DWORD PTR [eax+108]
  000d2	89 4a 50	 mov	 DWORD PTR [edx+80], ecx
  000d5	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000d8	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000db	8b 48 50	 mov	 ecx, DWORD PTR [eax+80]
  000de	89 4a 4c	 mov	 DWORD PTR [edx+76], ecx

; 124  :     Tracev((stderr, "inflate: reset\n"));
; 125  :     return Z_OK;

  000e1	33 c0		 xor	 eax, eax
$LN3@inflateRes:

; 126  : }

  000e3	8b e5		 mov	 esp, ebp
  000e5	5d		 pop	 ebp
  000e6	c2 04 00	 ret	 4
_inflateReset@4 ENDP
PUBLIC	_inflateSync@4
; Function compile flags: /Odtp
;	COMDAT _inflateSync@4
_TEXT	SEGMENT
_state$ = -20						; size = 4
_out$ = -16						; size = 4
_buf$ = -12						; size = 4
_len$ = -8						; size = 4
_in$ = -4						; size = 4
_strm$ = 8						; size = 4
_inflateSync@4 PROC					; COMDAT

; 1264 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 14	 sub	 esp, 20			; 00000014H

; 1265 :     unsigned len;               /* number of bytes to look at or looked at */
; 1266 :     unsigned long in, out;      /* temporary to save total_in and total_out */
; 1267 :     unsigned char buf[4];       /* to restore bit buffer to byte string */
; 1268 :     struct inflate_state FAR *state;
; 1269 : 
; 1270 :     /* check parameters */
; 1271 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN6@inflateSyn@2
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN7@inflateSyn@2
$LN6@inflateSyn@2:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 61 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN7@inflateSyn@2:

; 1272 :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 ec	 mov	 DWORD PTR _state$[ebp], edx

; 1273 :     if (strm->avail_in == 0 && state->bits < 8) return Z_BUF_ERROR;

  00028	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0002b	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002f	75 13		 jne	 SHORT $LN5@inflateSyn@2
  00031	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	83 79 3c 08	 cmp	 DWORD PTR [ecx+60], 8
  00038	73 0a		 jae	 SHORT $LN5@inflateSyn@2
  0003a	b8 fb ff ff ff	 mov	 eax, -5			; fffffffbH
  0003f	e9 3c 01 00 00	 jmp	 $LN8@inflateSyn@2
$LN5@inflateSyn@2:

; 1274 : 
; 1275 :     /* if first time, start search in bit buffer */
; 1276 :     if (state->mode != SYNC) {

  00044	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00047	83 3a 1d	 cmp	 DWORD PTR [edx], 29	; 0000001dH
  0004a	0f 84 9e 00 00
	00		 je	 $LN4@inflateSyn@2

; 1277 :         state->mode = SYNC;

  00050	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00053	c7 00 1d 00 00
	00		 mov	 DWORD PTR [eax], 29	; 0000001dH

; 1278 :         state->hold <<= state->bits & 7;

  00059	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0005c	8b 49 3c	 mov	 ecx, DWORD PTR [ecx+60]
  0005f	83 e1 07	 and	 ecx, 7
  00062	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00065	8b 42 38	 mov	 eax, DWORD PTR [edx+56]
  00068	d3 e0		 shl	 eax, cl
  0006a	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0006d	89 41 38	 mov	 DWORD PTR [ecx+56], eax

; 1279 :         state->bits -= state->bits & 7;

  00070	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  00073	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  00076	83 e0 07	 and	 eax, 7
  00079	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  0007c	8b 51 3c	 mov	 edx, DWORD PTR [ecx+60]
  0007f	2b d0		 sub	 edx, eax
  00081	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  00084	89 50 3c	 mov	 DWORD PTR [eax+60], edx

; 1280 :         len = 0;

  00087	c7 45 f8 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0
$LN3@inflateSyn@2:

; 1281 :         while (state->bits >= 8) {

  0008e	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00091	83 79 3c 08	 cmp	 DWORD PTR [ecx+60], 8
  00095	72 36		 jb	 SHORT $LN2@inflateSyn@2

; 1282 :             buf[len++] = (unsigned char)(state->hold);

  00097	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  0009a	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0009d	8a 48 38	 mov	 cl, BYTE PTR [eax+56]
  000a0	88 4c 15 f4	 mov	 BYTE PTR _buf$[ebp+edx], cl
  000a4	8b 55 f8	 mov	 edx, DWORD PTR _len$[ebp]
  000a7	83 c2 01	 add	 edx, 1
  000aa	89 55 f8	 mov	 DWORD PTR _len$[ebp], edx

; 1283 :             state->hold >>= 8;

  000ad	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000b0	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  000b3	c1 e9 08	 shr	 ecx, 8
  000b6	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000b9	89 4a 38	 mov	 DWORD PTR [edx+56], ecx

; 1284 :             state->bits -= 8;

  000bc	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000bf	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  000c2	83 e9 08	 sub	 ecx, 8
  000c5	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000c8	89 4a 3c	 mov	 DWORD PTR [edx+60], ecx

; 1285 :         }

  000cb	eb c1		 jmp	 SHORT $LN3@inflateSyn@2
$LN2@inflateSyn@2:

; 1286 :         state->have = 0;

  000cd	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000d0	c7 40 68 00 00
	00 00		 mov	 DWORD PTR [eax+104], 0

; 1287 :         syncsearch(&(state->have), buf, len);

  000d7	8b 4d f8	 mov	 ecx, DWORD PTR _len$[ebp]
  000da	51		 push	 ecx
  000db	8d 55 f4	 lea	 edx, DWORD PTR _buf$[ebp]
  000de	52		 push	 edx
  000df	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  000e2	83 c0 68	 add	 eax, 104		; 00000068H
  000e5	50		 push	 eax
  000e6	e8 00 00 00 00	 call	 _syncsearch
  000eb	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN4@inflateSyn@2:

; 1288 :     }
; 1289 : 
; 1290 :     /* search available input */
; 1291 :     len = syncsearch(&(state->have), strm->next_in, strm->avail_in);

  000ee	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000f1	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  000f4	52		 push	 edx
  000f5	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000f8	8b 08		 mov	 ecx, DWORD PTR [eax]
  000fa	51		 push	 ecx
  000fb	8b 55 ec	 mov	 edx, DWORD PTR _state$[ebp]
  000fe	83 c2 68	 add	 edx, 104		; 00000068H
  00101	52		 push	 edx
  00102	e8 00 00 00 00	 call	 _syncsearch
  00107	83 c4 0c	 add	 esp, 12			; 0000000cH
  0010a	89 45 f8	 mov	 DWORD PTR _len$[ebp], eax

; 1292 :     strm->avail_in -= len;

  0010d	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00110	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  00113	2b 4d f8	 sub	 ecx, DWORD PTR _len$[ebp]
  00116	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00119	89 4a 04	 mov	 DWORD PTR [edx+4], ecx

; 1293 :     strm->next_in += len;

  0011c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0011f	8b 08		 mov	 ecx, DWORD PTR [eax]
  00121	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00124	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00127	89 0a		 mov	 DWORD PTR [edx], ecx

; 1294 :     strm->total_in += len;

  00129	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0012c	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  0012f	03 4d f8	 add	 ecx, DWORD PTR _len$[ebp]
  00132	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00135	89 4a 08	 mov	 DWORD PTR [edx+8], ecx

; 1295 : 
; 1296 :     /* return no joy or set up to restart inflate() on a new block */
; 1297 :     if (state->have != 4) return Z_DATA_ERROR;

  00138	8b 45 ec	 mov	 eax, DWORD PTR _state$[ebp]
  0013b	83 78 68 04	 cmp	 DWORD PTR [eax+104], 4
  0013f	74 07		 je	 SHORT $LN1@inflateSyn@2
  00141	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  00146	eb 38		 jmp	 SHORT $LN8@inflateSyn@2
$LN1@inflateSyn@2:

; 1298 :     in = strm->total_in;  out = strm->total_out;

  00148	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0014b	8b 51 08	 mov	 edx, DWORD PTR [ecx+8]
  0014e	89 55 fc	 mov	 DWORD PTR _in$[ebp], edx
  00151	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00154	8b 48 14	 mov	 ecx, DWORD PTR [eax+20]
  00157	89 4d f0	 mov	 DWORD PTR _out$[ebp], ecx

; 1299 :     inflateReset(strm);

  0015a	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0015d	52		 push	 edx
  0015e	e8 00 00 00 00	 call	 _inflateReset@4

; 1300 :     strm->total_in = in;  strm->total_out = out;

  00163	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00166	8b 4d fc	 mov	 ecx, DWORD PTR _in$[ebp]
  00169	89 48 08	 mov	 DWORD PTR [eax+8], ecx
  0016c	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0016f	8b 45 f0	 mov	 eax, DWORD PTR _out$[ebp]
  00172	89 42 14	 mov	 DWORD PTR [edx+20], eax

; 1301 :     state->mode = TYPE;

  00175	8b 4d ec	 mov	 ecx, DWORD PTR _state$[ebp]
  00178	c7 01 0b 00 00
	00		 mov	 DWORD PTR [ecx], 11	; 0000000bH

; 1302 :     return Z_OK;

  0017e	33 c0		 xor	 eax, eax
$LN8@inflateSyn@2:

; 1303 : }

  00180	8b e5		 mov	 esp, ebp
  00182	5d		 pop	 ebp
  00183	c2 04 00	 ret	 4
_inflateSync@4 ENDP
_TEXT	ENDS
PUBLIC	_inflateSetDictionary@12
; Function compile flags: /Odtp
;	COMDAT _inflateSetDictionary@12
_TEXT	SEGMENT
_state$ = -8						; size = 4
_id$ = -4						; size = 4
_strm$ = 8						; size = 4
_dictionary$ = 12					; size = 4
_dictLength$ = 16					; size = 4
_inflateSetDictionary@12 PROC				; COMDAT

; 1173 : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 08	 sub	 esp, 8

; 1174 :     struct inflate_state FAR *state;
; 1175 :     unsigned long id;
; 1176 : 
; 1177 :     /* check state */
; 1178 :     if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 09		 je	 SHORT $LN7@inflateSet
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	75 0a		 jne	 SHORT $LN8@inflateSet
$LN7@inflateSet:
  00015	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0001a	e9 fb 00 00 00	 jmp	 $LN9@inflateSet
$LN8@inflateSet:

; 1179 :     state = (struct inflate_state FAR *)strm->state;

  0001f	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00022	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  00025	89 55 f8	 mov	 DWORD PTR _state$[ebp], edx

; 1180 :     if (state->wrap != 0 && state->mode != DICT)

  00028	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  0002b	83 78 08 00	 cmp	 DWORD PTR [eax+8], 0
  0002f	74 12		 je	 SHORT $LN6@inflateSet
  00031	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00034	83 39 0a	 cmp	 DWORD PTR [ecx], 10	; 0000000aH
  00037	74 0a		 je	 SHORT $LN6@inflateSet

; 1181 :         return Z_STREAM_ERROR;

  00039	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  0003e	e9 d7 00 00 00	 jmp	 $LN9@inflateSet
$LN6@inflateSet:

; 1182 : 
; 1183 :     /* check for correct dictionary id */
; 1184 :     if (state->mode == DICT) {

  00043	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  00046	83 3a 0a	 cmp	 DWORD PTR [edx], 10	; 0000000aH
  00049	75 37		 jne	 SHORT $LN5@inflateSet

; 1185 :         id = adler32(0L, Z_NULL, 0);

  0004b	6a 00		 push	 0
  0004d	6a 00		 push	 0
  0004f	6a 00		 push	 0
  00051	e8 00 00 00 00	 call	 _adler32@12
  00056	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 1186 :         id = adler32(id, dictionary, dictLength);

  00059	8b 45 10	 mov	 eax, DWORD PTR _dictLength$[ebp]
  0005c	50		 push	 eax
  0005d	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  00060	51		 push	 ecx
  00061	8b 55 fc	 mov	 edx, DWORD PTR _id$[ebp]
  00064	52		 push	 edx
  00065	e8 00 00 00 00	 call	 _adler32@12
  0006a	89 45 fc	 mov	 DWORD PTR _id$[ebp], eax

; 1187 :         if (id != state->check)

  0006d	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00070	8b 4d fc	 mov	 ecx, DWORD PTR _id$[ebp]
  00073	3b 48 18	 cmp	 ecx, DWORD PTR [eax+24]
  00076	74 0a		 je	 SHORT $LN5@inflateSet

; 1188 :             return Z_DATA_ERROR;

  00078	b8 fd ff ff ff	 mov	 eax, -3			; fffffffdH
  0007d	e9 98 00 00 00	 jmp	 $LN9@inflateSet
$LN5@inflateSet:

; 1189 :     }
; 1190 : 
; 1191 :     /* copy dictionary to window */
; 1192 :     if (updatewindow(strm, strm->avail_out)) {

  00082	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00085	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00088	50		 push	 eax
  00089	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0008c	51		 push	 ecx
  0008d	e8 00 00 00 00	 call	 _updatewindow
  00092	83 c4 08	 add	 esp, 8
  00095	85 c0		 test	 eax, eax
  00097	74 10		 je	 SHORT $LN3@inflateSet

; 1193 :         state->mode = MEM;

  00099	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  0009c	c7 02 1c 00 00
	00		 mov	 DWORD PTR [edx], 28	; 0000001cH

; 1194 :         return Z_MEM_ERROR;

  000a2	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  000a7	eb 71		 jmp	 SHORT $LN9@inflateSet
$LN3@inflateSet:

; 1195 :     }
; 1196 :     if (dictLength > state->wsize) {

  000a9	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000ac	8b 4d 10	 mov	 ecx, DWORD PTR _dictLength$[ebp]
  000af	3b 48 28	 cmp	 ecx, DWORD PTR [eax+40]
  000b2	76 31		 jbe	 SHORT $LN2@inflateSet

; 1197 :         zmemcpy(state->window, dictionary + dictLength - state->wsize,
; 1198 :                 state->wsize);

  000b4	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000b7	8b 42 28	 mov	 eax, DWORD PTR [edx+40]
  000ba	50		 push	 eax
  000bb	8b 4d 0c	 mov	 ecx, DWORD PTR _dictionary$[ebp]
  000be	03 4d 10	 add	 ecx, DWORD PTR _dictLength$[ebp]
  000c1	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000c4	2b 4a 28	 sub	 ecx, DWORD PTR [edx+40]
  000c7	51		 push	 ecx
  000c8	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000cb	8b 48 34	 mov	 ecx, DWORD PTR [eax+52]
  000ce	51		 push	 ecx
  000cf	e8 00 00 00 00	 call	 _memcpy
  000d4	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1199 :         state->whave = state->wsize;

  000d7	8b 55 f8	 mov	 edx, DWORD PTR _state$[ebp]
  000da	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000dd	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000e0	89 4a 2c	 mov	 DWORD PTR [edx+44], ecx

; 1200 :     }
; 1201 :     else {

  000e3	eb 29		 jmp	 SHORT $LN1@inflateSet
$LN2@inflateSet:

; 1202 :         zmemcpy(state->window + state->wsize - dictLength, dictionary,
; 1203 :                 dictLength);

  000e5	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  000e8	52		 push	 edx
  000e9	8b 45 0c	 mov	 eax, DWORD PTR _dictionary$[ebp]
  000ec	50		 push	 eax
  000ed	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  000f0	8b 51 34	 mov	 edx, DWORD PTR [ecx+52]
  000f3	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  000f6	03 50 28	 add	 edx, DWORD PTR [eax+40]
  000f9	2b 55 10	 sub	 edx, DWORD PTR _dictLength$[ebp]
  000fc	52		 push	 edx
  000fd	e8 00 00 00 00	 call	 _memcpy
  00102	83 c4 0c	 add	 esp, 12			; 0000000cH

; 1204 :         state->whave = dictLength;

  00105	8b 4d f8	 mov	 ecx, DWORD PTR _state$[ebp]
  00108	8b 55 10	 mov	 edx, DWORD PTR _dictLength$[ebp]
  0010b	89 51 2c	 mov	 DWORD PTR [ecx+44], edx
$LN1@inflateSet:

; 1205 :     }
; 1206 :     state->havedict = 1;

  0010e	8b 45 f8	 mov	 eax, DWORD PTR _state$[ebp]
  00111	c7 40 0c 01 00
	00 00		 mov	 DWORD PTR [eax+12], 1

; 1207 :     Tracev((stderr, "inflate:   dictionary set\n"));
; 1208 :     return Z_OK;

  00118	33 c0		 xor	 eax, eax
$LN9@inflateSet:

; 1209 : }

  0011a	8b e5		 mov	 esp, ebp
  0011c	5d		 pop	 ebp
  0011d	c2 0c 00	 ret	 12			; 0000000cH
_inflateSetDictionary@12 ENDP
_TEXT	ENDS
PUBLIC	_inflate@8
; Function compile flags: /Odtp
;	COMDAT _inflate@8
_TEXT	SEGMENT
tv1278 = -88						; size = 4
tv1205 = -84						; size = 4
tv1191 = -80						; size = 4
tv552 = -76						; size = 4
tv348 = -72						; size = 4
tv80 = -68						; size = 4
_state$ = -64						; size = 4
_out$ = -60						; size = 4
_from$ = -56						; size = 4
_copy$ = -52						; size = 4
_this$ = -48						; size = 4
_hbuf$ = -44						; size = 4
_hold$ = -40						; size = 4
_ret$ = -36						; size = 4
_next$ = -32						; size = 4
_left$ = -28						; size = 4
_bits$ = -24						; size = 4
_len$ = -20						; size = 4
_in$ = -16						; size = 4
_have$ = -12						; size = 4
_last$ = -8						; size = 4
_put$ = -4						; size = 4
_strm$ = 8						; size = 4
_flush$ = 12						; size = 4
_inflate@8 PROC						; COMDAT

; 557  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	83 ec 58	 sub	 esp, 88			; 00000058H

; 558  :     struct inflate_state FAR *state;
; 559  :     unsigned char FAR *next;    /* next input */
; 560  :     unsigned char FAR *put;     /* next output */
; 561  :     unsigned have, left;        /* available input and output */
; 562  :     unsigned long hold;         /* bit buffer */
; 563  :     unsigned bits;              /* bits in bit buffer */
; 564  :     unsigned in, out;           /* save starting available input and output */
; 565  :     unsigned copy;              /* number of stored or match bytes to copy */
; 566  :     unsigned char FAR *from;    /* where to copy match bytes from */
; 567  :     code this;                  /* current decoding table entry */
; 568  :     code last;                  /* parent table entry */
; 569  :     unsigned len;               /* length to copy for repeats, bits to drop */
; 570  :     int ret;                    /* return code */
; 571  : #ifdef GUNZIP
; 572  :     unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
; 573  : #endif
; 574  :     static const unsigned short order[19] = /* permutation of code lengths */
; 575  :         {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};
; 576  : 
; 577  :     if (strm == Z_NULL || strm->state == Z_NULL || strm->next_out == Z_NULL ||
; 578  :         (strm->next_in == Z_NULL && strm->avail_in != 0))

  00006	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0000a	74 23		 je	 SHORT $LN492@inflate
  0000c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0000f	83 78 1c 00	 cmp	 DWORD PTR [eax+28], 0
  00013	74 1a		 je	 SHORT $LN492@inflate
  00015	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00018	83 79 0c 00	 cmp	 DWORD PTR [ecx+12], 0
  0001c	74 11		 je	 SHORT $LN492@inflate
  0001e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00021	83 3a 00	 cmp	 DWORD PTR [edx], 0
  00024	75 13		 jne	 SHORT $LN493@inflate
  00026	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00029	83 78 04 00	 cmp	 DWORD PTR [eax+4], 0
  0002d	74 0a		 je	 SHORT $LN493@inflate
$LN492@inflate:

; 579  :         return Z_STREAM_ERROR;

  0002f	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00034	e9 15 1e 00 00	 jmp	 $LN494@inflate
$LN493@inflate:

; 580  : 
; 581  :     state = (struct inflate_state FAR *)strm->state;

  00039	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0003c	8b 51 1c	 mov	 edx, DWORD PTR [ecx+28]
  0003f	89 55 c0	 mov	 DWORD PTR _state$[ebp], edx

; 582  :     if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */

  00042	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00045	83 38 0b	 cmp	 DWORD PTR [eax], 11	; 0000000bH
  00048	75 09		 jne	 SHORT $LN490@inflate
  0004a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0004d	c7 01 0c 00 00
	00		 mov	 DWORD PTR [ecx], 12	; 0000000cH
$LN490@inflate:

; 583  :     LOAD();

  00053	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00056	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  00059	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  0005c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0005f	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00062	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx
  00065	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00068	8b 08		 mov	 ecx, DWORD PTR [eax]
  0006a	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  0006d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00070	8b 42 04	 mov	 eax, DWORD PTR [edx+4]
  00073	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00076	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00079	8b 51 38	 mov	 edx, DWORD PTR [ecx+56]
  0007c	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0007f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00082	8b 48 3c	 mov	 ecx, DWORD PTR [eax+60]
  00085	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00088	33 d2		 xor	 edx, edx
  0008a	75 c7		 jne	 SHORT $LN490@inflate

; 584  :     in = have;

  0008c	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  0008f	89 45 f0	 mov	 DWORD PTR _in$[ebp], eax

; 585  :     out = left;

  00092	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00095	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 586  :     ret = Z_OK;

  00098	c7 45 dc 00 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 0
$LN487@inflate:

; 587  :     for (;;)
; 588  :         switch (state->mode) {

  0009f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000a2	8b 02		 mov	 eax, DWORD PTR [edx]
  000a4	89 45 bc	 mov	 DWORD PTR tv80[ebp], eax
  000a7	83 7d bc 1c	 cmp	 DWORD PTR tv80[ebp], 28	; 0000001cH
  000ab	0f 87 14 1c 00
	00		 ja	 $LN11@inflate
  000b1	8b 4d bc	 mov	 ecx, DWORD PTR tv80[ebp]
  000b4	ff 24 8d 00 00
	00 00		 jmp	 DWORD PTR $LN504@inflate[ecx*4]
$LN483@inflate:

; 589  :         case HEAD:
; 590  :             if (state->wrap == 0) {

  000bb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  000be	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  000c2	75 0e		 jne	 SHORT $LN478@inflate

; 591  :                 state->mode = TYPEDO;

  000c4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  000c7	c7 00 0c 00 00
	00		 mov	 DWORD PTR [eax], 12	; 0000000cH

; 592  :                 break;

  000cd	e9 fd 1b 00 00	 jmp	 $LN484@inflate
$LN478@inflate:

; 593  :             }
; 594  :             NEEDBITS(16);

  000d2	83 7d e8 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  000d6	73 3d		 jae	 SHORT $LN480@inflate
$LN476@inflate:
  000d8	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  000dc	75 05		 jne	 SHORT $LN473@inflate
  000de	e9 f1 1b 00 00	 jmp	 $inf_leave$77660
$LN473@inflate:
  000e3	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  000e6	83 e9 01	 sub	 ecx, 1
  000e9	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  000ec	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  000ef	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  000f2	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  000f5	d3 e0		 shl	 eax, cl
  000f7	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  000fa	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  000fd	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00100	83 c1 01	 add	 ecx, 1
  00103	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00106	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00109	83 c2 08	 add	 edx, 8
  0010c	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0010f	33 c0		 xor	 eax, eax
  00111	75 c5		 jne	 SHORT $LN476@inflate
  00113	eb bd		 jmp	 SHORT $LN478@inflate
$LN480@inflate:
  00115	33 c9		 xor	 ecx, ecx
  00117	75 b9		 jne	 SHORT $LN478@inflate

; 595  : #ifdef GUNZIP
; 596  :             if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */

  00119	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0011c	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  0011f	83 e0 02	 and	 eax, 2
  00122	74 65		 je	 SHORT $LN472@inflate
  00124	81 7d d8 1f 8b
	00 00		 cmp	 DWORD PTR _hold$[ebp], 35615 ; 00008b1fH
  0012b	75 5c		 jne	 SHORT $LN472@inflate

; 597  :                 state->check = crc32(0L, Z_NULL, 0);

  0012d	6a 00		 push	 0
  0012f	6a 00		 push	 0
  00131	6a 00		 push	 0
  00133	e8 00 00 00 00	 call	 _crc32@12
  00138	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0013b	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN471@inflate:

; 598  :                 CRC2(state->check, hold);

  0013e	8a 55 d8	 mov	 dl, BYTE PTR _hold$[ebp]
  00141	88 55 d4	 mov	 BYTE PTR _hbuf$[ebp], dl
  00144	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00147	c1 e8 08	 shr	 eax, 8
  0014a	88 45 d5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  0014d	6a 02		 push	 2
  0014f	8d 4d d4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  00152	51		 push	 ecx
  00153	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00156	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00159	50		 push	 eax
  0015a	e8 00 00 00 00	 call	 _crc32@12
  0015f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00162	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00165	33 d2		 xor	 edx, edx
  00167	75 d5		 jne	 SHORT $LN471@inflate
$LN468@inflate:

; 599  :                 INITBITS();

  00169	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00170	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00177	33 c0		 xor	 eax, eax
  00179	75 ee		 jne	 SHORT $LN468@inflate

; 600  :                 state->mode = FLAGS;

  0017b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0017e	c7 01 01 00 00
	00		 mov	 DWORD PTR [ecx], 1

; 601  :                 break;

  00184	e9 46 1b 00 00	 jmp	 $LN484@inflate
$LN472@inflate:

; 602  :             }
; 603  :             state->flags = 0;           /* expect zlib header */

  00189	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0018c	c7 42 10 00 00
	00 00		 mov	 DWORD PTR [edx+16], 0

; 604  :             if (state->head != Z_NULL)

  00193	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00196	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0019a	74 0d		 je	 SHORT $LN465@inflate

; 605  :                 state->head->done = -1;

  0019c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0019f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  001a2	c7 42 30 ff ff
	ff ff		 mov	 DWORD PTR [edx+48], -1
$LN465@inflate:

; 606  :             if (!(state->wrap & 1) ||   /* check if zlib header allowed */
; 607  : #else
; 608  :             if (
; 609  : #endif
; 610  :                 ((BITS(8) << 8) + (hold >> 8)) % 31) {

  001a9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001ac	8b 48 08	 mov	 ecx, DWORD PTR [eax+8]
  001af	83 e1 01	 and	 ecx, 1
  001b2	74 20		 je	 SHORT $LN463@inflate
  001b4	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  001b7	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  001bc	c1 e0 08	 shl	 eax, 8
  001bf	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  001c2	c1 ea 08	 shr	 edx, 8
  001c5	03 c2		 add	 eax, edx
  001c7	33 d2		 xor	 edx, edx
  001c9	b9 1f 00 00 00	 mov	 ecx, 31			; 0000001fH
  001ce	f7 f1		 div	 ecx
  001d0	85 d2		 test	 edx, edx
  001d2	74 18		 je	 SHORT $LN464@inflate
$LN463@inflate:

; 611  :                 strm->msg = (char *)"incorrect header check";

  001d4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001d7	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BH@LIBMMIGA@incorrect?5header?5check?$AA@

; 612  :                 state->mode = BAD;

  001de	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  001e1	c7 00 1b 00 00
	00		 mov	 DWORD PTR [eax], 27	; 0000001bH

; 613  :                 break;

  001e7	e9 e3 1a 00 00	 jmp	 $LN484@inflate
$LN464@inflate:

; 614  :             }
; 615  :             if (BITS(4) != Z_DEFLATED) {

  001ec	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  001ef	83 e1 0f	 and	 ecx, 15			; 0000000fH
  001f2	83 f9 08	 cmp	 ecx, 8
  001f5	74 18		 je	 SHORT $LN461@inflate

; 616  :                 strm->msg = (char *)"unknown compression method";

  001f7	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  001fa	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 617  :                 state->mode = BAD;

  00201	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00204	c7 00 1b 00 00
	00		 mov	 DWORD PTR [eax], 27	; 0000001bH

; 618  :                 break;

  0020a	e9 c0 1a 00 00	 jmp	 $LN484@inflate
$LN461@inflate:

; 619  :             }
; 620  :             DROPBITS(4);

  0020f	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00212	c1 e9 04	 shr	 ecx, 4
  00215	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00218	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0021b	83 ea 04	 sub	 edx, 4
  0021e	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00221	33 c0		 xor	 eax, eax
  00223	75 ea		 jne	 SHORT $LN461@inflate

; 621  :             len = BITS(4) + 8;

  00225	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00228	83 e1 0f	 and	 ecx, 15			; 0000000fH
  0022b	83 c1 08	 add	 ecx, 8
  0022e	89 4d ec	 mov	 DWORD PTR _len$[ebp], ecx

; 622  :             if (len > state->wbits) {

  00231	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00234	8b 45 ec	 mov	 eax, DWORD PTR _len$[ebp]
  00237	3b 42 24	 cmp	 eax, DWORD PTR [edx+36]
  0023a	76 18		 jbe	 SHORT $LN458@inflate

; 623  :                 strm->msg = (char *)"invalid window size";

  0023c	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0023f	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BE@EMOGCLGO@invalid?5window?5size?$AA@

; 624  :                 state->mode = BAD;

  00246	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00249	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 625  :                 break;

  0024f	e9 7b 1a 00 00	 jmp	 $LN484@inflate
$LN458@inflate:

; 626  :             }
; 627  :             state->dmax = 1U << len;

  00254	b8 01 00 00 00	 mov	 eax, 1
  00259	8b 4d ec	 mov	 ecx, DWORD PTR _len$[ebp]
  0025c	d3 e0		 shl	 eax, cl
  0025e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00261	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 628  :             Tracev((stderr, "inflate:   zlib header ok\n"));
; 629  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00264	6a 00		 push	 0
  00266	6a 00		 push	 0
  00268	6a 00		 push	 0
  0026a	e8 00 00 00 00	 call	 _adler32@12
  0026f	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00272	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00275	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00278	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0027b	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  0027e	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 630  :             state->mode = hold & 0x200 ? DICTID : TYPE;

  00281	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00284	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00289	f7 d8		 neg	 eax
  0028b	1b c0		 sbb	 eax, eax
  0028d	83 e0 fe	 and	 eax, -2			; fffffffeH
  00290	83 c0 0b	 add	 eax, 11			; 0000000bH
  00293	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00296	89 01		 mov	 DWORD PTR [ecx], eax
$LN457@inflate:

; 631  :             INITBITS();

  00298	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0029f	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  002a6	33 d2		 xor	 edx, edx
  002a8	75 ee		 jne	 SHORT $LN457@inflate

; 632  :             break;

  002aa	e9 20 1a 00 00	 jmp	 $LN484@inflate
$LN450@inflate:

; 633  : #ifdef GUNZIP
; 634  :         case FLAGS:
; 635  :             NEEDBITS(16);

  002af	83 7d e8 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  002b3	73 3d		 jae	 SHORT $LN452@inflate
$LN448@inflate:
  002b5	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  002b9	75 05		 jne	 SHORT $LN445@inflate
  002bb	e9 14 1a 00 00	 jmp	 $inf_leave$77660
$LN445@inflate:
  002c0	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  002c3	83 e8 01	 sub	 eax, 1
  002c6	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  002c9	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  002cc	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  002cf	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  002d2	d3 e2		 shl	 edx, cl
  002d4	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  002d7	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  002da	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  002dd	83 c0 01	 add	 eax, 1
  002e0	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  002e3	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  002e6	83 c1 08	 add	 ecx, 8
  002e9	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  002ec	33 d2		 xor	 edx, edx
  002ee	75 c5		 jne	 SHORT $LN448@inflate
  002f0	eb bd		 jmp	 SHORT $LN450@inflate
$LN452@inflate:
  002f2	33 c0		 xor	 eax, eax
  002f4	75 b9		 jne	 SHORT $LN450@inflate

; 636  :             state->flags = (int)(hold);

  002f6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  002f9	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  002fc	89 51 10	 mov	 DWORD PTR [ecx+16], edx

; 637  :             if ((state->flags & 0xff) != Z_DEFLATED) {

  002ff	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00302	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00305	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  0030b	83 f9 08	 cmp	 ecx, 8
  0030e	74 18		 je	 SHORT $LN444@inflate

; 638  :                 strm->msg = (char *)"unknown compression method";

  00310	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00313	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BL@IHKGDAEE@unknown?5compression?5method?$AA@

; 639  :                 state->mode = BAD;

  0031a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0031d	c7 00 1b 00 00
	00		 mov	 DWORD PTR [eax], 27	; 0000001bH

; 640  :                 break;

  00323	e9 a7 19 00 00	 jmp	 $LN484@inflate
$LN444@inflate:

; 641  :             }
; 642  :             if (state->flags & 0xe000) {

  00328	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0032b	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  0032e	81 e2 00 e0 00
	00		 and	 edx, 57344		; 0000e000H
  00334	74 18		 je	 SHORT $LN443@inflate

; 643  :                 strm->msg = (char *)"unknown header flags set";

  00336	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00339	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@BLBBCOMO@unknown?5header?5flags?5set?$AA@

; 644  :                 state->mode = BAD;

  00340	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00343	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH

; 645  :                 break;

  00349	e9 81 19 00 00	 jmp	 $LN484@inflate
$LN443@inflate:

; 646  :             }
; 647  :             if (state->head != Z_NULL)

  0034e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00351	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00355	74 11		 je	 SHORT $LN442@inflate

; 648  :                 state->head->text = (int)((hold >> 8) & 1);

  00357	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0035a	c1 e8 08	 shr	 eax, 8
  0035d	83 e0 01	 and	 eax, 1
  00360	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00363	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00366	89 02		 mov	 DWORD PTR [edx], eax
$LN442@inflate:

; 649  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  00368	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0036b	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  0036e	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  00374	74 2b		 je	 SHORT $LN437@inflate
$LN440@inflate:
  00376	8a 55 d8	 mov	 dl, BYTE PTR _hold$[ebp]
  00379	88 55 d4	 mov	 BYTE PTR _hbuf$[ebp], dl
  0037c	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0037f	c1 e8 08	 shr	 eax, 8
  00382	88 45 d5	 mov	 BYTE PTR _hbuf$[ebp+1], al
  00385	6a 02		 push	 2
  00387	8d 4d d4	 lea	 ecx, DWORD PTR _hbuf$[ebp]
  0038a	51		 push	 ecx
  0038b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0038e	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00391	50		 push	 eax
  00392	e8 00 00 00 00	 call	 _crc32@12
  00397	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0039a	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  0039d	33 d2		 xor	 edx, edx
  0039f	75 d5		 jne	 SHORT $LN440@inflate
$LN437@inflate:

; 650  :             INITBITS();

  003a1	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  003a8	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  003af	33 c0		 xor	 eax, eax
  003b1	75 ee		 jne	 SHORT $LN437@inflate

; 651  :             state->mode = TIME;

  003b3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  003b6	c7 01 02 00 00
	00		 mov	 DWORD PTR [ecx], 2
$LN430@inflate:

; 652  :         case TIME:
; 653  :             NEEDBITS(32);

  003bc	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  003c0	73 3d		 jae	 SHORT $LN432@inflate
$LN428@inflate:
  003c2	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  003c6	75 05		 jne	 SHORT $LN425@inflate
  003c8	e9 07 19 00 00	 jmp	 $inf_leave$77660
$LN425@inflate:
  003cd	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  003d0	83 ea 01	 sub	 edx, 1
  003d3	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  003d6	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  003d9	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  003dc	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  003df	d3 e2		 shl	 edx, cl
  003e1	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  003e4	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  003e7	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  003ea	83 c0 01	 add	 eax, 1
  003ed	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  003f0	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  003f3	83 c1 08	 add	 ecx, 8
  003f6	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  003f9	33 d2		 xor	 edx, edx
  003fb	75 c5		 jne	 SHORT $LN428@inflate
  003fd	eb bd		 jmp	 SHORT $LN430@inflate
$LN432@inflate:
  003ff	33 c0		 xor	 eax, eax
  00401	75 b9		 jne	 SHORT $LN430@inflate

; 654  :             if (state->head != Z_NULL)

  00403	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00406	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0040a	74 0c		 je	 SHORT $LN424@inflate

; 655  :                 state->head->time = hold;

  0040c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0040f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00412	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00415	89 48 04	 mov	 DWORD PTR [eax+4], ecx
$LN424@inflate:

; 656  :             if (state->flags & 0x0200) CRC4(state->check, hold);

  00418	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0041b	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  0041e	25 00 02 00 00	 and	 eax, 512		; 00000200H
  00423	74 3d		 je	 SHORT $LN419@inflate
$LN422@inflate:
  00425	8a 4d d8	 mov	 cl, BYTE PTR _hold$[ebp]
  00428	88 4d d4	 mov	 BYTE PTR _hbuf$[ebp], cl
  0042b	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0042e	c1 ea 08	 shr	 edx, 8
  00431	88 55 d5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  00434	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00437	c1 e8 10	 shr	 eax, 16			; 00000010H
  0043a	88 45 d6	 mov	 BYTE PTR _hbuf$[ebp+2], al
  0043d	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00440	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00443	88 4d d7	 mov	 BYTE PTR _hbuf$[ebp+3], cl
  00446	6a 04		 push	 4
  00448	8d 55 d4	 lea	 edx, DWORD PTR _hbuf$[ebp]
  0044b	52		 push	 edx
  0044c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0044f	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  00452	51		 push	 ecx
  00453	e8 00 00 00 00	 call	 _crc32@12
  00458	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0045b	89 42 18	 mov	 DWORD PTR [edx+24], eax
  0045e	33 c0		 xor	 eax, eax
  00460	75 c3		 jne	 SHORT $LN422@inflate
$LN419@inflate:

; 657  :             INITBITS();

  00462	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00469	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00470	33 c9		 xor	 ecx, ecx
  00472	75 ee		 jne	 SHORT $LN419@inflate

; 658  :             state->mode = OS;

  00474	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00477	c7 02 03 00 00
	00		 mov	 DWORD PTR [edx], 3
$LN412@inflate:

; 659  :         case OS:
; 660  :             NEEDBITS(16);

  0047d	83 7d e8 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00481	73 3d		 jae	 SHORT $LN414@inflate
$LN410@inflate:
  00483	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00487	75 05		 jne	 SHORT $LN407@inflate
  00489	e9 46 18 00 00	 jmp	 $inf_leave$77660
$LN407@inflate:
  0048e	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  00491	83 e8 01	 sub	 eax, 1
  00494	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00497	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0049a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0049d	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  004a0	d3 e2		 shl	 edx, cl
  004a2	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  004a5	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  004a8	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  004ab	83 c0 01	 add	 eax, 1
  004ae	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  004b1	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  004b4	83 c1 08	 add	 ecx, 8
  004b7	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  004ba	33 d2		 xor	 edx, edx
  004bc	75 c5		 jne	 SHORT $LN410@inflate
  004be	eb bd		 jmp	 SHORT $LN412@inflate
$LN414@inflate:
  004c0	33 c0		 xor	 eax, eax
  004c2	75 b9		 jne	 SHORT $LN412@inflate

; 661  :             if (state->head != Z_NULL) {

  004c4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  004c7	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  004cb	74 21		 je	 SHORT $LN406@inflate

; 662  :                 state->head->xflags = (int)(hold & 0xff);

  004cd	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  004d0	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  004d6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  004d9	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004dc	89 51 08	 mov	 DWORD PTR [ecx+8], edx

; 663  :                 state->head->os = (int)(hold >> 8);

  004df	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  004e2	c1 ea 08	 shr	 edx, 8
  004e5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  004e8	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  004eb	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
$LN406@inflate:

; 664  :             }
; 665  :             if (state->flags & 0x0200) CRC2(state->check, hold);

  004ee	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  004f1	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  004f4	25 00 02 00 00	 and	 eax, 512		; 00000200H
  004f9	74 2b		 je	 SHORT $LN401@inflate
$LN404@inflate:
  004fb	8a 4d d8	 mov	 cl, BYTE PTR _hold$[ebp]
  004fe	88 4d d4	 mov	 BYTE PTR _hbuf$[ebp], cl
  00501	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00504	c1 ea 08	 shr	 edx, 8
  00507	88 55 d5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  0050a	6a 02		 push	 2
  0050c	8d 45 d4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  0050f	50		 push	 eax
  00510	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00513	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00516	52		 push	 edx
  00517	e8 00 00 00 00	 call	 _crc32@12
  0051c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0051f	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  00522	33 d2		 xor	 edx, edx
  00524	75 d5		 jne	 SHORT $LN404@inflate
$LN401@inflate:

; 666  :             INITBITS();

  00526	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  0052d	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00534	33 c0		 xor	 eax, eax
  00536	75 ee		 jne	 SHORT $LN401@inflate

; 667  :             state->mode = EXLEN;

  00538	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0053b	c7 01 04 00 00
	00		 mov	 DWORD PTR [ecx], 4
$LN398@inflate:

; 668  :         case EXLEN:
; 669  :             if (state->flags & 0x0400) {

  00541	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00544	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00547	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0054c	0f 84 b1 00 00
	00		 je	 $LN397@inflate
$LN393@inflate:

; 670  :                 NEEDBITS(16);

  00552	83 7d e8 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00556	73 3d		 jae	 SHORT $LN395@inflate
$LN391@inflate:
  00558	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0055c	75 05		 jne	 SHORT $LN388@inflate
  0055e	e9 71 17 00 00	 jmp	 $inf_leave$77660
$LN388@inflate:
  00563	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00566	83 e9 01	 sub	 ecx, 1
  00569	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  0056c	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0056f	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00572	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00575	d3 e0		 shl	 eax, cl
  00577	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  0057a	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0057d	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00580	83 c1 01	 add	 ecx, 1
  00583	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00586	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00589	83 c2 08	 add	 edx, 8
  0058c	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0058f	33 c0		 xor	 eax, eax
  00591	75 c5		 jne	 SHORT $LN391@inflate
  00593	eb bd		 jmp	 SHORT $LN393@inflate
$LN395@inflate:
  00595	33 c9		 xor	 ecx, ecx
  00597	75 b9		 jne	 SHORT $LN393@inflate

; 671  :                 state->length = (unsigned)(hold);

  00599	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0059c	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0059f	89 42 40	 mov	 DWORD PTR [edx+64], eax

; 672  :                 if (state->head != Z_NULL)

  005a2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005a5	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  005a9	74 0c		 je	 SHORT $LN387@inflate

; 673  :                     state->head->extra_len = (unsigned)hold;

  005ab	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005ae	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  005b1	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  005b4	89 48 14	 mov	 DWORD PTR [eax+20], ecx
$LN387@inflate:

; 674  :                 if (state->flags & 0x0200) CRC2(state->check, hold);

  005b7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  005ba	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  005bd	25 00 02 00 00	 and	 eax, 512		; 00000200H
  005c2	74 2b		 je	 SHORT $LN382@inflate
$LN385@inflate:
  005c4	8a 4d d8	 mov	 cl, BYTE PTR _hold$[ebp]
  005c7	88 4d d4	 mov	 BYTE PTR _hbuf$[ebp], cl
  005ca	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  005cd	c1 ea 08	 shr	 edx, 8
  005d0	88 55 d5	 mov	 BYTE PTR _hbuf$[ebp+1], dl
  005d3	6a 02		 push	 2
  005d5	8d 45 d4	 lea	 eax, DWORD PTR _hbuf$[ebp]
  005d8	50		 push	 eax
  005d9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005dc	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  005df	52		 push	 edx
  005e0	e8 00 00 00 00	 call	 _crc32@12
  005e5	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  005e8	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  005eb	33 d2		 xor	 edx, edx
  005ed	75 d5		 jne	 SHORT $LN385@inflate
$LN382@inflate:

; 675  :                 INITBITS();

  005ef	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  005f6	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  005fd	33 c0		 xor	 eax, eax
  005ff	75 ee		 jne	 SHORT $LN382@inflate

; 676  :             }
; 677  :             else if (state->head != Z_NULL)

  00601	eb 16		 jmp	 SHORT $LN379@inflate
$LN397@inflate:
  00603	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00606	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0060a	74 0d		 je	 SHORT $LN379@inflate

; 678  :                 state->head->extra = Z_NULL;

  0060c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0060f	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00612	c7 40 10 00 00
	00 00		 mov	 DWORD PTR [eax+16], 0
$LN379@inflate:

; 679  :             state->mode = EXTRA;

  00619	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0061c	c7 01 05 00 00
	00		 mov	 DWORD PTR [ecx], 5
$LN377@inflate:

; 680  :         case EXTRA:
; 681  :             if (state->flags & 0x0400) {

  00622	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00625	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  00628	25 00 04 00 00	 and	 eax, 1024		; 00000400H
  0062d	0f 84 e4 00 00
	00		 je	 $LN376@inflate

; 682  :                 copy = state->length;

  00633	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00636	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00639	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 683  :                 if (copy > have) copy = have;

  0063c	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  0063f	3b 45 f4	 cmp	 eax, DWORD PTR _have$[ebp]
  00642	76 06		 jbe	 SHORT $LN375@inflate
  00644	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00647	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN375@inflate:

; 684  :                 if (copy) {

  0064a	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  0064e	0f 84 b5 00 00
	00		 je	 $LN374@inflate

; 685  :                     if (state->head != Z_NULL &&
; 686  :                         state->head->extra != Z_NULL) {

  00654	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00657	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0065b	74 63		 je	 SHORT $LN373@inflate
  0065d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00660	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00663	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  00667	74 57		 je	 SHORT $LN373@inflate

; 687  :                         len = state->head->extra_len - state->length;

  00669	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0066c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0066f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00672	8b 50 14	 mov	 edx, DWORD PTR [eax+20]
  00675	2b 51 40	 sub	 edx, DWORD PTR [ecx+64]
  00678	89 55 ec	 mov	 DWORD PTR _len$[ebp], edx

; 688  :                         zmemcpy(state->head->extra + len, next,
; 689  :                                 len + copy > state->head->extra_max ?
; 690  :                                 state->head->extra_max - len : copy);

  0067b	8b 45 ec	 mov	 eax, DWORD PTR _len$[ebp]
  0067e	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00681	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00684	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00687	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  0068a	76 11		 jbe	 SHORT $LN496@inflate
  0068c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0068f	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00692	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00695	2b 55 ec	 sub	 edx, DWORD PTR _len$[ebp]
  00698	89 55 b8	 mov	 DWORD PTR tv348[ebp], edx
  0069b	eb 06		 jmp	 SHORT $LN497@inflate
$LN496@inflate:
  0069d	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  006a0	89 45 b8	 mov	 DWORD PTR tv348[ebp], eax
$LN497@inflate:
  006a3	8b 4d b8	 mov	 ecx, DWORD PTR tv348[ebp]
  006a6	51		 push	 ecx
  006a7	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  006aa	52		 push	 edx
  006ab	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006ae	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  006b1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  006b4	03 55 ec	 add	 edx, DWORD PTR _len$[ebp]
  006b7	52		 push	 edx
  006b8	e8 00 00 00 00	 call	 _memcpy
  006bd	83 c4 0c	 add	 esp, 12			; 0000000cH
$LN373@inflate:

; 691  :                     }
; 692  :                     if (state->flags & 0x0200)

  006c0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  006c3	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  006c6	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  006cc	74 1a		 je	 SHORT $LN372@inflate

; 693  :                         state->check = crc32(state->check, next, copy);

  006ce	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  006d1	52		 push	 edx
  006d2	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  006d5	50		 push	 eax
  006d6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006d9	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  006dc	52		 push	 edx
  006dd	e8 00 00 00 00	 call	 _crc32@12
  006e2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006e5	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN372@inflate:

; 694  :                     have -= copy;

  006e8	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  006eb	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  006ee	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx

; 695  :                     next += copy;

  006f1	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  006f4	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  006f7	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax

; 696  :                     state->length -= copy;

  006fa	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  006fd	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00700	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  00703	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00706	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN374@inflate:

; 697  :                 }
; 698  :                 if (state->length) goto inf_leave;

  00709	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0070c	83 79 40 00	 cmp	 DWORD PTR [ecx+64], 0
  00710	74 05		 je	 SHORT $LN376@inflate
  00712	e9 bd 15 00 00	 jmp	 $inf_leave$77660
$LN376@inflate:

; 699  :             }
; 700  :             state->length = 0;

  00717	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0071a	c7 42 40 00 00
	00 00		 mov	 DWORD PTR [edx+64], 0

; 701  :             state->mode = NAME;

  00721	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00724	c7 00 06 00 00
	00		 mov	 DWORD PTR [eax], 6
$LN370@inflate:

; 702  :         case NAME:
; 703  :             if (state->flags & 0x0800) {

  0072a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0072d	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  00730	81 e2 00 08 00
	00		 and	 edx, 2048		; 00000800H
  00736	0f 84 c6 00 00
	00		 je	 $LN369@inflate

; 704  :                 if (have == 0) goto inf_leave;

  0073c	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00740	75 05		 jne	 SHORT $LN368@inflate
  00742	e9 8d 15 00 00	 jmp	 $inf_leave$77660
$LN368@inflate:

; 705  :                 copy = 0;

  00747	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN367@inflate:

; 706  :                 do {
; 707  :                     len = (unsigned)(next[copy++]);

  0074e	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00751	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  00754	0f b6 08	 movzx	 ecx, BYTE PTR [eax]
  00757	89 4d ec	 mov	 DWORD PTR _len$[ebp], ecx
  0075a	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  0075d	83 c2 01	 add	 edx, 1
  00760	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 708  :                     if (state->head != Z_NULL &&
; 709  :                             state->head->name != Z_NULL &&
; 710  :                             state->length < state->head->name_max)

  00763	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00766	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  0076a	74 41		 je	 SHORT $LN366@inflate
  0076c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0076f	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  00772	83 7a 1c 00	 cmp	 DWORD PTR [edx+28], 0
  00776	74 35		 je	 SHORT $LN366@inflate
  00778	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0077b	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  0077e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00781	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00784	3b 41 20	 cmp	 eax, DWORD PTR [ecx+32]
  00787	73 24		 jae	 SHORT $LN366@inflate

; 711  :                         state->head->name[state->length++] = len;

  00789	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0078c	8b 51 20	 mov	 edx, DWORD PTR [ecx+32]
  0078f	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  00792	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00795	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00798	8a 4d ec	 mov	 cl, BYTE PTR _len$[ebp]
  0079b	88 0c 10	 mov	 BYTE PTR [eax+edx], cl
  0079e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  007a1	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  007a4	83 c0 01	 add	 eax, 1
  007a7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007aa	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN366@inflate:

; 712  :                 } while (len && copy < have);

  007ad	83 7d ec 00	 cmp	 DWORD PTR _len$[ebp], 0
  007b1	74 08		 je	 SHORT $LN365@inflate
  007b3	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  007b6	3b 55 f4	 cmp	 edx, DWORD PTR _have$[ebp]
  007b9	72 93		 jb	 SHORT $LN367@inflate
$LN365@inflate:

; 713  :                 if (state->flags & 0x0200)

  007bb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  007be	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  007c1	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  007c7	74 1a		 je	 SHORT $LN362@inflate

; 714  :                     state->check = crc32(state->check, next, copy);

  007c9	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  007cc	52		 push	 edx
  007cd	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  007d0	50		 push	 eax
  007d1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007d4	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  007d7	52		 push	 edx
  007d8	e8 00 00 00 00	 call	 _crc32@12
  007dd	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  007e0	89 41 18	 mov	 DWORD PTR [ecx+24], eax
$LN362@inflate:

; 715  :                 have -= copy;

  007e3	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  007e6	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  007e9	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx

; 716  :                 next += copy;

  007ec	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  007ef	03 45 cc	 add	 eax, DWORD PTR _copy$[ebp]
  007f2	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax

; 717  :                 if (len) goto inf_leave;

  007f5	83 7d ec 00	 cmp	 DWORD PTR _len$[ebp], 0
  007f9	74 05		 je	 SHORT $LN361@inflate
  007fb	e9 d4 14 00 00	 jmp	 $inf_leave$77660
$LN361@inflate:

; 718  :             }
; 719  :             else if (state->head != Z_NULL)

  00800	eb 16		 jmp	 SHORT $LN360@inflate
$LN369@inflate:
  00802	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00805	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  00809	74 0d		 je	 SHORT $LN360@inflate

; 720  :                 state->head->name = Z_NULL;

  0080b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0080e	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00811	c7 40 1c 00 00
	00 00		 mov	 DWORD PTR [eax+28], 0
$LN360@inflate:

; 721  :             state->length = 0;

  00818	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0081b	c7 41 40 00 00
	00 00		 mov	 DWORD PTR [ecx+64], 0

; 722  :             state->mode = COMMENT;

  00822	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00825	c7 02 07 00 00
	00		 mov	 DWORD PTR [edx], 7
$LN358@inflate:

; 723  :         case COMMENT:
; 724  :             if (state->flags & 0x1000) {

  0082b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0082e	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00831	81 e1 00 10 00
	00		 and	 ecx, 4096		; 00001000H
  00837	0f 84 c5 00 00
	00		 je	 $LN357@inflate

; 725  :                 if (have == 0) goto inf_leave;

  0083d	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00841	75 05		 jne	 SHORT $LN356@inflate
  00843	e9 8c 14 00 00	 jmp	 $inf_leave$77660
$LN356@inflate:

; 726  :                 copy = 0;

  00848	c7 45 cc 00 00
	00 00		 mov	 DWORD PTR _copy$[ebp], 0
$LN355@inflate:

; 727  :                 do {
; 728  :                     len = (unsigned)(next[copy++]);

  0084f	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00852	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00855	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00858	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax
  0085b	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  0085e	83 c1 01	 add	 ecx, 1
  00861	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 729  :                     if (state->head != Z_NULL &&
; 730  :                             state->head->comment != Z_NULL &&
; 731  :                             state->length < state->head->comm_max)

  00864	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00867	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  0086b	74 41		 je	 SHORT $LN354@inflate
  0086d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00870	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00873	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00877	74 35		 je	 SHORT $LN354@inflate
  00879	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0087c	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  0087f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00882	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00885	3b 50 28	 cmp	 edx, DWORD PTR [eax+40]
  00888	73 24		 jae	 SHORT $LN354@inflate

; 732  :                         state->head->comment[state->length++] = len;

  0088a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0088d	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00890	8b 51 24	 mov	 edx, DWORD PTR [ecx+36]
  00893	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00896	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  00899	8a 45 ec	 mov	 al, BYTE PTR _len$[ebp]
  0089c	88 04 0a	 mov	 BYTE PTR [edx+ecx], al
  0089f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  008a2	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  008a5	83 c2 01	 add	 edx, 1
  008a8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008ab	89 50 40	 mov	 DWORD PTR [eax+64], edx
$LN354@inflate:

; 733  :                 } while (len && copy < have);

  008ae	83 7d ec 00	 cmp	 DWORD PTR _len$[ebp], 0
  008b2	74 08		 je	 SHORT $LN353@inflate
  008b4	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008b7	3b 4d f4	 cmp	 ecx, DWORD PTR _have$[ebp]
  008ba	72 93		 jb	 SHORT $LN355@inflate
$LN353@inflate:

; 734  :                 if (state->flags & 0x0200)

  008bc	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008bf	8b 42 10	 mov	 eax, DWORD PTR [edx+16]
  008c2	25 00 02 00 00	 and	 eax, 512		; 00000200H
  008c7	74 1a		 je	 SHORT $LN350@inflate

; 735  :                     state->check = crc32(state->check, next, copy);

  008c9	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  008cc	51		 push	 ecx
  008cd	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  008d0	52		 push	 edx
  008d1	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  008d4	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  008d7	51		 push	 ecx
  008d8	e8 00 00 00 00	 call	 _crc32@12
  008dd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  008e0	89 42 18	 mov	 DWORD PTR [edx+24], eax
$LN350@inflate:

; 736  :                 have -= copy;

  008e3	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  008e6	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  008e9	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax

; 737  :                 next += copy;

  008ec	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  008ef	03 4d cc	 add	 ecx, DWORD PTR _copy$[ebp]
  008f2	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx

; 738  :                 if (len) goto inf_leave;

  008f5	83 7d ec 00	 cmp	 DWORD PTR _len$[ebp], 0
  008f9	74 05		 je	 SHORT $LN349@inflate
  008fb	e9 d4 13 00 00	 jmp	 $inf_leave$77660
$LN349@inflate:

; 739  :             }
; 740  :             else if (state->head != Z_NULL)

  00900	eb 16		 jmp	 SHORT $LN348@inflate
$LN357@inflate:
  00902	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00905	83 7a 20 00	 cmp	 DWORD PTR [edx+32], 0
  00909	74 0d		 je	 SHORT $LN348@inflate

; 741  :                 state->head->comment = Z_NULL;

  0090b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0090e	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  00911	c7 41 24 00 00
	00 00		 mov	 DWORD PTR [ecx+36], 0
$LN348@inflate:

; 742  :             state->mode = HCRC;

  00918	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0091b	c7 02 08 00 00
	00		 mov	 DWORD PTR [edx], 8
$LN346@inflate:

; 743  :         case HCRC:
; 744  :             if (state->flags & 0x0200) {

  00921	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00924	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  00927	81 e1 00 02 00
	00		 and	 ecx, 512		; 00000200H
  0092d	0f 84 82 00 00
	00		 je	 $LN345@inflate
$LN341@inflate:

; 745  :                 NEEDBITS(16);

  00933	83 7d e8 10	 cmp	 DWORD PTR _bits$[ebp], 16 ; 00000010H
  00937	73 3d		 jae	 SHORT $LN343@inflate
$LN339@inflate:
  00939	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0093d	75 05		 jne	 SHORT $LN336@inflate
  0093f	e9 90 13 00 00	 jmp	 $inf_leave$77660
$LN336@inflate:
  00944	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  00947	83 ea 01	 sub	 edx, 1
  0094a	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  0094d	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00950	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  00953	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00956	d3 e2		 shl	 edx, cl
  00958	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  0095b	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0095e	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00961	83 c0 01	 add	 eax, 1
  00964	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00967	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0096a	83 c1 08	 add	 ecx, 8
  0096d	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00970	33 d2		 xor	 edx, edx
  00972	75 c5		 jne	 SHORT $LN339@inflate
  00974	eb bd		 jmp	 SHORT $LN341@inflate
$LN343@inflate:
  00976	33 c0		 xor	 eax, eax
  00978	75 b9		 jne	 SHORT $LN341@inflate

; 746  :                 if (hold != (state->check & 0xffff)) {

  0097a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0097d	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00980	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00986	39 55 d8	 cmp	 DWORD PTR _hold$[ebp], edx
  00989	74 18		 je	 SHORT $LN334@inflate

; 747  :                     strm->msg = (char *)"header crc mismatch";

  0098b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0098e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BE@GONKLEPM@header?5crc?5mismatch?$AA@

; 748  :                     state->mode = BAD;

  00995	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00998	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH

; 749  :                     break;

  0099e	e9 2c 13 00 00	 jmp	 $LN484@inflate
$LN334@inflate:

; 750  :                 }
; 751  :                 INITBITS();

  009a3	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  009aa	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  009b1	33 d2		 xor	 edx, edx
  009b3	75 ee		 jne	 SHORT $LN334@inflate
$LN345@inflate:

; 752  :             }
; 753  :             if (state->head != Z_NULL) {

  009b5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009b8	83 78 20 00	 cmp	 DWORD PTR [eax+32], 0
  009bc	74 22		 je	 SHORT $LN331@inflate

; 754  :                 state->head->hcrc = (int)((state->flags >> 9) & 1);

  009be	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009c1	8b 51 10	 mov	 edx, DWORD PTR [ecx+16]
  009c4	c1 fa 09	 sar	 edx, 9
  009c7	83 e2 01	 and	 edx, 1
  009ca	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009cd	8b 48 20	 mov	 ecx, DWORD PTR [eax+32]
  009d0	89 51 2c	 mov	 DWORD PTR [ecx+44], edx

; 755  :                 state->head->done = 1;

  009d3	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  009d6	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  009d9	c7 40 30 01 00
	00 00		 mov	 DWORD PTR [eax+48], 1
$LN331@inflate:

; 756  :             }
; 757  :             strm->adler = state->check = crc32(0L, Z_NULL, 0);

  009e0	6a 00		 push	 0
  009e2	6a 00		 push	 0
  009e4	6a 00		 push	 0
  009e6	e8 00 00 00 00	 call	 _crc32@12
  009eb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  009ee	89 41 18	 mov	 DWORD PTR [ecx+24], eax
  009f1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  009f4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  009f7	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  009fa	89 4a 30	 mov	 DWORD PTR [edx+48], ecx

; 758  :             state->mode = TYPE;

  009fd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00a00	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 759  :             break;

  00a06	e9 c4 12 00 00	 jmp	 $LN484@inflate
$LN326@inflate:

; 760  : #endif
; 761  :         case DICTID:
; 762  :             NEEDBITS(32);

  00a0b	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00a0f	73 3d		 jae	 SHORT $LN328@inflate
$LN324@inflate:
  00a11	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00a15	75 05		 jne	 SHORT $LN321@inflate
  00a17	e9 b8 12 00 00	 jmp	 $inf_leave$77660
$LN321@inflate:
  00a1c	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  00a1f	83 e8 01	 sub	 eax, 1
  00a22	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00a25	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00a28	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00a2b	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a2e	d3 e2		 shl	 edx, cl
  00a30	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00a33	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00a36	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00a39	83 c0 01	 add	 eax, 1
  00a3c	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00a3f	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00a42	83 c1 08	 add	 ecx, 8
  00a45	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00a48	33 d2		 xor	 edx, edx
  00a4a	75 c5		 jne	 SHORT $LN324@inflate
  00a4c	eb bd		 jmp	 SHORT $LN326@inflate
$LN328@inflate:
  00a4e	33 c0		 xor	 eax, eax
  00a50	75 b9		 jne	 SHORT $LN326@inflate

; 763  :             strm->adler = state->check = REVERSE(hold);

  00a52	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00a55	c1 e9 18	 shr	 ecx, 24			; 00000018H
  00a58	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  00a5e	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00a61	c1 ea 08	 shr	 edx, 8
  00a64	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  00a6a	03 ca		 add	 ecx, edx
  00a6c	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00a6f	25 00 ff 00 00	 and	 eax, 65280		; 0000ff00H
  00a74	c1 e0 08	 shl	 eax, 8
  00a77	03 c8		 add	 ecx, eax
  00a79	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00a7c	81 e2 ff 00 00
	00		 and	 edx, 255		; 000000ffH
  00a82	c1 e2 18	 shl	 edx, 24			; 00000018H
  00a85	03 ca		 add	 ecx, edx
  00a87	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00a8a	89 48 18	 mov	 DWORD PTR [eax+24], ecx
  00a8d	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00a90	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00a93	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  00a96	89 41 30	 mov	 DWORD PTR [ecx+48], eax
$LN320@inflate:

; 764  :             INITBITS();

  00a99	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00aa0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00aa7	33 c9		 xor	 ecx, ecx
  00aa9	75 ee		 jne	 SHORT $LN320@inflate

; 765  :             state->mode = DICT;

  00aab	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00aae	c7 02 0a 00 00
	00		 mov	 DWORD PTR [edx], 10	; 0000000aH
$LN317@inflate:

; 766  :         case DICT:
; 767  :             if (state->havedict == 0) {

  00ab4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ab7	83 78 0c 00	 cmp	 DWORD PTR [eax+12], 0
  00abb	75 43		 jne	 SHORT $LN316@inflate
$LN315@inflate:

; 768  :                 RESTORE();

  00abd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00ac0	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  00ac3	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  00ac6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00ac9	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  00acc	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  00acf	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00ad2	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00ad5	89 02		 mov	 DWORD PTR [edx], eax
  00ad7	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00ada	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  00add	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  00ae0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00ae3	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00ae6	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  00ae9	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00aec	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  00aef	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  00af2	33 c9		 xor	 ecx, ecx
  00af4	75 c7		 jne	 SHORT $LN315@inflate

; 769  :                 return Z_NEED_DICT;

  00af6	b8 02 00 00 00	 mov	 eax, 2
  00afb	e9 4e 13 00 00	 jmp	 $LN494@inflate
$LN316@inflate:

; 770  :             }
; 771  :             strm->adler = state->check = adler32(0L, Z_NULL, 0);

  00b00	6a 00		 push	 0
  00b02	6a 00		 push	 0
  00b04	6a 00		 push	 0
  00b06	e8 00 00 00 00	 call	 _adler32@12
  00b0b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00b0e	89 42 18	 mov	 DWORD PTR [edx+24], eax
  00b11	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00b14	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00b17	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  00b1a	89 50 30	 mov	 DWORD PTR [eax+48], edx

; 772  :             state->mode = TYPE;

  00b1d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b20	c7 00 0b 00 00
	00		 mov	 DWORD PTR [eax], 11	; 0000000bH
$LN312@inflate:

; 773  :         case TYPE:
; 774  :             if (flush == Z_BLOCK) goto inf_leave;

  00b26	83 7d 0c 05	 cmp	 DWORD PTR _flush$[ebp], 5
  00b2a	75 05		 jne	 SHORT $LN310@inflate
  00b2c	e9 a3 11 00 00	 jmp	 $inf_leave$77660
$LN310@inflate:

; 775  :         case TYPEDO:
; 776  :             if (state->last) {

  00b31	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00b34	83 79 04 00	 cmp	 DWORD PTR [ecx+4], 0
  00b38	74 2e		 je	 SHORT $LN302@inflate
$LN308@inflate:

; 777  :                 BYTEBITS();

  00b3a	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b3d	83 e1 07	 and	 ecx, 7
  00b40	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00b43	d3 ea		 shr	 edx, cl
  00b45	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00b48	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  00b4b	83 e0 07	 and	 eax, 7
  00b4e	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b51	2b c8		 sub	 ecx, eax
  00b53	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00b56	33 d2		 xor	 edx, edx
  00b58	75 e0		 jne	 SHORT $LN308@inflate

; 778  :                 state->mode = CHECK;

  00b5a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00b5d	c7 00 18 00 00
	00		 mov	 DWORD PTR [eax], 24	; 00000018H

; 779  :                 break;

  00b63	e9 67 11 00 00	 jmp	 $LN484@inflate
$LN302@inflate:

; 780  :             }
; 781  :             NEEDBITS(3);

  00b68	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00b6c	73 3d		 jae	 SHORT $LN304@inflate
$LN300@inflate:
  00b6e	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00b72	75 05		 jne	 SHORT $LN297@inflate
  00b74	e9 5b 11 00 00	 jmp	 $inf_leave$77660
$LN297@inflate:
  00b79	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00b7c	83 e9 01	 sub	 ecx, 1
  00b7f	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00b82	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00b85	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00b88	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00b8b	d3 e0		 shl	 eax, cl
  00b8d	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00b90	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00b93	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00b96	83 c1 01	 add	 ecx, 1
  00b99	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00b9c	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00b9f	83 c2 08	 add	 edx, 8
  00ba2	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00ba5	33 c0		 xor	 eax, eax
  00ba7	75 c5		 jne	 SHORT $LN300@inflate
  00ba9	eb bd		 jmp	 SHORT $LN302@inflate
$LN304@inflate:
  00bab	33 c9		 xor	 ecx, ecx
  00bad	75 b9		 jne	 SHORT $LN302@inflate

; 782  :             state->last = BITS(1);

  00baf	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00bb2	83 e2 01	 and	 edx, 1
  00bb5	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00bb8	89 50 04	 mov	 DWORD PTR [eax+4], edx
$LN296@inflate:

; 783  :             DROPBITS(1);

  00bbb	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bbe	d1 e9		 shr	 ecx, 1
  00bc0	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00bc3	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00bc6	83 ea 01	 sub	 edx, 1
  00bc9	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00bcc	33 c0		 xor	 eax, eax
  00bce	75 eb		 jne	 SHORT $LN296@inflate

; 784  :             switch (BITS(2)) {

  00bd0	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00bd3	83 e1 03	 and	 ecx, 3
  00bd6	89 4d b4	 mov	 DWORD PTR tv552[ebp], ecx
  00bd9	83 7d b4 03	 cmp	 DWORD PTR tv552[ebp], 3
  00bdd	77 4a		 ja	 SHORT $LN287@inflate
  00bdf	8b 55 b4	 mov	 edx, DWORD PTR tv552[ebp]
  00be2	ff 24 95 00 00
	00 00		 jmp	 DWORD PTR $LN505@inflate[edx*4]
$LN291@inflate:

; 785  :             case 0:                             /* stored block */
; 786  :                 Tracev((stderr, "inflate:     stored block%s\n",
; 787  :                         state->last ? " (last)" : ""));
; 788  :                 state->mode = STORED;

  00be9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00bec	c7 00 0d 00 00
	00		 mov	 DWORD PTR [eax], 13	; 0000000dH

; 789  :                 break;

  00bf2	eb 35		 jmp	 SHORT $LN287@inflate
$LN290@inflate:

; 790  :             case 1:                             /* fixed block */
; 791  :                 fixedtables(state);

  00bf4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00bf7	51		 push	 ecx
  00bf8	e8 00 00 00 00	 call	 _fixedtables
  00bfd	83 c4 04	 add	 esp, 4

; 792  :                 Tracev((stderr, "inflate:     fixed codes block%s\n",
; 793  :                         state->last ? " (last)" : ""));
; 794  :                 state->mode = LEN;              /* decode codes */

  00c00	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00c03	c7 02 12 00 00
	00		 mov	 DWORD PTR [edx], 18	; 00000012H

; 795  :                 break;

  00c09	eb 1e		 jmp	 SHORT $LN287@inflate
$LN289@inflate:

; 796  :             case 2:                             /* dynamic block */
; 797  :                 Tracev((stderr, "inflate:     dynamic codes block%s\n",
; 798  :                         state->last ? " (last)" : ""));
; 799  :                 state->mode = TABLE;

  00c0b	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00c0e	c7 00 0f 00 00
	00		 mov	 DWORD PTR [eax], 15	; 0000000fH

; 800  :                 break;

  00c14	eb 13		 jmp	 SHORT $LN287@inflate
$LN288@inflate:

; 801  :             case 3:
; 802  :                 strm->msg = (char *)"invalid block type";

  00c16	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00c19	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BD@PJCBIDD@invalid?5block?5type?$AA@

; 803  :                 state->mode = BAD;

  00c20	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00c23	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH
$LN287@inflate:

; 804  :             }
; 805  :             DROPBITS(2);

  00c29	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00c2c	c1 e8 02	 shr	 eax, 2
  00c2f	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00c32	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c35	83 e9 02	 sub	 ecx, 2
  00c38	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00c3b	33 d2		 xor	 edx, edx
  00c3d	75 ea		 jne	 SHORT $LN287@inflate

; 806  :             break;

  00c3f	e9 8b 10 00 00	 jmp	 $LN484@inflate
$LN283@inflate:

; 807  :         case STORED:
; 808  :             BYTEBITS();                         /* go to byte boundary */

  00c44	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c47	83 e1 07	 and	 ecx, 7
  00c4a	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00c4d	d3 e8		 shr	 eax, cl
  00c4f	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00c52	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c55	83 e1 07	 and	 ecx, 7
  00c58	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00c5b	2b d1		 sub	 edx, ecx
  00c5d	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00c60	33 c0		 xor	 eax, eax
  00c62	75 e0		 jne	 SHORT $LN283@inflate
$LN277@inflate:

; 809  :             NEEDBITS(32);

  00c64	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  00c68	73 3d		 jae	 SHORT $LN279@inflate
$LN275@inflate:
  00c6a	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00c6e	75 05		 jne	 SHORT $LN272@inflate
  00c70	e9 5f 10 00 00	 jmp	 $inf_leave$77660
$LN272@inflate:
  00c75	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00c78	83 e9 01	 sub	 ecx, 1
  00c7b	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00c7e	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00c81	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00c84	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00c87	d3 e0		 shl	 eax, cl
  00c89	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00c8c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00c8f	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00c92	83 c1 01	 add	 ecx, 1
  00c95	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00c98	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00c9b	83 c2 08	 add	 edx, 8
  00c9e	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00ca1	33 c0		 xor	 eax, eax
  00ca3	75 c5		 jne	 SHORT $LN275@inflate
  00ca5	eb bd		 jmp	 SHORT $LN277@inflate
$LN279@inflate:
  00ca7	33 c9		 xor	 ecx, ecx
  00ca9	75 b9		 jne	 SHORT $LN277@inflate

; 810  :             if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {

  00cab	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00cae	81 e2 ff ff 00
	00		 and	 edx, 65535		; 0000ffffH
  00cb4	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00cb7	c1 e8 10	 shr	 eax, 16			; 00000010H
  00cba	35 ff ff 00 00	 xor	 eax, 65535		; 0000ffffH
  00cbf	3b d0		 cmp	 edx, eax
  00cc1	74 18		 je	 SHORT $LN271@inflate

; 811  :                 strm->msg = (char *)"invalid stored block lengths";

  00cc3	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00cc6	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BN@LGAADGOK@invalid?5stored?5block?5lengths?$AA@

; 812  :                 state->mode = BAD;

  00ccd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00cd0	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 813  :                 break;

  00cd6	e9 f4 0f 00 00	 jmp	 $LN484@inflate
$LN271@inflate:

; 814  :             }
; 815  :             state->length = (unsigned)hold & 0xffff;

  00cdb	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00cde	25 ff ff 00 00	 and	 eax, 65535		; 0000ffffH
  00ce3	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00ce6	89 41 40	 mov	 DWORD PTR [ecx+64], eax
$LN270@inflate:

; 816  :             Tracev((stderr, "inflate:       stored length %u\n",
; 817  :                     state->length));
; 818  :             INITBITS();

  00ce9	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  00cf0	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  00cf7	33 d2		 xor	 edx, edx
  00cf9	75 ee		 jne	 SHORT $LN270@inflate

; 819  :             state->mode = COPY;

  00cfb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00cfe	c7 00 0e 00 00
	00		 mov	 DWORD PTR [eax], 14	; 0000000eH
$LN267@inflate:

; 820  :         case COPY:
; 821  :             copy = state->length;

  00d04	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00d07	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  00d0a	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 822  :             if (copy) {

  00d0d	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00d11	74 73		 je	 SHORT $LN266@inflate

; 823  :                 if (copy > have) copy = have;

  00d13	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  00d16	3b 45 f4	 cmp	 eax, DWORD PTR _have$[ebp]
  00d19	76 06		 jbe	 SHORT $LN265@inflate
  00d1b	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00d1e	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN265@inflate:

; 824  :                 if (copy > left) copy = left;

  00d21	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  00d24	3b 55 e4	 cmp	 edx, DWORD PTR _left$[ebp]
  00d27	76 06		 jbe	 SHORT $LN264@inflate
  00d29	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00d2c	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN264@inflate:

; 825  :                 if (copy == 0) goto inf_leave;

  00d2f	83 7d cc 00	 cmp	 DWORD PTR _copy$[ebp], 0
  00d33	75 05		 jne	 SHORT $LN263@inflate
  00d35	e9 9a 0f 00 00	 jmp	 $inf_leave$77660
$LN263@inflate:

; 826  :                 zmemcpy(put, next, copy);

  00d3a	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  00d3d	51		 push	 ecx
  00d3e	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00d41	52		 push	 edx
  00d42	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  00d45	50		 push	 eax
  00d46	e8 00 00 00 00	 call	 _memcpy
  00d4b	83 c4 0c	 add	 esp, 12			; 0000000cH

; 827  :                 have -= copy;

  00d4e	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00d51	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  00d54	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx

; 828  :                 next += copy;

  00d57	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00d5a	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  00d5d	89 55 e0	 mov	 DWORD PTR _next$[ebp], edx

; 829  :                 left -= copy;

  00d60	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  00d63	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  00d66	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax

; 830  :                 put += copy;

  00d69	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  00d6c	03 4d cc	 add	 ecx, DWORD PTR _copy$[ebp]
  00d6f	89 4d fc	 mov	 DWORD PTR _put$[ebp], ecx

; 831  :                 state->length -= copy;

  00d72	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00d75	8b 42 40	 mov	 eax, DWORD PTR [edx+64]
  00d78	2b 45 cc	 sub	 eax, DWORD PTR _copy$[ebp]
  00d7b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00d7e	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 832  :                 break;

  00d81	e9 49 0f 00 00	 jmp	 $LN484@inflate
$LN266@inflate:

; 833  :             }
; 834  :             Tracev((stderr, "inflate:       stored end\n"));
; 835  :             state->mode = TYPE;

  00d86	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00d89	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 836  :             break;

  00d8f	e9 3b 0f 00 00	 jmp	 $LN484@inflate
$LN258@inflate:

; 837  :         case TABLE:
; 838  :             NEEDBITS(14);

  00d94	83 7d e8 0e	 cmp	 DWORD PTR _bits$[ebp], 14 ; 0000000eH
  00d98	73 3d		 jae	 SHORT $LN260@inflate
$LN256@inflate:
  00d9a	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00d9e	75 05		 jne	 SHORT $LN253@inflate
  00da0	e9 2f 0f 00 00	 jmp	 $inf_leave$77660
$LN253@inflate:
  00da5	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  00da8	83 e8 01	 sub	 eax, 1
  00dab	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  00dae	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00db1	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  00db4	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00db7	d3 e2		 shl	 edx, cl
  00db9	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  00dbc	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00dbf	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  00dc2	83 c0 01	 add	 eax, 1
  00dc5	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  00dc8	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00dcb	83 c1 08	 add	 ecx, 8
  00dce	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00dd1	33 d2		 xor	 edx, edx
  00dd3	75 c5		 jne	 SHORT $LN256@inflate
  00dd5	eb bd		 jmp	 SHORT $LN258@inflate
$LN260@inflate:
  00dd7	33 c0		 xor	 eax, eax
  00dd9	75 b9		 jne	 SHORT $LN258@inflate

; 839  :             state->nlen = BITS(5) + 257;

  00ddb	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00dde	83 e1 1f	 and	 ecx, 31			; 0000001fH
  00de1	81 c1 01 01 00
	00		 add	 ecx, 257		; 00000101H
  00de7	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00dea	89 4a 60	 mov	 DWORD PTR [edx+96], ecx
$LN252@inflate:

; 840  :             DROPBITS(5);

  00ded	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00df0	c1 e8 05	 shr	 eax, 5
  00df3	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00df6	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00df9	83 e9 05	 sub	 ecx, 5
  00dfc	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  00dff	33 d2		 xor	 edx, edx
  00e01	75 ea		 jne	 SHORT $LN252@inflate

; 841  :             state->ndist = BITS(5) + 1;

  00e03	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  00e06	83 e0 1f	 and	 eax, 31			; 0000001fH
  00e09	83 c0 01	 add	 eax, 1
  00e0c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00e0f	89 41 64	 mov	 DWORD PTR [ecx+100], eax
$LN249@inflate:

; 842  :             DROPBITS(5);

  00e12	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00e15	c1 ea 05	 shr	 edx, 5
  00e18	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00e1b	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  00e1e	83 e8 05	 sub	 eax, 5
  00e21	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  00e24	33 c9		 xor	 ecx, ecx
  00e26	75 ea		 jne	 SHORT $LN249@inflate

; 843  :             state->ncode = BITS(4) + 4;

  00e28	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00e2b	83 e2 0f	 and	 edx, 15			; 0000000fH
  00e2e	83 c2 04	 add	 edx, 4
  00e31	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00e34	89 50 5c	 mov	 DWORD PTR [eax+92], edx
$LN246@inflate:

; 844  :             DROPBITS(4);

  00e37	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  00e3a	c1 e9 04	 shr	 ecx, 4
  00e3d	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  00e40	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00e43	83 ea 04	 sub	 edx, 4
  00e46	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00e49	33 c0		 xor	 eax, eax
  00e4b	75 ea		 jne	 SHORT $LN246@inflate

; 845  : #ifndef PKZIP_BUG_WORKAROUND
; 846  :             if (state->nlen > 286 || state->ndist > 30) {

  00e4d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00e50	81 79 60 1e 01
	00 00		 cmp	 DWORD PTR [ecx+96], 286	; 0000011eH
  00e57	77 09		 ja	 SHORT $LN242@inflate
  00e59	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e5c	83 7a 64 1e	 cmp	 DWORD PTR [edx+100], 30	; 0000001eH
  00e60	76 18		 jbe	 SHORT $LN243@inflate
$LN242@inflate:

; 847  :                 strm->msg = (char *)"too many length or distance symbols";

  00e62	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00e65	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0CE@GMIGFPBB@too?5many?5length?5or?5distance?5symb@

; 848  :                 state->mode = BAD;

  00e6c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00e6f	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH

; 849  :                 break;

  00e75	e9 55 0e 00 00	 jmp	 $LN484@inflate
$LN243@inflate:

; 850  :             }
; 851  : #endif
; 852  :             Tracev((stderr, "inflate:       table sizes ok\n"));
; 853  :             state->have = 0;

  00e7a	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e7d	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 854  :             state->mode = LENLENS;

  00e84	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00e87	c7 00 10 00 00
	00		 mov	 DWORD PTR [eax], 16	; 00000010H
$LN240@inflate:

; 855  :         case LENLENS:
; 856  :             while (state->have < state->ncode) {

  00e8d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00e90	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00e93	8b 41 68	 mov	 eax, DWORD PTR [ecx+104]
  00e96	3b 42 5c	 cmp	 eax, DWORD PTR [edx+92]
  00e99	0f 83 8d 00 00
	00		 jae	 $LN226@inflate
$LN235@inflate:

; 857  :                 NEEDBITS(3);

  00e9f	83 7d e8 03	 cmp	 DWORD PTR _bits$[ebp], 3
  00ea3	73 3d		 jae	 SHORT $LN237@inflate
$LN233@inflate:
  00ea5	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  00ea9	75 05		 jne	 SHORT $LN230@inflate
  00eab	e9 24 0e 00 00	 jmp	 $inf_leave$77660
$LN230@inflate:
  00eb0	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  00eb3	83 e9 01	 sub	 ecx, 1
  00eb6	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  00eb9	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  00ebc	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  00ebf	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  00ec2	d3 e0		 shl	 eax, cl
  00ec4	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  00ec7	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  00eca	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  00ecd	83 c1 01	 add	 ecx, 1
  00ed0	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  00ed3	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  00ed6	83 c2 08	 add	 edx, 8
  00ed9	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  00edc	33 c0		 xor	 eax, eax
  00ede	75 c5		 jne	 SHORT $LN233@inflate
  00ee0	eb bd		 jmp	 SHORT $LN235@inflate
$LN237@inflate:
  00ee2	33 c9		 xor	 ecx, ecx
  00ee4	75 b9		 jne	 SHORT $LN235@inflate

; 858  :                 state->lens[order[state->have++]] = (unsigned short)BITS(3);

  00ee6	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00ee9	83 e2 07	 and	 edx, 7
  00eec	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00eef	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00ef2	0f b7 04 4d 00
	00 00 00	 movzx	 eax, WORD PTR ?order@?1??inflate@@9@9[ecx*2]
  00efa	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00efd	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  00f02	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f05	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00f08	83 c0 01	 add	 eax, 1
  00f0b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f0e	89 41 68	 mov	 DWORD PTR [ecx+104], eax
$LN229@inflate:

; 859  :                 DROPBITS(3);

  00f11	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  00f14	c1 ea 03	 shr	 edx, 3
  00f17	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  00f1a	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  00f1d	83 e8 03	 sub	 eax, 3
  00f20	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  00f23	33 c9		 xor	 ecx, ecx
  00f25	75 ea		 jne	 SHORT $LN229@inflate

; 860  :             }

  00f27	e9 61 ff ff ff	 jmp	 $LN240@inflate
$LN226@inflate:

; 861  :             while (state->have < 19)

  00f2c	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f2f	83 7a 68 13	 cmp	 DWORD PTR [edx+104], 19	; 00000013H
  00f33	73 29		 jae	 SHORT $LN225@inflate

; 862  :                 state->lens[order[state->have++]] = 0;

  00f35	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f38	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  00f3b	0f b7 14 4d 00
	00 00 00	 movzx	 edx, WORD PTR ?order@?1??inflate@@9@9[ecx*2]
  00f43	33 c0		 xor	 eax, eax
  00f45	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f48	66 89 44 51 70	 mov	 WORD PTR [ecx+edx*2+112], ax
  00f4d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f50	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  00f53	83 c0 01	 add	 eax, 1
  00f56	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f59	89 41 68	 mov	 DWORD PTR [ecx+104], eax
  00f5c	eb ce		 jmp	 SHORT $LN226@inflate
$LN225@inflate:

; 863  :             state->next = state->codes;

  00f5e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f61	81 c2 30 05 00
	00		 add	 edx, 1328		; 00000530H
  00f67	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f6a	89 50 6c	 mov	 DWORD PTR [eax+108], edx

; 864  :             state->lencode = (code const FAR *)(state->next);

  00f6d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f70	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f73	8b 42 6c	 mov	 eax, DWORD PTR [edx+108]
  00f76	89 41 4c	 mov	 DWORD PTR [ecx+76], eax

; 865  :             state->lenbits = 7;

  00f79	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f7c	c7 41 54 07 00
	00 00		 mov	 DWORD PTR [ecx+84], 7

; 866  :             ret = inflate_table(CODES, state->lens, 19, &(state->next),
; 867  :                                 &(state->lenbits), state->work);

  00f83	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00f86	81 c2 f0 02 00
	00		 add	 edx, 752		; 000002f0H
  00f8c	52		 push	 edx
  00f8d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00f90	83 c0 54	 add	 eax, 84			; 00000054H
  00f93	50		 push	 eax
  00f94	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00f97	83 c1 6c	 add	 ecx, 108		; 0000006cH
  00f9a	51		 push	 ecx
  00f9b	6a 13		 push	 19			; 00000013H
  00f9d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fa0	83 c2 70	 add	 edx, 112		; 00000070H
  00fa3	52		 push	 edx
  00fa4	6a 00		 push	 0
  00fa6	e8 00 00 00 00	 call	 _inflate_table
  00fab	83 c4 18	 add	 esp, 24			; 00000018H
  00fae	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 868  :             if (ret) {

  00fb1	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  00fb5	74 18		 je	 SHORT $LN224@inflate

; 869  :                 strm->msg = (char *)"invalid code lengths set";

  00fb7	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  00fba	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], OFFSET ??_C@_0BJ@HDEPPGOH@invalid?5code?5lengths?5set?$AA@

; 870  :                 state->mode = BAD;

  00fc1	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fc4	c7 01 1b 00 00
	00		 mov	 DWORD PTR [ecx], 27	; 0000001bH

; 871  :                 break;

  00fca	e9 00 0d 00 00	 jmp	 $LN484@inflate
$LN224@inflate:

; 872  :             }
; 873  :             Tracev((stderr, "inflate:       code lengths ok\n"));
; 874  :             state->have = 0;

  00fcf	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00fd2	c7 42 68 00 00
	00 00		 mov	 DWORD PTR [edx+104], 0

; 875  :             state->mode = CODELENS;

  00fd9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00fdc	c7 00 11 00 00
	00		 mov	 DWORD PTR [eax], 17	; 00000011H
$LN222@inflate:

; 876  :         case CODELENS:
; 877  :             while (state->have < state->nlen + state->ndist) {

  00fe2	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00fe5	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  00fe8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  00feb	03 50 64	 add	 edx, DWORD PTR [eax+100]
  00fee	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  00ff1	39 51 68	 cmp	 DWORD PTR [ecx+104], edx
  00ff4	0f 83 6b 03 00
	00		 jae	 $LN221@inflate
$LN220@inflate:

; 878  :                 for (;;) {
; 879  :                     this = state->lencode[BITS(state->lenbits)];

  00ffa	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  00ffd	b8 01 00 00 00	 mov	 eax, 1
  01002	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  01005	d3 e0		 shl	 eax, cl
  01007	83 e8 01	 sub	 eax, 1
  0100a	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  0100d	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01010	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01013	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01016	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax

; 880  :                     if ((unsigned)(this.bits) <= bits) break;

  01019	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  0101d	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01020	77 02		 ja	 SHORT $LN217@inflate
  01022	eb 3d		 jmp	 SHORT $LN219@inflate
$LN217@inflate:

; 881  :                     PULLBYTE();

  01024	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01028	75 05		 jne	 SHORT $LN214@inflate
  0102a	e9 a5 0c 00 00	 jmp	 $inf_leave$77660
$LN214@inflate:
  0102f	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  01032	83 ea 01	 sub	 edx, 1
  01035	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  01038	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0103b	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0103e	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01041	d3 e2		 shl	 edx, cl
  01043	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01046	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01049	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0104c	83 c0 01	 add	 eax, 1
  0104f	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  01052	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01055	83 c1 08	 add	 ecx, 8
  01058	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0105b	33 d2		 xor	 edx, edx
  0105d	75 c5		 jne	 SHORT $LN217@inflate

; 882  :                 }

  0105f	eb 99		 jmp	 SHORT $LN220@inflate
$LN219@inflate:

; 883  :                 if (this.val < 16) {

  01061	0f b7 45 d2	 movzx	 eax, WORD PTR _this$[ebp+2]
  01065	83 f8 10	 cmp	 eax, 16			; 00000010H
  01068	0f 8d 8c 00 00
	00		 jge	 $LN213@inflate
$LN209@inflate:

; 884  :                     NEEDBITS(this.bits);

  0106e	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01072	39 4d e8	 cmp	 DWORD PTR _bits$[ebp], ecx
  01075	73 3d		 jae	 SHORT $LN211@inflate
$LN207@inflate:
  01077	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0107b	75 05		 jne	 SHORT $LN204@inflate
  0107d	e9 52 0c 00 00	 jmp	 $inf_leave$77660
$LN204@inflate:
  01082	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  01085	83 ea 01	 sub	 edx, 1
  01088	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  0108b	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0108e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01091	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01094	d3 e2		 shl	 edx, cl
  01096	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01099	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0109c	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0109f	83 c0 01	 add	 eax, 1
  010a2	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  010a5	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  010a8	83 c1 08	 add	 ecx, 8
  010ab	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  010ae	33 d2		 xor	 edx, edx
  010b0	75 c5		 jne	 SHORT $LN207@inflate
  010b2	eb ba		 jmp	 SHORT $LN209@inflate
$LN211@inflate:
  010b4	33 c0		 xor	 eax, eax
  010b6	75 b6		 jne	 SHORT $LN209@inflate
$LN203@inflate:

; 885  :                     DROPBITS(this.bits);

  010b8	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  010bc	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  010bf	d3 ea		 shr	 edx, cl
  010c1	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  010c4	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  010c8	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  010cb	2b c8		 sub	 ecx, eax
  010cd	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  010d0	33 d2		 xor	 edx, edx
  010d2	75 e4		 jne	 SHORT $LN203@inflate

; 886  :                     state->lens[state->have++] = this.val;

  010d4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010d7	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  010da	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  010dd	66 8b 45 d2	 mov	 ax, WORD PTR _this$[ebp+2]
  010e1	66 89 44 4a 70	 mov	 WORD PTR [edx+ecx*2+112], ax
  010e6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  010e9	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  010ec	83 c2 01	 add	 edx, 1
  010ef	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  010f2	89 50 68	 mov	 DWORD PTR [eax+104], edx

; 887  :                 }
; 888  :                 else {

  010f5	e9 66 02 00 00	 jmp	 $LN200@inflate
$LN213@inflate:

; 889  :                     if (this.val == 16) {

  010fa	0f b7 4d d2	 movzx	 ecx, WORD PTR _this$[ebp+2]
  010fe	83 f9 10	 cmp	 ecx, 16			; 00000010H
  01101	0f 85 c2 00 00
	00		 jne	 $LN199@inflate
$LN195@inflate:

; 890  :                         NEEDBITS(this.bits + 2);

  01107	0f b6 55 d1	 movzx	 edx, BYTE PTR _this$[ebp+1]
  0110b	83 c2 02	 add	 edx, 2
  0110e	39 55 e8	 cmp	 DWORD PTR _bits$[ebp], edx
  01111	73 3d		 jae	 SHORT $LN197@inflate
$LN193@inflate:
  01113	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01117	75 05		 jne	 SHORT $LN190@inflate
  01119	e9 b6 0b 00 00	 jmp	 $inf_leave$77660
$LN190@inflate:
  0111e	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  01121	83 e8 01	 sub	 eax, 1
  01124	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  01127	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0112a	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  0112d	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01130	d3 e2		 shl	 edx, cl
  01132	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01135	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01138	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0113b	83 c0 01	 add	 eax, 1
  0113e	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  01141	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01144	83 c1 08	 add	 ecx, 8
  01147	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0114a	33 d2		 xor	 edx, edx
  0114c	75 c5		 jne	 SHORT $LN193@inflate
  0114e	eb b7		 jmp	 SHORT $LN195@inflate
$LN197@inflate:
  01150	33 c0		 xor	 eax, eax
  01152	75 b3		 jne	 SHORT $LN195@inflate
$LN189@inflate:

; 891  :                         DROPBITS(this.bits);

  01154	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01158	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0115b	d3 ea		 shr	 edx, cl
  0115d	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01160	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  01164	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01167	2b c8		 sub	 ecx, eax
  01169	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0116c	33 d2		 xor	 edx, edx
  0116e	75 e4		 jne	 SHORT $LN189@inflate

; 892  :                         if (state->have == 0) {

  01170	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01173	83 78 68 00	 cmp	 DWORD PTR [eax+104], 0
  01177	75 18		 jne	 SHORT $LN186@inflate

; 893  :                             strm->msg = (char *)"invalid bit length repeat";

  01179	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0117c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 894  :                             state->mode = BAD;

  01183	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01186	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 895  :                             break;

  0118c	e9 d4 01 00 00	 jmp	 $LN221@inflate
$LN186@inflate:

; 896  :                         }
; 897  :                         len = state->lens[state->have - 1];

  01191	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01194	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  01197	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0119a	0f b7 44 4a 6e	 movzx	 eax, WORD PTR [edx+ecx*2+110]
  0119f	89 45 ec	 mov	 DWORD PTR _len$[ebp], eax

; 898  :                         copy = 3 + BITS(2);

  011a2	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  011a5	83 e1 03	 and	 ecx, 3
  011a8	83 c1 03	 add	 ecx, 3
  011ab	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN185@inflate:

; 899  :                         DROPBITS(2);

  011ae	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  011b1	c1 ea 02	 shr	 edx, 2
  011b4	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  011b7	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  011ba	83 e8 02	 sub	 eax, 2
  011bd	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  011c0	33 c9		 xor	 ecx, ecx
  011c2	75 ea		 jne	 SHORT $LN185@inflate

; 900  :                     }
; 901  :                     else if (this.val == 17) {

  011c4	e9 36 01 00 00	 jmp	 $LN182@inflate
$LN199@inflate:
  011c9	0f b7 55 d2	 movzx	 edx, WORD PTR _this$[ebp+2]
  011cd	83 fa 11	 cmp	 edx, 17			; 00000011H
  011d0	0f 85 97 00 00
	00		 jne	 $LN161@inflate
$LN177@inflate:

; 902  :                         NEEDBITS(this.bits + 3);

  011d6	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  011da	83 c0 03	 add	 eax, 3
  011dd	39 45 e8	 cmp	 DWORD PTR _bits$[ebp], eax
  011e0	73 3d		 jae	 SHORT $LN179@inflate
$LN175@inflate:
  011e2	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  011e6	75 05		 jne	 SHORT $LN172@inflate
  011e8	e9 e7 0a 00 00	 jmp	 $inf_leave$77660
$LN172@inflate:
  011ed	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  011f0	83 e9 01	 sub	 ecx, 1
  011f3	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  011f6	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  011f9	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  011fc	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  011ff	d3 e0		 shl	 eax, cl
  01201	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  01204	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01207	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0120a	83 c1 01	 add	 ecx, 1
  0120d	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  01210	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01213	83 c2 08	 add	 edx, 8
  01216	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  01219	33 c0		 xor	 eax, eax
  0121b	75 c5		 jne	 SHORT $LN175@inflate
  0121d	eb b7		 jmp	 SHORT $LN177@inflate
$LN179@inflate:
  0121f	33 c9		 xor	 ecx, ecx
  01221	75 b3		 jne	 SHORT $LN177@inflate
$LN171@inflate:

; 903  :                         DROPBITS(this.bits);

  01223	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01227	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  0122a	d3 ea		 shr	 edx, cl
  0122c	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0122f	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  01233	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01236	2b c8		 sub	 ecx, eax
  01238	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0123b	33 d2		 xor	 edx, edx
  0123d	75 e4		 jne	 SHORT $LN171@inflate

; 904  :                         len = 0;

  0123f	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 905  :                         copy = 3 + BITS(3);

  01246	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  01249	83 e0 07	 and	 eax, 7
  0124c	83 c0 03	 add	 eax, 3
  0124f	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN168@inflate:

; 906  :                         DROPBITS(3);

  01252	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01255	c1 e9 03	 shr	 ecx, 3
  01258	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  0125b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  0125e	83 ea 03	 sub	 edx, 3
  01261	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  01264	33 c0		 xor	 eax, eax
  01266	75 ea		 jne	 SHORT $LN168@inflate

; 907  :                     }
; 908  :                     else {

  01268	e9 92 00 00 00	 jmp	 $LN182@inflate
$LN161@inflate:

; 909  :                         NEEDBITS(this.bits + 7);

  0126d	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01271	83 c1 07	 add	 ecx, 7
  01274	39 4d e8	 cmp	 DWORD PTR _bits$[ebp], ecx
  01277	73 3d		 jae	 SHORT $LN163@inflate
$LN159@inflate:
  01279	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0127d	75 05		 jne	 SHORT $LN156@inflate
  0127f	e9 50 0a 00 00	 jmp	 $inf_leave$77660
$LN156@inflate:
  01284	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  01287	83 ea 01	 sub	 edx, 1
  0128a	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  0128d	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  01290	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01293	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01296	d3 e2		 shl	 edx, cl
  01298	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  0129b	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0129e	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  012a1	83 c0 01	 add	 eax, 1
  012a4	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  012a7	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  012aa	83 c1 08	 add	 ecx, 8
  012ad	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  012b0	33 d2		 xor	 edx, edx
  012b2	75 c5		 jne	 SHORT $LN159@inflate
  012b4	eb b7		 jmp	 SHORT $LN161@inflate
$LN163@inflate:
  012b6	33 c0		 xor	 eax, eax
  012b8	75 b3		 jne	 SHORT $LN161@inflate
$LN155@inflate:

; 910  :                         DROPBITS(this.bits);

  012ba	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  012be	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  012c1	d3 ea		 shr	 edx, cl
  012c3	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  012c6	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  012ca	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  012cd	2b c8		 sub	 ecx, eax
  012cf	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  012d2	33 d2		 xor	 edx, edx
  012d4	75 e4		 jne	 SHORT $LN155@inflate

; 911  :                         len = 0;

  012d6	c7 45 ec 00 00
	00 00		 mov	 DWORD PTR _len$[ebp], 0

; 912  :                         copy = 11 + BITS(7);

  012dd	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  012e0	83 e0 7f	 and	 eax, 127		; 0000007fH
  012e3	83 c0 0b	 add	 eax, 11			; 0000000bH
  012e6	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax
$LN152@inflate:

; 913  :                         DROPBITS(7);

  012e9	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  012ec	c1 e9 07	 shr	 ecx, 7
  012ef	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  012f2	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  012f5	83 ea 07	 sub	 edx, 7
  012f8	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  012fb	33 c0		 xor	 eax, eax
  012fd	75 ea		 jne	 SHORT $LN152@inflate
$LN182@inflate:

; 914  :                     }
; 915  :                     if (state->have + copy > state->nlen + state->ndist) {

  012ff	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01302	8b 51 68	 mov	 edx, DWORD PTR [ecx+104]
  01305	03 55 cc	 add	 edx, DWORD PTR _copy$[ebp]
  01308	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0130b	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  0130e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01311	03 48 64	 add	 ecx, DWORD PTR [eax+100]
  01314	3b d1		 cmp	 edx, ecx
  01316	76 15		 jbe	 SHORT $LN148@inflate

; 916  :                         strm->msg = (char *)"invalid bit length repeat";

  01318	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0131b	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BK@BMMPFBBH@invalid?5bit?5length?5repeat?$AA@

; 917  :                         state->mode = BAD;

  01322	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01325	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 918  :                         break;

  0132b	eb 38		 jmp	 SHORT $LN221@inflate
$LN148@inflate:

; 919  :                     }
; 920  :                     while (copy--)

  0132d	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01330	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  01333	83 e9 01	 sub	 ecx, 1
  01336	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
  01339	85 c0		 test	 eax, eax
  0133b	74 23		 je	 SHORT $LN200@inflate

; 921  :                         state->lens[state->have++] = (unsigned short)len;

  0133d	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01340	8b 42 68	 mov	 eax, DWORD PTR [edx+104]
  01343	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01346	66 8b 55 ec	 mov	 dx, WORD PTR _len$[ebp]
  0134a	66 89 54 41 70	 mov	 WORD PTR [ecx+eax*2+112], dx
  0134f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01352	8b 48 68	 mov	 ecx, DWORD PTR [eax+104]
  01355	83 c1 01	 add	 ecx, 1
  01358	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0135b	89 4a 68	 mov	 DWORD PTR [edx+104], ecx
  0135e	eb cd		 jmp	 SHORT $LN148@inflate
$LN200@inflate:

; 922  :                 }
; 923  :             }

  01360	e9 7d fc ff ff	 jmp	 $LN222@inflate
$LN221@inflate:

; 924  : 
; 925  :             /* handle error breaks in while */
; 926  :             if (state->mode == BAD) break;

  01365	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01368	83 38 1b	 cmp	 DWORD PTR [eax], 27	; 0000001bH
  0136b	75 05		 jne	 SHORT $LN146@inflate
  0136d	e9 5d 09 00 00	 jmp	 $LN484@inflate
$LN146@inflate:

; 927  : 
; 928  :             /* build code tables */
; 929  :             state->next = state->codes;

  01372	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01375	81 c1 30 05 00
	00		 add	 ecx, 1328		; 00000530H
  0137b	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0137e	89 4a 6c	 mov	 DWORD PTR [edx+108], ecx

; 930  :             state->lencode = (code const FAR *)(state->next);

  01381	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01384	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01387	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  0138a	89 50 4c	 mov	 DWORD PTR [eax+76], edx

; 931  :             state->lenbits = 9;

  0138d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01390	c7 40 54 09 00
	00 00		 mov	 DWORD PTR [eax+84], 9

; 932  :             ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
; 933  :                                 &(state->lenbits), state->work);

  01397	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0139a	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  013a0	51		 push	 ecx
  013a1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013a4	83 c2 54	 add	 edx, 84			; 00000054H
  013a7	52		 push	 edx
  013a8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013ab	83 c0 6c	 add	 eax, 108		; 0000006cH
  013ae	50		 push	 eax
  013af	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013b2	8b 51 60	 mov	 edx, DWORD PTR [ecx+96]
  013b5	52		 push	 edx
  013b6	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013b9	83 c0 70	 add	 eax, 112		; 00000070H
  013bc	50		 push	 eax
  013bd	6a 01		 push	 1
  013bf	e8 00 00 00 00	 call	 _inflate_table
  013c4	83 c4 18	 add	 esp, 24			; 00000018H
  013c7	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 934  :             if (ret) {

  013ca	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  013ce	74 18		 je	 SHORT $LN145@inflate

; 935  :                 strm->msg = (char *)"invalid literal/lengths set";

  013d0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  013d3	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@IIMGAINC@invalid?5literal?1lengths?5set?$AA@

; 936  :                 state->mode = BAD;

  013da	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  013dd	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 937  :                 break;

  013e3	e9 e7 08 00 00	 jmp	 $LN484@inflate
$LN145@inflate:

; 938  :             }
; 939  :             state->distcode = (code const FAR *)(state->next);

  013e8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013eb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  013ee	8b 51 6c	 mov	 edx, DWORD PTR [ecx+108]
  013f1	89 50 50	 mov	 DWORD PTR [eax+80], edx

; 940  :             state->distbits = 6;

  013f4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  013f7	c7 40 58 06 00
	00 00		 mov	 DWORD PTR [eax+88], 6

; 941  :             ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
; 942  :                             &(state->next), &(state->distbits), state->work);

  013fe	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01401	81 c1 f0 02 00
	00		 add	 ecx, 752		; 000002f0H
  01407	51		 push	 ecx
  01408	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0140b	83 c2 58	 add	 edx, 88			; 00000058H
  0140e	52		 push	 edx
  0140f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01412	83 c0 6c	 add	 eax, 108		; 0000006cH
  01415	50		 push	 eax
  01416	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01419	8b 51 64	 mov	 edx, DWORD PTR [ecx+100]
  0141c	52		 push	 edx
  0141d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01420	8b 48 60	 mov	 ecx, DWORD PTR [eax+96]
  01423	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01426	8d 44 4a 70	 lea	 eax, DWORD PTR [edx+ecx*2+112]
  0142a	50		 push	 eax
  0142b	6a 02		 push	 2
  0142d	e8 00 00 00 00	 call	 _inflate_table
  01432	83 c4 18	 add	 esp, 24			; 00000018H
  01435	89 45 dc	 mov	 DWORD PTR _ret$[ebp], eax

; 943  :             if (ret) {

  01438	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  0143c	74 18		 je	 SHORT $LN144@inflate

; 944  :                 strm->msg = (char *)"invalid distances set";

  0143e	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01441	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BG@GMDFCBGP@invalid?5distances?5set?$AA@

; 945  :                 state->mode = BAD;

  01448	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0144b	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 946  :                 break;

  01451	e9 79 08 00 00	 jmp	 $LN484@inflate
$LN144@inflate:

; 947  :             }
; 948  :             Tracev((stderr, "inflate:       codes ok\n"));
; 949  :             state->mode = LEN;

  01456	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01459	c7 00 12 00 00
	00		 mov	 DWORD PTR [eax], 18	; 00000012H
$LN143@inflate:

; 950  :         case LEN:
; 951  :             if (have >= 6 && left >= 258) {

  0145f	83 7d f4 06	 cmp	 DWORD PTR _have$[ebp], 6
  01463	0f 82 94 00 00
	00		 jb	 $LN135@inflate
  01469	81 7d e4 02 01
	00 00		 cmp	 DWORD PTR _left$[ebp], 258 ; 00000102H
  01470	0f 82 87 00 00
	00		 jb	 $LN135@inflate
$LN141@inflate:

; 952  :                 RESTORE();

  01476	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01479	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  0147c	89 51 0c	 mov	 DWORD PTR [ecx+12], edx
  0147f	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01482	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  01485	89 48 10	 mov	 DWORD PTR [eax+16], ecx
  01488	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0148b	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0148e	89 02		 mov	 DWORD PTR [edx], eax
  01490	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01493	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  01496	89 51 04	 mov	 DWORD PTR [ecx+4], edx
  01499	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0149c	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  0149f	89 48 38	 mov	 DWORD PTR [eax+56], ecx
  014a2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014a5	8b 45 e8	 mov	 eax, DWORD PTR _bits$[ebp]
  014a8	89 42 3c	 mov	 DWORD PTR [edx+60], eax
  014ab	33 c9		 xor	 ecx, ecx
  014ad	75 c7		 jne	 SHORT $LN141@inflate

; 953  :                 inflate_fast(strm, out);

  014af	8b 55 c4	 mov	 edx, DWORD PTR _out$[ebp]
  014b2	52		 push	 edx
  014b3	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014b6	50		 push	 eax
  014b7	e8 00 00 00 00	 call	 _inflate_fast
  014bc	83 c4 08	 add	 esp, 8
$LN138@inflate:

; 954  :                 LOAD();

  014bf	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  014c2	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  014c5	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx
  014c8	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  014cb	8b 48 10	 mov	 ecx, DWORD PTR [eax+16]
  014ce	89 4d e4	 mov	 DWORD PTR _left$[ebp], ecx
  014d1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  014d4	8b 02		 mov	 eax, DWORD PTR [edx]
  014d6	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  014d9	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  014dc	8b 51 04	 mov	 edx, DWORD PTR [ecx+4]
  014df	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  014e2	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  014e5	8b 48 38	 mov	 ecx, DWORD PTR [eax+56]
  014e8	89 4d d8	 mov	 DWORD PTR _hold$[ebp], ecx
  014eb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  014ee	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  014f1	89 45 e8	 mov	 DWORD PTR _bits$[ebp], eax
  014f4	33 c9		 xor	 ecx, ecx
  014f6	75 c7		 jne	 SHORT $LN138@inflate

; 955  :                 break;

  014f8	e9 d2 07 00 00	 jmp	 $LN484@inflate
$LN135@inflate:

; 956  :             }
; 957  :             for (;;) {
; 958  :                 this = state->lencode[BITS(state->lenbits)];

  014fd	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01500	b8 01 00 00 00	 mov	 eax, 1
  01505	8b 4a 54	 mov	 ecx, DWORD PTR [edx+84]
  01508	d3 e0		 shl	 eax, cl
  0150a	83 e8 01	 sub	 eax, 1
  0150d	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  01510	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01513	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  01516	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01519	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax

; 959  :                 if ((unsigned)(this.bits) <= bits) break;

  0151c	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01520	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  01523	77 02		 ja	 SHORT $LN132@inflate
  01525	eb 3d		 jmp	 SHORT $LN134@inflate
$LN132@inflate:

; 960  :                 PULLBYTE();

  01527	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  0152b	75 05		 jne	 SHORT $LN129@inflate
  0152d	e9 a2 07 00 00	 jmp	 $inf_leave$77660
$LN129@inflate:
  01532	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  01535	83 ea 01	 sub	 edx, 1
  01538	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  0153b	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0153e	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  01541	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01544	d3 e2		 shl	 edx, cl
  01546	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01549	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0154c	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0154f	83 c0 01	 add	 eax, 1
  01552	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  01555	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01558	83 c1 08	 add	 ecx, 8
  0155b	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  0155e	33 d2		 xor	 edx, edx
  01560	75 c5		 jne	 SHORT $LN132@inflate

; 961  :             }

  01562	eb 99		 jmp	 SHORT $LN135@inflate
$LN134@inflate:

; 962  :             if (this.op && (this.op & 0xf0) == 0) {

  01564	0f b6 45 d0	 movzx	 eax, BYTE PTR _this$[ebp]
  01568	85 c0		 test	 eax, eax
  0156a	0f 84 af 00 00
	00		 je	 $LN117@inflate
  01570	0f b6 4d d0	 movzx	 ecx, BYTE PTR _this$[ebp]
  01574	81 e1 f0 00 00
	00		 and	 ecx, 240		; 000000f0H
  0157a	0f 85 9f 00 00
	00		 jne	 $LN117@inflate

; 963  :                 last = this;

  01580	8b 55 d0	 mov	 edx, DWORD PTR _this$[ebp]
  01583	89 55 f8	 mov	 DWORD PTR _last$[ebp], edx
$LN127@inflate:

; 964  :                 for (;;) {
; 965  :                     this = state->lencode[last.val +
; 966  :                             (BITS(last.bits + last.op) >> last.bits)];

  01586	0f b7 45 fa	 movzx	 eax, WORD PTR _last$[ebp+2]
  0158a	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  0158e	0f b6 55 f8	 movzx	 edx, BYTE PTR _last$[ebp]
  01592	03 ca		 add	 ecx, edx
  01594	ba 01 00 00 00	 mov	 edx, 1
  01599	d3 e2		 shl	 edx, cl
  0159b	83 ea 01	 sub	 edx, 1
  0159e	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  015a1	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  015a5	d3 ea		 shr	 edx, cl
  015a7	03 c2		 add	 eax, edx
  015a9	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  015ac	8b 51 4c	 mov	 edx, DWORD PTR [ecx+76]
  015af	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  015b2	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax

; 967  :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  015b5	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  015b9	0f b6 55 d1	 movzx	 edx, BYTE PTR _this$[ebp+1]
  015bd	03 ca		 add	 ecx, edx
  015bf	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  015c2	77 02		 ja	 SHORT $LN124@inflate
  015c4	eb 3d		 jmp	 SHORT $LN120@inflate
$LN124@inflate:

; 968  :                     PULLBYTE();

  015c6	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  015ca	75 05		 jne	 SHORT $LN121@inflate
  015cc	e9 03 07 00 00	 jmp	 $inf_leave$77660
$LN121@inflate:
  015d1	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  015d4	83 e8 01	 sub	 eax, 1
  015d7	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  015da	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  015dd	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  015e0	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  015e3	d3 e2		 shl	 edx, cl
  015e5	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  015e8	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  015eb	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  015ee	83 c0 01	 add	 eax, 1
  015f1	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  015f4	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  015f7	83 c1 08	 add	 ecx, 8
  015fa	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  015fd	33 d2		 xor	 edx, edx
  015ff	75 c5		 jne	 SHORT $LN124@inflate

; 969  :                 }

  01601	eb 83		 jmp	 SHORT $LN127@inflate
$LN120@inflate:

; 970  :                 DROPBITS(last.bits);

  01603	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01607	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  0160a	d3 e8		 shr	 eax, cl
  0160c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0160f	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01613	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01616	2b d1		 sub	 edx, ecx
  01618	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0161b	33 c0		 xor	 eax, eax
  0161d	75 e4		 jne	 SHORT $LN120@inflate
$LN117@inflate:

; 971  :             }
; 972  :             DROPBITS(this.bits);

  0161f	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01623	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  01626	d3 ea		 shr	 edx, cl
  01628	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0162b	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  0162f	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01632	2b c8		 sub	 ecx, eax
  01634	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  01637	33 d2		 xor	 edx, edx
  01639	75 e4		 jne	 SHORT $LN117@inflate

; 973  :             state->length = (unsigned)this.val;

  0163b	0f b7 45 d2	 movzx	 eax, WORD PTR _this$[ebp+2]
  0163f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01642	89 41 40	 mov	 DWORD PTR [ecx+64], eax

; 974  :             if ((int)(this.op) == 0) {

  01645	0f b6 55 d0	 movzx	 edx, BYTE PTR _this$[ebp]
  01649	85 d2		 test	 edx, edx
  0164b	75 0e		 jne	 SHORT $LN114@inflate

; 975  :                 Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
; 976  :                         "inflate:         literal '%c'\n" :
; 977  :                         "inflate:         literal 0x%02x\n", this.val));
; 978  :                 state->mode = LIT;

  0164d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01650	c7 00 17 00 00
	00		 mov	 DWORD PTR [eax], 23	; 00000017H

; 979  :                 break;

  01656	e9 74 06 00 00	 jmp	 $LN484@inflate
$LN114@inflate:

; 980  :             }
; 981  :             if (this.op & 32) {

  0165b	0f b6 4d d0	 movzx	 ecx, BYTE PTR _this$[ebp]
  0165f	83 e1 20	 and	 ecx, 32			; 00000020H
  01662	74 0e		 je	 SHORT $LN113@inflate

; 982  :                 Tracevv((stderr, "inflate:         end of block\n"));
; 983  :                 state->mode = TYPE;

  01664	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01667	c7 02 0b 00 00
	00		 mov	 DWORD PTR [edx], 11	; 0000000bH

; 984  :                 break;

  0166d	e9 5d 06 00 00	 jmp	 $LN484@inflate
$LN113@inflate:

; 985  :             }
; 986  :             if (this.op & 64) {

  01672	0f b6 45 d0	 movzx	 eax, BYTE PTR _this$[ebp]
  01676	83 e0 40	 and	 eax, 64			; 00000040H
  01679	74 18		 je	 SHORT $LN112@inflate

; 987  :                 strm->msg = (char *)"invalid literal/length code";

  0167b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  0167e	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BM@FFFLPBBC@invalid?5literal?1length?5code?$AA@

; 988  :                 state->mode = BAD;

  01685	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01688	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 989  :                 break;

  0168e	e9 3c 06 00 00	 jmp	 $LN484@inflate
$LN112@inflate:

; 990  :             }
; 991  :             state->extra = (unsigned)(this.op) & 15;

  01693	0f b6 45 d0	 movzx	 eax, BYTE PTR _this$[ebp]
  01697	83 e0 0f	 and	 eax, 15			; 0000000fH
  0169a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0169d	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 992  :             state->mode = LENEXT;

  016a0	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  016a3	c7 02 13 00 00
	00		 mov	 DWORD PTR [edx], 19	; 00000013H
$LN111@inflate:

; 993  :         case LENEXT:
; 994  :             if (state->extra) {

  016a9	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  016ac	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  016b0	0f 84 89 00 00
	00		 je	 $LN110@inflate
$LN106@inflate:

; 995  :                 NEEDBITS(state->extra);

  016b6	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  016b9	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  016bc	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  016bf	73 3d		 jae	 SHORT $LN108@inflate
$LN104@inflate:
  016c1	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  016c5	75 05		 jne	 SHORT $LN101@inflate
  016c7	e9 08 06 00 00	 jmp	 $inf_leave$77660
$LN101@inflate:
  016cc	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  016cf	83 e8 01	 sub	 eax, 1
  016d2	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  016d5	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  016d8	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  016db	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  016de	d3 e2		 shl	 edx, cl
  016e0	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  016e3	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  016e6	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  016e9	83 c0 01	 add	 eax, 1
  016ec	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  016ef	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  016f2	83 c1 08	 add	 ecx, 8
  016f5	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  016f8	33 d2		 xor	 edx, edx
  016fa	75 c5		 jne	 SHORT $LN104@inflate
  016fc	eb b8		 jmp	 SHORT $LN106@inflate
$LN108@inflate:
  016fe	33 c0		 xor	 eax, eax
  01700	75 b4		 jne	 SHORT $LN106@inflate

; 996  :                 state->length += BITS(state->extra);

  01702	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01705	ba 01 00 00 00	 mov	 edx, 1
  0170a	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  0170d	d3 e2		 shl	 edx, cl
  0170f	83 ea 01	 sub	 edx, 1
  01712	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  01715	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01718	03 50 40	 add	 edx, DWORD PTR [eax+64]
  0171b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0171e	89 51 40	 mov	 DWORD PTR [ecx+64], edx
$LN100@inflate:

; 997  :                 DROPBITS(state->extra);

  01721	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01724	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  01727	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  0172a	d3 e8		 shr	 eax, cl
  0172c	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  0172f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01732	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01735	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  01738	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0173b	33 c0		 xor	 eax, eax
  0173d	75 e2		 jne	 SHORT $LN100@inflate
$LN110@inflate:

; 998  :             }
; 999  :             Tracevv((stderr, "inflate:         length %u\n", state->length));
; 1000 :             state->mode = DIST;

  0173f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01742	c7 01 14 00 00
	00		 mov	 DWORD PTR [ecx], 20	; 00000014H
$LN96@inflate:

; 1001 :         case DIST:
; 1002 :             for (;;) {
; 1003 :                 this = state->distcode[BITS(state->distbits)];

  01748	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0174b	b8 01 00 00 00	 mov	 eax, 1
  01750	8b 4a 58	 mov	 ecx, DWORD PTR [edx+88]
  01753	d3 e0		 shl	 eax, cl
  01755	83 e8 01	 sub	 eax, 1
  01758	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  0175b	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0175e	8b 51 50	 mov	 edx, DWORD PTR [ecx+80]
  01761	8b 04 82	 mov	 eax, DWORD PTR [edx+eax*4]
  01764	89 45 d0	 mov	 DWORD PTR _this$[ebp], eax

; 1004 :                 if ((unsigned)(this.bits) <= bits) break;

  01767	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  0176b	3b 4d e8	 cmp	 ecx, DWORD PTR _bits$[ebp]
  0176e	77 02		 ja	 SHORT $LN93@inflate
  01770	eb 3d		 jmp	 SHORT $LN95@inflate
$LN93@inflate:

; 1005 :                 PULLBYTE();

  01772	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01776	75 05		 jne	 SHORT $LN90@inflate
  01778	e9 57 05 00 00	 jmp	 $inf_leave$77660
$LN90@inflate:
  0177d	8b 55 f4	 mov	 edx, DWORD PTR _have$[ebp]
  01780	83 ea 01	 sub	 edx, 1
  01783	89 55 f4	 mov	 DWORD PTR _have$[ebp], edx
  01786	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  01789	0f b6 10	 movzx	 edx, BYTE PTR [eax]
  0178c	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  0178f	d3 e2		 shl	 edx, cl
  01791	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01794	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01797	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  0179a	83 c0 01	 add	 eax, 1
  0179d	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  017a0	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  017a3	83 c1 08	 add	 ecx, 8
  017a6	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  017a9	33 d2		 xor	 edx, edx
  017ab	75 c5		 jne	 SHORT $LN93@inflate

; 1006 :             }

  017ad	eb 99		 jmp	 SHORT $LN96@inflate
$LN95@inflate:

; 1007 :             if ((this.op & 0xf0) == 0) {

  017af	0f b6 45 d0	 movzx	 eax, BYTE PTR _this$[ebp]
  017b3	25 f0 00 00 00	 and	 eax, 240		; 000000f0H
  017b8	0f 85 9f 00 00
	00		 jne	 $LN78@inflate

; 1008 :                 last = this;

  017be	8b 4d d0	 mov	 ecx, DWORD PTR _this$[ebp]
  017c1	89 4d f8	 mov	 DWORD PTR _last$[ebp], ecx
$LN88@inflate:

; 1009 :                 for (;;) {
; 1010 :                     this = state->distcode[last.val +
; 1011 :                             (BITS(last.bits + last.op) >> last.bits)];

  017c4	0f b7 55 fa	 movzx	 edx, WORD PTR _last$[ebp+2]
  017c8	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  017cc	0f b6 45 f8	 movzx	 eax, BYTE PTR _last$[ebp]
  017d0	03 c8		 add	 ecx, eax
  017d2	b8 01 00 00 00	 mov	 eax, 1
  017d7	d3 e0		 shl	 eax, cl
  017d9	83 e8 01	 sub	 eax, 1
  017dc	23 45 d8	 and	 eax, DWORD PTR _hold$[ebp]
  017df	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  017e3	d3 e8		 shr	 eax, cl
  017e5	03 d0		 add	 edx, eax
  017e7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  017ea	8b 41 50	 mov	 eax, DWORD PTR [ecx+80]
  017ed	8b 0c 90	 mov	 ecx, DWORD PTR [eax+edx*4]
  017f0	89 4d d0	 mov	 DWORD PTR _this$[ebp], ecx

; 1012 :                     if ((unsigned)(last.bits + this.bits) <= bits) break;

  017f3	0f b6 55 f9	 movzx	 edx, BYTE PTR _last$[ebp+1]
  017f7	0f b6 45 d1	 movzx	 eax, BYTE PTR _this$[ebp+1]
  017fb	03 d0		 add	 edx, eax
  017fd	3b 55 e8	 cmp	 edx, DWORD PTR _bits$[ebp]
  01800	77 02		 ja	 SHORT $LN85@inflate
  01802	eb 3d		 jmp	 SHORT $LN81@inflate
$LN85@inflate:

; 1013 :                     PULLBYTE();

  01804	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01808	75 05		 jne	 SHORT $LN82@inflate
  0180a	e9 c5 04 00 00	 jmp	 $inf_leave$77660
$LN82@inflate:
  0180f	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  01812	83 e9 01	 sub	 ecx, 1
  01815	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  01818	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  0181b	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  0181e	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01821	d3 e0		 shl	 eax, cl
  01823	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  01826	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01829	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  0182c	83 c1 01	 add	 ecx, 1
  0182f	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  01832	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01835	83 c2 08	 add	 edx, 8
  01838	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0183b	33 c0		 xor	 eax, eax
  0183d	75 c5		 jne	 SHORT $LN85@inflate

; 1014 :                 }

  0183f	eb 83		 jmp	 SHORT $LN88@inflate
$LN81@inflate:

; 1015 :                 DROPBITS(last.bits);

  01841	0f b6 4d f9	 movzx	 ecx, BYTE PTR _last$[ebp+1]
  01845	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  01848	d3 ea		 shr	 edx, cl
  0184a	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  0184d	0f b6 45 f9	 movzx	 eax, BYTE PTR _last$[ebp+1]
  01851	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01854	2b c8		 sub	 ecx, eax
  01856	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  01859	33 d2		 xor	 edx, edx
  0185b	75 e4		 jne	 SHORT $LN81@inflate
$LN78@inflate:

; 1016 :             }
; 1017 :             DROPBITS(this.bits);

  0185d	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  01861	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  01864	d3 e8		 shr	 eax, cl
  01866	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01869	0f b6 4d d1	 movzx	 ecx, BYTE PTR _this$[ebp+1]
  0186d	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01870	2b d1		 sub	 edx, ecx
  01872	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  01875	33 c0		 xor	 eax, eax
  01877	75 e4		 jne	 SHORT $LN78@inflate

; 1018 :             if (this.op & 64) {

  01879	0f b6 4d d0	 movzx	 ecx, BYTE PTR _this$[ebp]
  0187d	83 e1 40	 and	 ecx, 64			; 00000040H
  01880	74 18		 je	 SHORT $LN75@inflate

; 1019 :                 strm->msg = (char *)"invalid distance code";

  01882	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01885	c7 42 18 00 00
	00 00		 mov	 DWORD PTR [edx+24], OFFSET ??_C@_0BG@LBKINIKP@invalid?5distance?5code?$AA@

; 1020 :                 state->mode = BAD;

  0188c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0188f	c7 00 1b 00 00
	00		 mov	 DWORD PTR [eax], 27	; 0000001bH

; 1021 :                 break;

  01895	e9 35 04 00 00	 jmp	 $LN484@inflate
$LN75@inflate:

; 1022 :             }
; 1023 :             state->offset = (unsigned)this.val;

  0189a	0f b7 4d d2	 movzx	 ecx, WORD PTR _this$[ebp+2]
  0189e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  018a1	89 4a 44	 mov	 DWORD PTR [edx+68], ecx

; 1024 :             state->extra = (unsigned)(this.op) & 15;

  018a4	0f b6 45 d0	 movzx	 eax, BYTE PTR _this$[ebp]
  018a8	83 e0 0f	 and	 eax, 15			; 0000000fH
  018ab	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  018ae	89 41 48	 mov	 DWORD PTR [ecx+72], eax

; 1025 :             state->mode = DISTEXT;

  018b1	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  018b4	c7 02 15 00 00
	00		 mov	 DWORD PTR [edx], 21	; 00000015H
$LN74@inflate:

; 1026 :         case DISTEXT:
; 1027 :             if (state->extra) {

  018ba	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  018bd	83 78 48 00	 cmp	 DWORD PTR [eax+72], 0
  018c1	0f 84 89 00 00
	00		 je	 $LN73@inflate
$LN69@inflate:

; 1028 :                 NEEDBITS(state->extra);

  018c7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  018ca	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  018cd	3b 51 48	 cmp	 edx, DWORD PTR [ecx+72]
  018d0	73 3d		 jae	 SHORT $LN71@inflate
$LN67@inflate:
  018d2	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  018d6	75 05		 jne	 SHORT $LN64@inflate
  018d8	e9 f7 03 00 00	 jmp	 $inf_leave$77660
$LN64@inflate:
  018dd	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  018e0	83 e8 01	 sub	 eax, 1
  018e3	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  018e6	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  018e9	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  018ec	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  018ef	d3 e2		 shl	 edx, cl
  018f1	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  018f4	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  018f7	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  018fa	83 c0 01	 add	 eax, 1
  018fd	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  01900	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01903	83 c1 08	 add	 ecx, 8
  01906	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  01909	33 d2		 xor	 edx, edx
  0190b	75 c5		 jne	 SHORT $LN67@inflate
  0190d	eb b8		 jmp	 SHORT $LN69@inflate
$LN71@inflate:
  0190f	33 c0		 xor	 eax, eax
  01911	75 b4		 jne	 SHORT $LN69@inflate

; 1029 :                 state->offset += BITS(state->extra);

  01913	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01916	ba 01 00 00 00	 mov	 edx, 1
  0191b	8b 49 48	 mov	 ecx, DWORD PTR [ecx+72]
  0191e	d3 e2		 shl	 edx, cl
  01920	83 ea 01	 sub	 edx, 1
  01923	23 55 d8	 and	 edx, DWORD PTR _hold$[ebp]
  01926	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01929	03 50 44	 add	 edx, DWORD PTR [eax+68]
  0192c	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  0192f	89 51 44	 mov	 DWORD PTR [ecx+68], edx
$LN63@inflate:

; 1030 :                 DROPBITS(state->extra);

  01932	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01935	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  01938	8b 4a 48	 mov	 ecx, DWORD PTR [edx+72]
  0193b	d3 e8		 shr	 eax, cl
  0193d	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01940	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01943	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01946	2b 51 48	 sub	 edx, DWORD PTR [ecx+72]
  01949	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  0194c	33 c0		 xor	 eax, eax
  0194e	75 e2		 jne	 SHORT $LN63@inflate
$LN73@inflate:

; 1031 :             }
; 1032 : #ifdef INFLATE_STRICT
; 1033 :             if (state->offset > state->dmax) {
; 1034 :                 strm->msg = (char *)"invalid distance too far back";
; 1035 :                 state->mode = BAD;
; 1036 :                 break;
; 1037 :             }
; 1038 : #endif
; 1039 :             if (state->offset > state->whave + out - left) {

  01950	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01953	8b 51 2c	 mov	 edx, DWORD PTR [ecx+44]
  01956	03 55 c4	 add	 edx, DWORD PTR _out$[ebp]
  01959	2b 55 e4	 sub	 edx, DWORD PTR _left$[ebp]
  0195c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0195f	39 50 44	 cmp	 DWORD PTR [eax+68], edx
  01962	76 18		 jbe	 SHORT $LN60@inflate

; 1040 :                 strm->msg = (char *)"invalid distance too far back";

  01964	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01967	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BO@ECPMAOGG@invalid?5distance?5too?5far?5back?$AA@

; 1041 :                 state->mode = BAD;

  0196e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01971	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 1042 :                 break;

  01977	e9 53 03 00 00	 jmp	 $LN484@inflate
$LN60@inflate:

; 1043 :             }
; 1044 :             Tracevv((stderr, "inflate:         distance %u\n", state->offset));
; 1045 :             state->mode = MATCH;

  0197c	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  0197f	c7 00 16 00 00
	00		 mov	 DWORD PTR [eax], 22	; 00000016H
$LN59@inflate:

; 1046 :         case MATCH:
; 1047 :             if (left == 0) goto inf_leave;

  01985	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  01989	75 05		 jne	 SHORT $LN58@inflate
  0198b	e9 44 03 00 00	 jmp	 $inf_leave$77660
$LN58@inflate:

; 1048 :             copy = out - left;

  01990	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01993	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  01996	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx

; 1049 :             if (state->offset > copy) {         /* copy from window */

  01999	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  0199c	8b 42 44	 mov	 eax, DWORD PTR [edx+68]
  0199f	3b 45 cc	 cmp	 eax, DWORD PTR _copy$[ebp]
  019a2	76 5f		 jbe	 SHORT $LN57@inflate

; 1050 :                 copy = state->offset - copy;

  019a4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019a7	8b 51 44	 mov	 edx, DWORD PTR [ecx+68]
  019aa	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  019ad	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx

; 1051 :                 if (copy > state->write) {

  019b0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019b3	8b 4d cc	 mov	 ecx, DWORD PTR _copy$[ebp]
  019b6	3b 48 30	 cmp	 ecx, DWORD PTR [eax+48]
  019b9	76 20		 jbe	 SHORT $LN56@inflate

; 1052 :                     copy -= state->write;

  019bb	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  019be	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  019c1	2b 42 30	 sub	 eax, DWORD PTR [edx+48]
  019c4	89 45 cc	 mov	 DWORD PTR _copy$[ebp], eax

; 1053 :                     from = state->window + (state->wsize - copy);

  019c7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019ca	8b 51 28	 mov	 edx, DWORD PTR [ecx+40]
  019cd	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  019d0	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019d3	03 50 34	 add	 edx, DWORD PTR [eax+52]
  019d6	89 55 c8	 mov	 DWORD PTR _from$[ebp], edx

; 1054 :                 }
; 1055 :                 else

  019d9	eb 12		 jmp	 SHORT $LN55@inflate
$LN56@inflate:

; 1056 :                     from = state->window + (state->write - copy);

  019db	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019de	8b 51 30	 mov	 edx, DWORD PTR [ecx+48]
  019e1	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  019e4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019e7	03 50 34	 add	 edx, DWORD PTR [eax+52]
  019ea	89 55 c8	 mov	 DWORD PTR _from$[ebp], edx
$LN55@inflate:

; 1057 :                 if (copy > state->length) copy = state->length;

  019ed	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  019f0	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  019f3	3b 51 40	 cmp	 edx, DWORD PTR [ecx+64]
  019f6	76 09		 jbe	 SHORT $LN54@inflate
  019f8	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  019fb	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  019fe	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN54@inflate:

; 1058 :             }
; 1059 :             else {                              /* copy from output */

  01a01	eb 15		 jmp	 SHORT $LN53@inflate
$LN57@inflate:

; 1060 :                 from = put - state->offset;

  01a03	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a06	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01a09	2b 42 44	 sub	 eax, DWORD PTR [edx+68]
  01a0c	89 45 c8	 mov	 DWORD PTR _from$[ebp], eax

; 1061 :                 copy = state->length;

  01a0f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a12	8b 51 40	 mov	 edx, DWORD PTR [ecx+64]
  01a15	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
$LN53@inflate:

; 1062 :             }
; 1063 :             if (copy > left) copy = left;

  01a18	8b 45 cc	 mov	 eax, DWORD PTR _copy$[ebp]
  01a1b	3b 45 e4	 cmp	 eax, DWORD PTR _left$[ebp]
  01a1e	76 06		 jbe	 SHORT $LN52@inflate
  01a20	8b 4d e4	 mov	 ecx, DWORD PTR _left$[ebp]
  01a23	89 4d cc	 mov	 DWORD PTR _copy$[ebp], ecx
$LN52@inflate:

; 1064 :             left -= copy;

  01a26	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01a29	2b 55 cc	 sub	 edx, DWORD PTR _copy$[ebp]
  01a2c	89 55 e4	 mov	 DWORD PTR _left$[ebp], edx

; 1065 :             state->length -= copy;

  01a2f	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a32	8b 48 40	 mov	 ecx, DWORD PTR [eax+64]
  01a35	2b 4d cc	 sub	 ecx, DWORD PTR _copy$[ebp]
  01a38	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01a3b	89 4a 40	 mov	 DWORD PTR [edx+64], ecx
$LN51@inflate:

; 1066 :             do {
; 1067 :                 *put++ = *from++;

  01a3e	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01a41	8b 4d c8	 mov	 ecx, DWORD PTR _from$[ebp]
  01a44	8a 11		 mov	 dl, BYTE PTR [ecx]
  01a46	88 10		 mov	 BYTE PTR [eax], dl
  01a48	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01a4b	83 c0 01	 add	 eax, 1
  01a4e	89 45 fc	 mov	 DWORD PTR _put$[ebp], eax
  01a51	8b 4d c8	 mov	 ecx, DWORD PTR _from$[ebp]
  01a54	83 c1 01	 add	 ecx, 1
  01a57	89 4d c8	 mov	 DWORD PTR _from$[ebp], ecx

; 1068 :             } while (--copy);

  01a5a	8b 55 cc	 mov	 edx, DWORD PTR _copy$[ebp]
  01a5d	83 ea 01	 sub	 edx, 1
  01a60	89 55 cc	 mov	 DWORD PTR _copy$[ebp], edx
  01a63	75 d9		 jne	 SHORT $LN51@inflate

; 1069 :             if (state->length == 0) state->mode = LEN;

  01a65	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a68	83 78 40 00	 cmp	 DWORD PTR [eax+64], 0
  01a6c	75 09		 jne	 SHORT $LN48@inflate
  01a6e	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01a71	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H
$LN48@inflate:

; 1070 :             break;

  01a77	e9 53 02 00 00	 jmp	 $LN484@inflate
$LN47@inflate:

; 1071 :         case LIT:
; 1072 :             if (left == 0) goto inf_leave;

  01a7c	83 7d e4 00	 cmp	 DWORD PTR _left$[ebp], 0
  01a80	75 05		 jne	 SHORT $LN46@inflate
  01a82	e9 4d 02 00 00	 jmp	 $inf_leave$77660
$LN46@inflate:

; 1073 :             *put++ = (unsigned char)(state->length);

  01a87	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01a8a	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01a8d	8a 48 40	 mov	 cl, BYTE PTR [eax+64]
  01a90	88 0a		 mov	 BYTE PTR [edx], cl
  01a92	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01a95	83 c2 01	 add	 edx, 1
  01a98	89 55 fc	 mov	 DWORD PTR _put$[ebp], edx

; 1074 :             left--;

  01a9b	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  01a9e	83 e8 01	 sub	 eax, 1
  01aa1	89 45 e4	 mov	 DWORD PTR _left$[ebp], eax

; 1075 :             state->mode = LEN;

  01aa4	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01aa7	c7 01 12 00 00
	00		 mov	 DWORD PTR [ecx], 18	; 00000012H

; 1076 :             break;

  01aad	e9 1d 02 00 00	 jmp	 $LN484@inflate
$LN45@inflate:

; 1077 :         case CHECK:
; 1078 :             if (state->wrap) {

  01ab2	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01ab5	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  01ab9	0f 84 49 01 00
	00		 je	 $LN44@inflate
$LN40@inflate:

; 1079 :                 NEEDBITS(32);

  01abf	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01ac3	73 3d		 jae	 SHORT $LN42@inflate
$LN38@inflate:
  01ac5	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01ac9	75 05		 jne	 SHORT $LN35@inflate
  01acb	e9 04 02 00 00	 jmp	 $inf_leave$77660
$LN35@inflate:
  01ad0	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  01ad3	83 e8 01	 sub	 eax, 1
  01ad6	89 45 f4	 mov	 DWORD PTR _have$[ebp], eax
  01ad9	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  01adc	0f b6 11	 movzx	 edx, BYTE PTR [ecx]
  01adf	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01ae2	d3 e2		 shl	 edx, cl
  01ae4	03 55 d8	 add	 edx, DWORD PTR _hold$[ebp]
  01ae7	89 55 d8	 mov	 DWORD PTR _hold$[ebp], edx
  01aea	8b 45 e0	 mov	 eax, DWORD PTR _next$[ebp]
  01aed	83 c0 01	 add	 eax, 1
  01af0	89 45 e0	 mov	 DWORD PTR _next$[ebp], eax
  01af3	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01af6	83 c1 08	 add	 ecx, 8
  01af9	89 4d e8	 mov	 DWORD PTR _bits$[ebp], ecx
  01afc	33 d2		 xor	 edx, edx
  01afe	75 c5		 jne	 SHORT $LN38@inflate
  01b00	eb bd		 jmp	 SHORT $LN40@inflate
$LN42@inflate:
  01b02	33 c0		 xor	 eax, eax
  01b04	75 b9		 jne	 SHORT $LN40@inflate

; 1080 :                 out -= left;

  01b06	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01b09	2b 4d e4	 sub	 ecx, DWORD PTR _left$[ebp]
  01b0c	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 1081 :                 strm->total_out += out;

  01b0f	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01b12	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01b15	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01b18	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01b1b	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1082 :                 state->total += out;

  01b1e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b21	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01b24	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01b27	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b2a	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1083 :                 if (out)

  01b2d	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01b31	74 51		 je	 SHORT $LN34@inflate

; 1084 :                     strm->adler = state->check =
; 1085 :                         UPDATE(state->check, put - out, out);

  01b33	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b36	83 7a 10 00	 cmp	 DWORD PTR [edx+16], 0
  01b3a	74 1c		 je	 SHORT $LN498@inflate
  01b3c	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01b3f	50		 push	 eax
  01b40	8b 4d fc	 mov	 ecx, DWORD PTR _put$[ebp]
  01b43	2b 4d c4	 sub	 ecx, DWORD PTR _out$[ebp]
  01b46	51		 push	 ecx
  01b47	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b4a	8b 42 18	 mov	 eax, DWORD PTR [edx+24]
  01b4d	50		 push	 eax
  01b4e	e8 00 00 00 00	 call	 _crc32@12
  01b53	89 45 b0	 mov	 DWORD PTR tv1191[ebp], eax
  01b56	eb 1a		 jmp	 SHORT $LN499@inflate
$LN498@inflate:
  01b58	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01b5b	51		 push	 ecx
  01b5c	8b 55 fc	 mov	 edx, DWORD PTR _put$[ebp]
  01b5f	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01b62	52		 push	 edx
  01b63	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01b66	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01b69	51		 push	 ecx
  01b6a	e8 00 00 00 00	 call	 _adler32@12
  01b6f	89 45 b0	 mov	 DWORD PTR tv1191[ebp], eax
$LN499@inflate:
  01b72	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01b75	8b 45 b0	 mov	 eax, DWORD PTR tv1191[ebp]
  01b78	89 42 18	 mov	 DWORD PTR [edx+24], eax
  01b7b	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01b7e	8b 55 b0	 mov	 edx, DWORD PTR tv1191[ebp]
  01b81	89 51 30	 mov	 DWORD PTR [ecx+48], edx
$LN34@inflate:

; 1086 :                 out = left;

  01b84	8b 45 e4	 mov	 eax, DWORD PTR _left$[ebp]
  01b87	89 45 c4	 mov	 DWORD PTR _out$[ebp], eax

; 1087 :                 if ((
; 1088 : #ifdef GUNZIP
; 1089 :                      state->flags ? hold :
; 1090 : #endif
; 1091 :                      REVERSE(hold)) != state->check) {

  01b8a	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01b8d	83 79 10 00	 cmp	 DWORD PTR [ecx+16], 0
  01b91	74 08		 je	 SHORT $LN500@inflate
  01b93	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  01b96	89 55 ac	 mov	 DWORD PTR tv1205[ebp], edx
  01b99	eb 38		 jmp	 SHORT $LN501@inflate
$LN500@inflate:
  01b9b	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  01b9e	c1 e8 18	 shr	 eax, 24			; 00000018H
  01ba1	25 ff 00 00 00	 and	 eax, 255		; 000000ffH
  01ba6	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01ba9	c1 e9 08	 shr	 ecx, 8
  01bac	81 e1 00 ff 00
	00		 and	 ecx, 65280		; 0000ff00H
  01bb2	03 c1		 add	 eax, ecx
  01bb4	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  01bb7	81 e2 00 ff 00
	00		 and	 edx, 65280		; 0000ff00H
  01bbd	c1 e2 08	 shl	 edx, 8
  01bc0	03 c2		 add	 eax, edx
  01bc2	8b 4d d8	 mov	 ecx, DWORD PTR _hold$[ebp]
  01bc5	81 e1 ff 00 00
	00		 and	 ecx, 255		; 000000ffH
  01bcb	c1 e1 18	 shl	 ecx, 24			; 00000018H
  01bce	03 c1		 add	 eax, ecx
  01bd0	89 45 ac	 mov	 DWORD PTR tv1205[ebp], eax
$LN501@inflate:
  01bd3	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01bd6	8b 45 ac	 mov	 eax, DWORD PTR tv1205[ebp]
  01bd9	3b 42 18	 cmp	 eax, DWORD PTR [edx+24]
  01bdc	74 18		 je	 SHORT $LN32@inflate

; 1092 :                     strm->msg = (char *)"incorrect data check";

  01bde	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01be1	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BF@MEIGEHBE@incorrect?5data?5check?$AA@

; 1093 :                     state->mode = BAD;

  01be8	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01beb	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 1094 :                     break;

  01bf1	e9 d9 00 00 00	 jmp	 $LN484@inflate
$LN32@inflate:

; 1095 :                 }
; 1096 :                 INITBITS();

  01bf6	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01bfd	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01c04	33 c0		 xor	 eax, eax
  01c06	75 ee		 jne	 SHORT $LN32@inflate
$LN44@inflate:

; 1097 :                 Tracev((stderr, "inflate:   check matches trailer\n"));
; 1098 :             }
; 1099 : #ifdef GUNZIP
; 1100 :             state->mode = LENGTH;

  01c08	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01c0b	c7 01 19 00 00
	00		 mov	 DWORD PTR [ecx], 25	; 00000019H
$LN29@inflate:

; 1101 :         case LENGTH:
; 1102 :             if (state->wrap && state->flags) {

  01c11	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c14	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  01c18	0f 84 82 00 00
	00		 je	 $LN28@inflate
  01c1e	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01c21	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01c25	74 79		 je	 SHORT $LN28@inflate
$LN24@inflate:

; 1103 :                 NEEDBITS(32);

  01c27	83 7d e8 20	 cmp	 DWORD PTR _bits$[ebp], 32 ; 00000020H
  01c2b	73 3d		 jae	 SHORT $LN26@inflate
$LN22@inflate:
  01c2d	83 7d f4 00	 cmp	 DWORD PTR _have$[ebp], 0
  01c31	75 05		 jne	 SHORT $LN19@inflate
  01c33	e9 9c 00 00 00	 jmp	 $inf_leave$77660
$LN19@inflate:
  01c38	8b 4d f4	 mov	 ecx, DWORD PTR _have$[ebp]
  01c3b	83 e9 01	 sub	 ecx, 1
  01c3e	89 4d f4	 mov	 DWORD PTR _have$[ebp], ecx
  01c41	8b 55 e0	 mov	 edx, DWORD PTR _next$[ebp]
  01c44	0f b6 02	 movzx	 eax, BYTE PTR [edx]
  01c47	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01c4a	d3 e0		 shl	 eax, cl
  01c4c	03 45 d8	 add	 eax, DWORD PTR _hold$[ebp]
  01c4f	89 45 d8	 mov	 DWORD PTR _hold$[ebp], eax
  01c52	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  01c55	83 c1 01	 add	 ecx, 1
  01c58	89 4d e0	 mov	 DWORD PTR _next$[ebp], ecx
  01c5b	8b 55 e8	 mov	 edx, DWORD PTR _bits$[ebp]
  01c5e	83 c2 08	 add	 edx, 8
  01c61	89 55 e8	 mov	 DWORD PTR _bits$[ebp], edx
  01c64	33 c0		 xor	 eax, eax
  01c66	75 c5		 jne	 SHORT $LN22@inflate
  01c68	eb bd		 jmp	 SHORT $LN24@inflate
$LN26@inflate:
  01c6a	33 c9		 xor	 ecx, ecx
  01c6c	75 b9		 jne	 SHORT $LN24@inflate

; 1104 :                 if (hold != (state->total & 0xffffffffUL)) {

  01c6e	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c71	8b 45 d8	 mov	 eax, DWORD PTR _hold$[ebp]
  01c74	3b 42 1c	 cmp	 eax, DWORD PTR [edx+28]
  01c77	74 15		 je	 SHORT $LN17@inflate

; 1105 :                     strm->msg = (char *)"incorrect length check";

  01c79	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01c7c	c7 41 18 00 00
	00 00		 mov	 DWORD PTR [ecx+24], OFFSET ??_C@_0BH@FGKKJGOC@incorrect?5length?5check?$AA@

; 1106 :                     state->mode = BAD;

  01c83	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01c86	c7 02 1b 00 00
	00		 mov	 DWORD PTR [edx], 27	; 0000001bH

; 1107 :                     break;

  01c8c	eb 41		 jmp	 SHORT $LN484@inflate
$LN17@inflate:

; 1108 :                 }
; 1109 :                 INITBITS();

  01c8e	c7 45 d8 00 00
	00 00		 mov	 DWORD PTR _hold$[ebp], 0
  01c95	c7 45 e8 00 00
	00 00		 mov	 DWORD PTR _bits$[ebp], 0
  01c9c	33 c0		 xor	 eax, eax
  01c9e	75 ee		 jne	 SHORT $LN17@inflate
$LN28@inflate:

; 1110 :                 Tracev((stderr, "inflate:   length matches trailer\n"));
; 1111 :             }
; 1112 : #endif
; 1113 :             state->mode = DONE;

  01ca0	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01ca3	c7 01 1a 00 00
	00		 mov	 DWORD PTR [ecx], 26	; 0000001aH
$LN14@inflate:

; 1114 :         case DONE:
; 1115 :             ret = Z_STREAM_END;

  01ca9	c7 45 dc 01 00
	00 00		 mov	 DWORD PTR _ret$[ebp], 1

; 1116 :             goto inf_leave;

  01cb0	eb 22		 jmp	 SHORT $inf_leave$77660
$LN13@inflate:

; 1117 :         case BAD:
; 1118 :             ret = Z_DATA_ERROR;

  01cb2	c7 45 dc fd ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -3 ; fffffffdH

; 1119 :             goto inf_leave;

  01cb9	eb 19		 jmp	 SHORT $inf_leave$77660
$LN12@inflate:

; 1120 :         case MEM:
; 1121 :             return Z_MEM_ERROR;

  01cbb	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01cc0	e9 89 01 00 00	 jmp	 $LN494@inflate
$LN11@inflate:

; 1122 :         case SYNC:
; 1123 :         default:
; 1124 :             return Z_STREAM_ERROR;

  01cc5	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  01cca	e9 7f 01 00 00	 jmp	 $LN494@inflate
$LN484@inflate:

; 1125 :         }

  01ccf	e9 cb e3 ff ff	 jmp	 $LN487@inflate
$inf_leave$77660:

; 1126 : 
; 1127 :     /*
; 1128 :        Return from inflate(), updating the total counts and the check value.
; 1129 :        If there was no progress during the inflate() call, return a buffer
; 1130 :        error.  Call updatewindow() to create and/or update the window state.
; 1131 :        Note: a memory error from inflate() is non-recoverable.
; 1132 :      */
; 1133 :   inf_leave:
; 1134 :     RESTORE();

  01cd4	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01cd7	8b 45 fc	 mov	 eax, DWORD PTR _put$[ebp]
  01cda	89 42 0c	 mov	 DWORD PTR [edx+12], eax
  01cdd	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01ce0	8b 55 e4	 mov	 edx, DWORD PTR _left$[ebp]
  01ce3	89 51 10	 mov	 DWORD PTR [ecx+16], edx
  01ce6	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01ce9	8b 4d e0	 mov	 ecx, DWORD PTR _next$[ebp]
  01cec	89 08		 mov	 DWORD PTR [eax], ecx
  01cee	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01cf1	8b 45 f4	 mov	 eax, DWORD PTR _have$[ebp]
  01cf4	89 42 04	 mov	 DWORD PTR [edx+4], eax
  01cf7	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01cfa	8b 55 d8	 mov	 edx, DWORD PTR _hold$[ebp]
  01cfd	89 51 38	 mov	 DWORD PTR [ecx+56], edx
  01d00	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d03	8b 4d e8	 mov	 ecx, DWORD PTR _bits$[ebp]
  01d06	89 48 3c	 mov	 DWORD PTR [eax+60], ecx
  01d09	33 d2		 xor	 edx, edx
  01d0b	75 c7		 jne	 SHORT $inf_leave$77660

; 1135 :     if (state->wsize || (state->mode < CHECK && out != strm->avail_out))

  01d0d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d10	83 78 28 00	 cmp	 DWORD PTR [eax+40], 0
  01d14	75 13		 jne	 SHORT $LN6@inflate
  01d16	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d19	83 39 18	 cmp	 DWORD PTR [ecx], 24	; 00000018H
  01d1c	7d 32		 jge	 SHORT $LN7@inflate
  01d1e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01d21	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01d24	3b 42 10	 cmp	 eax, DWORD PTR [edx+16]
  01d27	74 27		 je	 SHORT $LN7@inflate
$LN6@inflate:

; 1136 :         if (updatewindow(strm, out)) {

  01d29	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01d2c	51		 push	 ecx
  01d2d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01d30	52		 push	 edx
  01d31	e8 00 00 00 00	 call	 _updatewindow
  01d36	83 c4 08	 add	 esp, 8
  01d39	85 c0		 test	 eax, eax
  01d3b	74 13		 je	 SHORT $LN7@inflate

; 1137 :             state->mode = MEM;

  01d3d	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01d40	c7 00 1c 00 00
	00		 mov	 DWORD PTR [eax], 28	; 0000001cH

; 1138 :             return Z_MEM_ERROR;

  01d46	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  01d4b	e9 fe 00 00 00	 jmp	 $LN494@inflate
$LN7@inflate:

; 1139 :         }
; 1140 :     in -= strm->avail_in;

  01d50	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01d53	8b 55 f0	 mov	 edx, DWORD PTR _in$[ebp]
  01d56	2b 51 04	 sub	 edx, DWORD PTR [ecx+4]
  01d59	89 55 f0	 mov	 DWORD PTR _in$[ebp], edx

; 1141 :     out -= strm->avail_out;

  01d5c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  01d5f	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01d62	2b 48 10	 sub	 ecx, DWORD PTR [eax+16]
  01d65	89 4d c4	 mov	 DWORD PTR _out$[ebp], ecx

; 1142 :     strm->total_in += in;

  01d68	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01d6b	8b 42 08	 mov	 eax, DWORD PTR [edx+8]
  01d6e	03 45 f0	 add	 eax, DWORD PTR _in$[ebp]
  01d71	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01d74	89 41 08	 mov	 DWORD PTR [ecx+8], eax

; 1143 :     strm->total_out += out;

  01d77	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01d7a	8b 42 14	 mov	 eax, DWORD PTR [edx+20]
  01d7d	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01d80	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01d83	89 41 14	 mov	 DWORD PTR [ecx+20], eax

; 1144 :     state->total += out;

  01d86	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d89	8b 42 1c	 mov	 eax, DWORD PTR [edx+28]
  01d8c	03 45 c4	 add	 eax, DWORD PTR _out$[ebp]
  01d8f	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01d92	89 41 1c	 mov	 DWORD PTR [ecx+28], eax

; 1145 :     if (state->wrap && out)

  01d95	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01d98	83 7a 08 00	 cmp	 DWORD PTR [edx+8], 0
  01d9c	74 5d		 je	 SHORT $LN4@inflate
  01d9e	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01da2	74 57		 je	 SHORT $LN4@inflate

; 1146 :         strm->adler = state->check =
; 1147 :             UPDATE(state->check, strm->next_out - out, out);

  01da4	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01da7	83 78 10 00	 cmp	 DWORD PTR [eax+16], 0
  01dab	74 1f		 je	 SHORT $LN502@inflate
  01dad	8b 4d c4	 mov	 ecx, DWORD PTR _out$[ebp]
  01db0	51		 push	 ecx
  01db1	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  01db4	8b 42 0c	 mov	 eax, DWORD PTR [edx+12]
  01db7	2b 45 c4	 sub	 eax, DWORD PTR _out$[ebp]
  01dba	50		 push	 eax
  01dbb	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01dbe	8b 51 18	 mov	 edx, DWORD PTR [ecx+24]
  01dc1	52		 push	 edx
  01dc2	e8 00 00 00 00	 call	 _crc32@12
  01dc7	89 45 a8	 mov	 DWORD PTR tv1278[ebp], eax
  01dca	eb 1d		 jmp	 SHORT $LN503@inflate
$LN502@inflate:
  01dcc	8b 45 c4	 mov	 eax, DWORD PTR _out$[ebp]
  01dcf	50		 push	 eax
  01dd0	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01dd3	8b 51 0c	 mov	 edx, DWORD PTR [ecx+12]
  01dd6	2b 55 c4	 sub	 edx, DWORD PTR _out$[ebp]
  01dd9	52		 push	 edx
  01dda	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01ddd	8b 48 18	 mov	 ecx, DWORD PTR [eax+24]
  01de0	51		 push	 ecx
  01de1	e8 00 00 00 00	 call	 _adler32@12
  01de6	89 45 a8	 mov	 DWORD PTR tv1278[ebp], eax
$LN503@inflate:
  01de9	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01dec	8b 45 a8	 mov	 eax, DWORD PTR tv1278[ebp]
  01def	89 42 18	 mov	 DWORD PTR [edx+24], eax
  01df2	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01df5	8b 55 a8	 mov	 edx, DWORD PTR tv1278[ebp]
  01df8	89 51 30	 mov	 DWORD PTR [ecx+48], edx
$LN4@inflate:

; 1148 :     strm->data_type = state->bits + (state->last ? 64 : 0) +
; 1149 :                       (state->mode == TYPE ? 128 : 0);

  01dfb	8b 45 c0	 mov	 eax, DWORD PTR _state$[ebp]
  01dfe	8b 48 04	 mov	 ecx, DWORD PTR [eax+4]
  01e01	f7 d9		 neg	 ecx
  01e03	1b c9		 sbb	 ecx, ecx
  01e05	83 e1 40	 and	 ecx, 64			; 00000040H
  01e08	8b 55 c0	 mov	 edx, DWORD PTR _state$[ebp]
  01e0b	8b 42 3c	 mov	 eax, DWORD PTR [edx+60]
  01e0e	03 c1		 add	 eax, ecx
  01e10	8b 4d c0	 mov	 ecx, DWORD PTR _state$[ebp]
  01e13	33 d2		 xor	 edx, edx
  01e15	83 39 0b	 cmp	 DWORD PTR [ecx], 11	; 0000000bH
  01e18	0f 95 c2	 setne	 dl
  01e1b	83 ea 01	 sub	 edx, 1
  01e1e	81 e2 80 00 00
	00		 and	 edx, 128		; 00000080H
  01e24	03 c2		 add	 eax, edx
  01e26	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  01e29	89 41 2c	 mov	 DWORD PTR [ecx+44], eax

; 1150 :     if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)

  01e2c	83 7d f0 00	 cmp	 DWORD PTR _in$[ebp], 0
  01e30	75 06		 jne	 SHORT $LN1@inflate
  01e32	83 7d c4 00	 cmp	 DWORD PTR _out$[ebp], 0
  01e36	74 06		 je	 SHORT $LN2@inflate
$LN1@inflate:
  01e38	83 7d 0c 04	 cmp	 DWORD PTR _flush$[ebp], 4
  01e3c	75 0d		 jne	 SHORT $LN3@inflate
$LN2@inflate:
  01e3e	83 7d dc 00	 cmp	 DWORD PTR _ret$[ebp], 0
  01e42	75 07		 jne	 SHORT $LN3@inflate

; 1151 :         ret = Z_BUF_ERROR;

  01e44	c7 45 dc fb ff
	ff ff		 mov	 DWORD PTR _ret$[ebp], -5 ; fffffffbH
$LN3@inflate:

; 1152 :     return ret;

  01e4b	8b 45 dc	 mov	 eax, DWORD PTR _ret$[ebp]
$LN494@inflate:

; 1153 : }

  01e4e	8b e5		 mov	 esp, ebp
  01e50	5d		 pop	 ebp
  01e51	c2 08 00	 ret	 8
$LN504@inflate:
  01e54	00 00 00 00	 DD	 $LN483@inflate
  01e58	00 00 00 00	 DD	 $LN450@inflate
  01e5c	00 00 00 00	 DD	 $LN430@inflate
  01e60	00 00 00 00	 DD	 $LN412@inflate
  01e64	00 00 00 00	 DD	 $LN398@inflate
  01e68	00 00 00 00	 DD	 $LN377@inflate
  01e6c	00 00 00 00	 DD	 $LN370@inflate
  01e70	00 00 00 00	 DD	 $LN358@inflate
  01e74	00 00 00 00	 DD	 $LN346@inflate
  01e78	00 00 00 00	 DD	 $LN326@inflate
  01e7c	00 00 00 00	 DD	 $LN317@inflate
  01e80	00 00 00 00	 DD	 $LN312@inflate
  01e84	00 00 00 00	 DD	 $LN310@inflate
  01e88	00 00 00 00	 DD	 $LN283@inflate
  01e8c	00 00 00 00	 DD	 $LN267@inflate
  01e90	00 00 00 00	 DD	 $LN258@inflate
  01e94	00 00 00 00	 DD	 $LN240@inflate
  01e98	00 00 00 00	 DD	 $LN222@inflate
  01e9c	00 00 00 00	 DD	 $LN143@inflate
  01ea0	00 00 00 00	 DD	 $LN111@inflate
  01ea4	00 00 00 00	 DD	 $LN96@inflate
  01ea8	00 00 00 00	 DD	 $LN74@inflate
  01eac	00 00 00 00	 DD	 $LN59@inflate
  01eb0	00 00 00 00	 DD	 $LN47@inflate
  01eb4	00 00 00 00	 DD	 $LN45@inflate
  01eb8	00 00 00 00	 DD	 $LN29@inflate
  01ebc	00 00 00 00	 DD	 $LN14@inflate
  01ec0	00 00 00 00	 DD	 $LN13@inflate
  01ec4	00 00 00 00	 DD	 $LN12@inflate
$LN505@inflate:
  01ec8	00 00 00 00	 DD	 $LN291@inflate
  01ecc	00 00 00 00	 DD	 $LN290@inflate
  01ed0	00 00 00 00	 DD	 $LN289@inflate
  01ed4	00 00 00 00	 DD	 $LN288@inflate
_inflate@8 ENDP
_TEXT	ENDS
PUBLIC	_inflateInit2_@16
; Function compile flags: /Odtp
;	COMDAT _inflateInit2_@16
_TEXT	SEGMENT
_state$ = -4						; size = 4
_strm$ = 8						; size = 4
_windowBits$ = 12					; size = 4
_version$ = 16						; size = 4
_stream_size$ = 20					; size = 4
_inflateInit2_@16 PROC					; COMDAT

; 149  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp
  00003	51		 push	 ecx

; 150  :     struct inflate_state FAR *state;
; 151  : 
; 152  :     if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
; 153  :         stream_size != (int)(sizeof(z_stream)))

  00004	83 7d 10 00	 cmp	 DWORD PTR _version$[ebp], 0
  00008	74 17		 je	 SHORT $LN10@inflateIni
  0000a	8b 45 10	 mov	 eax, DWORD PTR _version$[ebp]
  0000d	0f be 08	 movsx	 ecx, BYTE PTR [eax]
  00010	0f be 15 00 00
	00 00		 movsx	 edx, BYTE PTR ??_C@_05GDHACFMB@1?42?43?$AA@
  00017	3b ca		 cmp	 ecx, edx
  00019	75 06		 jne	 SHORT $LN10@inflateIni
  0001b	83 7d 14 38	 cmp	 DWORD PTR _stream_size$[ebp], 56 ; 00000038H
  0001f	74 0a		 je	 SHORT $LN11@inflateIni
$LN10@inflateIni:

; 154  :         return Z_VERSION_ERROR;

  00021	b8 fa ff ff ff	 mov	 eax, -6			; fffffffaH
  00026	e9 06 01 00 00	 jmp	 $LN12@inflateIni
$LN11@inflateIni:

; 155  :     if (strm == Z_NULL) return Z_STREAM_ERROR;

  0002b	83 7d 08 00	 cmp	 DWORD PTR _strm$[ebp], 0
  0002f	75 0a		 jne	 SHORT $LN9@inflateIni
  00031	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00036	e9 f6 00 00 00	 jmp	 $LN12@inflateIni
$LN9@inflateIni:

; 156  :     strm->msg = Z_NULL;                 /* in case we return an error */

  0003b	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0003e	c7 40 18 00 00
	00 00		 mov	 DWORD PTR [eax+24], 0

; 157  :     if (strm->zalloc == (alloc_func)0) {

  00045	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00048	83 79 20 00	 cmp	 DWORD PTR [ecx+32], 0
  0004c	75 14		 jne	 SHORT $LN8@inflateIni

; 158  :         strm->zalloc = zcalloc;

  0004e	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00051	c7 42 20 00 00
	00 00		 mov	 DWORD PTR [edx+32], OFFSET _zcalloc

; 159  :         strm->opaque = (voidpf)0;

  00058	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0005b	c7 40 28 00 00
	00 00		 mov	 DWORD PTR [eax+40], 0
$LN8@inflateIni:

; 160  :     }
; 161  :     if (strm->zfree == (free_func)0) strm->zfree = zcfree;

  00062	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00065	83 79 24 00	 cmp	 DWORD PTR [ecx+36], 0
  00069	75 0a		 jne	 SHORT $LN7@inflateIni
  0006b	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0006e	c7 42 24 00 00
	00 00		 mov	 DWORD PTR [edx+36], OFFSET _zcfree
$LN7@inflateIni:

; 162  :     state = (struct inflate_state FAR *)
; 163  :             ZALLOC(strm, 1, sizeof(struct inflate_state));

  00075	68 30 25 00 00	 push	 9520			; 00002530H
  0007a	6a 01		 push	 1
  0007c	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  0007f	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  00082	51		 push	 ecx
  00083	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00086	8b 42 20	 mov	 eax, DWORD PTR [edx+32]
  00089	ff d0		 call	 eax
  0008b	83 c4 0c	 add	 esp, 12			; 0000000cH
  0008e	89 45 fc	 mov	 DWORD PTR _state$[ebp], eax

; 164  :     if (state == Z_NULL) return Z_MEM_ERROR;

  00091	83 7d fc 00	 cmp	 DWORD PTR _state$[ebp], 0
  00095	75 0a		 jne	 SHORT $LN6@inflateIni
  00097	b8 fc ff ff ff	 mov	 eax, -4			; fffffffcH
  0009c	e9 90 00 00 00	 jmp	 $LN12@inflateIni
$LN6@inflateIni:

; 165  :     Tracev((stderr, "inflate: allocated\n"));
; 166  :     strm->state = (struct internal_state FAR *)state;

  000a1	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  000a4	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000a7	89 51 1c	 mov	 DWORD PTR [ecx+28], edx

; 167  :     if (windowBits < 0) {

  000aa	83 7d 0c 00	 cmp	 DWORD PTR _windowBits$[ebp], 0
  000ae	7d 14		 jge	 SHORT $LN5@inflateIni

; 168  :         state->wrap = 0;

  000b0	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000b3	c7 40 08 00 00
	00 00		 mov	 DWORD PTR [eax+8], 0

; 169  :         windowBits = -windowBits;

  000ba	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000bd	f7 d9		 neg	 ecx
  000bf	89 4d 0c	 mov	 DWORD PTR _windowBits$[ebp], ecx

; 170  :     }
; 171  :     else {

  000c2	eb 1e		 jmp	 SHORT $LN4@inflateIni
$LN5@inflateIni:

; 172  :         state->wrap = (windowBits >> 4) + 1;

  000c4	8b 55 0c	 mov	 edx, DWORD PTR _windowBits$[ebp]
  000c7	c1 fa 04	 sar	 edx, 4
  000ca	83 c2 01	 add	 edx, 1
  000cd	8b 45 fc	 mov	 eax, DWORD PTR _state$[ebp]
  000d0	89 50 08	 mov	 DWORD PTR [eax+8], edx

; 173  : #ifdef GUNZIP
; 174  :         if (windowBits < 48) windowBits &= 15;

  000d3	83 7d 0c 30	 cmp	 DWORD PTR _windowBits$[ebp], 48 ; 00000030H
  000d7	7d 09		 jge	 SHORT $LN4@inflateIni
  000d9	8b 4d 0c	 mov	 ecx, DWORD PTR _windowBits$[ebp]
  000dc	83 e1 0f	 and	 ecx, 15			; 0000000fH
  000df	89 4d 0c	 mov	 DWORD PTR _windowBits$[ebp], ecx
$LN4@inflateIni:

; 175  : #endif
; 176  :     }
; 177  :     if (windowBits < 8 || windowBits > 15) {

  000e2	83 7d 0c 08	 cmp	 DWORD PTR _windowBits$[ebp], 8
  000e6	7c 06		 jl	 SHORT $LN1@inflateIni
  000e8	83 7d 0c 0f	 cmp	 DWORD PTR _windowBits$[ebp], 15 ; 0000000fH
  000ec	7e 27		 jle	 SHORT $LN2@inflateIni
$LN1@inflateIni:

; 178  :         ZFREE(strm, state);

  000ee	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  000f1	52		 push	 edx
  000f2	8b 45 08	 mov	 eax, DWORD PTR _strm$[ebp]
  000f5	8b 48 28	 mov	 ecx, DWORD PTR [eax+40]
  000f8	51		 push	 ecx
  000f9	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  000fc	8b 42 24	 mov	 eax, DWORD PTR [edx+36]
  000ff	ff d0		 call	 eax
  00101	83 c4 08	 add	 esp, 8

; 179  :         strm->state = Z_NULL;

  00104	8b 4d 08	 mov	 ecx, DWORD PTR _strm$[ebp]
  00107	c7 41 1c 00 00
	00 00		 mov	 DWORD PTR [ecx+28], 0

; 180  :         return Z_STREAM_ERROR;

  0010e	b8 fe ff ff ff	 mov	 eax, -2			; fffffffeH
  00113	eb 1c		 jmp	 SHORT $LN12@inflateIni
$LN2@inflateIni:

; 181  :     }
; 182  :     state->wbits = (unsigned)windowBits;

  00115	8b 55 fc	 mov	 edx, DWORD PTR _state$[ebp]
  00118	8b 45 0c	 mov	 eax, DWORD PTR _windowBits$[ebp]
  0011b	89 42 24	 mov	 DWORD PTR [edx+36], eax

; 183  :     state->window = Z_NULL;

  0011e	8b 4d fc	 mov	 ecx, DWORD PTR _state$[ebp]
  00121	c7 41 34 00 00
	00 00		 mov	 DWORD PTR [ecx+52], 0

; 184  :     return inflateReset(strm);

  00128	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  0012b	52		 push	 edx
  0012c	e8 00 00 00 00	 call	 _inflateReset@4
$LN12@inflateIni:

; 185  : }

  00131	8b e5		 mov	 esp, ebp
  00133	5d		 pop	 ebp
  00134	c2 10 00	 ret	 16			; 00000010H
_inflateInit2_@16 ENDP
PUBLIC	_inflateInit_@12
; Function compile flags: /Odtp
;	COMDAT _inflateInit_@12
_TEXT	SEGMENT
_strm$ = 8						; size = 4
_version$ = 12						; size = 4
_stream_size$ = 16					; size = 4
_inflateInit_@12 PROC					; COMDAT

; 191  : {

  00000	55		 push	 ebp
  00001	8b ec		 mov	 ebp, esp

; 192  :     return inflateInit2_(strm, DEF_WBITS, version, stream_size);

  00003	8b 45 10	 mov	 eax, DWORD PTR _stream_size$[ebp]
  00006	50		 push	 eax
  00007	8b 4d 0c	 mov	 ecx, DWORD PTR _version$[ebp]
  0000a	51		 push	 ecx
  0000b	6a 0f		 push	 15			; 0000000fH
  0000d	8b 55 08	 mov	 edx, DWORD PTR _strm$[ebp]
  00010	52		 push	 edx
  00011	e8 00 00 00 00	 call	 _inflateInit2_@16

; 193  : }

  00016	5d		 pop	 ebp
  00017	c2 0c 00	 ret	 12			; 0000000cH
_inflateInit_@12 ENDP
END
